"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _uu_appg01_core = require("uu_appg01_core");

var _Defaults = require("./Defaults.js");

var _Defaults2 = _interopRequireDefault(_Defaults);

var _ImplicitFlow = require("./flow/ImplicitFlow.js");

var _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);

var _SessionContext = require("./SessionContext.js");

var _SessionContext2 = _interopRequireDefault(_SessionContext);

var _Uuid = require("./util/Uuid.js");

var _Uuid2 = _interopRequireDefault(_Uuid);

var _Jwt = require("./jwt/Jwt.js");

var _Jwt2 = _interopRequireDefault(_Jwt);

var _InvalidTokenError = require("./jwt/InvalidTokenError.js");

var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

var _Jwks = require("./jwks/Jwks.js");

var _Jwks2 = _interopRequireDefault(_Jwks);

var _Discovery = require("./discovery/Discovery.js");

var _Discovery2 = _interopRequireDefault(_Discovery);

var _Os8Auth = require("./uuos8/Os8Auth.js");

var _Os8Auth2 = _interopRequireDefault(_Os8Auth);

var _Dom = require("./util/Dom.js");

var _Dom2 = _interopRequireDefault(_Dom);

var _PromiseUtil = require("./util/PromiseUtil.js");

var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

var _StringUtil = require("./util/StringUtil.js");

var _StringUtil2 = _interopRequireDefault(_StringUtil);

var _IframeComponent = require("./ui/IframeComponent.js");

var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Error = _uu_appg01_core.Error.Error;

var Session = function () {

  /**
   * Creates new Session with specified options.
   * 
   * @class UuOidc.Session
   * @classdesc
   * 
   * Session handling via OpenID Connect server.
   * 
   * **Configuration**
   * 
   * Login via OpenID Connect server **requires a special callback HTML page be present on the domain where application is running**. The callback
   * HTML page should be copied from the contents of this library (callbacks/oidc-callback.html) to the application and URL path to it must be
   * configured as described below - configuration parameter "uuoidc.redirectUri".
   * 
   * Following global configuration parameters are used for initializing {@link UuOidc.Session.currentSession Session.currentSession}:
   * 
   * * **uuoidc.clientId** - OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.
   *   Default is auto-generated which means that the application will be treated as an anonymous application and therefore might not be authorized for
   *   accessing most of user data.
   * * **uuoidc.redirectUri** - Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application
   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative
   *   to document.baseURI (current URL). Default is "callbacks/oidc-callback.html".
   * * **uuoidc.serverUri** - OpenID Connect server to perform login / logout against. Default is "https://oidc.plus4u.net/uu-oidcg01-main/0-0".
   * * **uuoidc.sessionCheckInterval** - how often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds. Default is 60.
   * 
   * @param options {Object|UuApp.Util.Config} Options.
   * @param options.serverUri OpenID Connect server to perform login / logout against.
   * @param options.clientId OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.
   * @param options.redirectUri Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application
   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative
   *   to document.baseURI (current URL).
   * @param options.sessionCheckInterval How often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.
   */
  function Session(options) {
    var _this = this;

    _classCallCheck(this, Session);

    if (!options) throw new Error("Session must be initialized with proper options or UuApp.Util.Config.");
    this._optionsMergedPromise = _PromiseUtil2.default.wrapForImmediateThen(Promise.resolve(options && typeof options.get == "function" ? options.initPromise : options).then(function (env) {
      if (env && typeof env.get == "function") {
        _this.serverUri = env.get("uuoidc.serverUri", false);
        _this.clientId = env.get("uuoidc.clientId", false);
        _this.implicitFlowRedirectUri = env.get("uuoidc.redirectUri", false);
        _this.sessionCheckInterval = env.get("uuoidc.sessionCheckInterval", false);
      } else if (env) {
        _this.serverUri = env["serverUri"];
        _this.clientId = env["clientId"];
        _this.implicitFlowRedirectUri = env["redirectUri"];
        _this.sessionCheckInterval = env["uuoidc.sessionCheckInterval"];
      }
      if (_this.serverUri == null) _this.serverUri = _Defaults2.default.serverUri;
      if (_this.clientId == null) _this.clientId = "uu-oidc:unregistered-client:" + (0, _Uuid2.default)();
      if (_this.sessionCheckInterval == null) _this.sessionCheckInterval = _Defaults2.default.sessionCheckInterval;
      if (!_this.implicitFlowRedirectUri) {
        // console.warn("Session login will work only with directly provided access token because no callback URL for OpenID Connect server was specified in" + 
        //   " the configuration. To support login via popup, specify redirectUri when creating session, or initialize UuApp.Util.Config with \"uuoidc.redirectUri\" option.");
        _this.implicitFlowRedirectUri = "callbacks/oidc-callback.html";
      }
      // if redirect URI is relative then absolutize it (relative to current document.baseURI)
      if (!_this.implicitFlowRedirectUri.match(/^[a-z]+:/i)) {
        // no protocol present
        var baseUrl = toFullUrl(document.baseURI || location.pathname).replace(/^([^?#]*\/).*/, "$1");
        if (_this.implicitFlowRedirectUri.charAt(0) != "/") _this.implicitFlowRedirectUri = toFullUrl(baseUrl + _this.implicitFlowRedirectUri);else _this.implicitFlowRedirectUri = toFullUrl(_this.implicitFlowRedirectUri);
      }

      // add session state checking which, in case that we were logged in and a logout
      // against OIDC is detected (e.g. in another browser tab), will log us out
      // TODO This is a hotfix solution - proper way is that there's a component scoped by serverUri which performs the session checks.
      var timeout = Math.max(5, _this.sessionCheckInterval) * 1000;
      var check = function () {
        var _this2 = this;

        // if not logged in then just plan another check (we don't want to auto-login in this tab if user logs in another browser tab)
        if (!this._loginCtx) return setTimeout(check, timeout);

        // check login state via login (but don't actually use the newly issued token)
        this._login({
          acr_values: "1",
          prompt: "none"
        }, false).then(function () {
          // still logged in => just plan another check
          setTimeout(check, timeout);
        }, function (e) {
          // assume logout
          delete _this2._loginCtx;
          _this2._runListeners();
          setTimeout(check, timeout);
        });
      }.bind(_this);
      setTimeout(check, timeout);
    }));
    this._loginInProgress = [];

    var listeners = [];
    /**
     * @return {boolean} True iff the user is authenticated (logged in).
     * @method UuOidc.Session#isAuthenticated
     */
    this.isAuthenticated = function () {
      return !!_this._loginCtx;
    };
    /**
     * Adds listener for changes of user identity (logins / logouts).
     * 
     * @param {Function(Object)} listener The listener function to add. The function receives identity object or null.
     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeIdentityChangeListener}).
     * @see UuOidc.Session#getIdentity
     * @method UuOidc.Session#addIdentityChangeListener
     */
    this.addIdentityChangeListener = function (listener) {
      listeners.push(listener);
      return _this.removeIdentityChangeListener.bind(_this, listener);
    };
    /**
     * Removes listener for changes of user identity (logins / logouts).
     * 
     * @param {Function(Object)} listener The listener to remove.
     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
     * @method UuOidc.Session#removeIdentityChangeListener
     */
    this.removeIdentityChangeListener = function (listener) {
      var idx = listeners.indexOf(listener);
      if (idx != -1) listeners.splice(idx, 1);
      return idx != -1;
    };
    this._runListeners = function () {
      var identity = _this.getIdentity();
      listeners.forEach(function (it) {
        return it.call(_this, identity);
      });
    };

    this.nonce = Math.random().toString(32).substr(2);

    // add planning & executing of token refresh when its nearing expiration
    // NOTE This assumes that each token refresh ends with running the identity-change listeners.
    this.addIdentityChangeListener(function (identity) {
      // console.log("Identity change:", identity);
      if (_this._sessionRefreshTimeout) {
        clearTimeout(_this._sessionRefreshTimeout);
        delete _this._sessionRefreshTimeout;
      }
      var claims = _this.getClaims();
      var expiresAt = (claims || {})["exp"];
      if (!expiresAt) return;
      expiresAt = expiresAt * 1000; // let it be in milliseconds
      var LEEWAY = 5 * 60 * 1000;
      var now = new Date().getTime();
      var delay = expiresAt - now - LEEWAY;
      if (delay < 0) delay = 0;
      // expiresAt = now + 30000;
      // delay = 20000;
      // console.log("Planning token refresh in ", delay, "ms.");
      _this._sessionRefreshTimeout = setTimeout(function () {
        delete _this._sessionRefreshTimeout;
        // refresh token by calling login() un-interactively
        _this._login({
          prompt: "none", // no user interaction
          acr_values: "1" // non-anonymous user
        }).catch(function (e) {
          if (_this._sessionRefreshTimeout) return; // identity changed in-between (maybe due to login with directly provided access_token)
          // refresh failed => perform logout few seconds before the token expires
          var autoLogoutAfter = Math.max(0, expiresAt - new Date().getTime() - 30 * 1000);
          // console.log("Token refresh failed - will perform auto-logout in", autoLogoutAfter, "ms.");
          _this._sessionRefreshTimeout = setTimeout(function () {
            delete _this._loginCtx;
            _this._runListeners();
          }, autoLogoutAfter);
        });
      }, delay);
    });
  }

  /**
   * Returns identity of currently logged in user or null if not logged in. The identity contains following fields:
   * 
   * * id
   * * name
   * * uuIdentity
   * * email
   * * levelOfAssurance
   * * loginLevelOfAssurance
   * 
   * @return {Object} Identity of currently logged in user or null if not logged in.
   * @method UuOidc.Session#getIdentity
   */


  _createClass(Session, [{
    key: "getIdentity",
    value: function getIdentity() {
      return this._loginCtx ? this._loginCtx.getIdentity() : null;
    }

    /**
     * Returns all claims present in the token (or null if not logged in).
     * 
     * @method UuOidc.Session#getClaims
     */

  }, {
    key: "getClaims",
    value: function getClaims() {
      return this._loginCtx ? this._loginCtx.getClaims() : null;
    }

    /**
     * Login against OpenID Connect server. If no or empty options are used, user will be required to
     * log in as non-anonymous user (as if { acrValues: 1 } was used). If user is already logged in
     * and options don't indicate that a re-login is necessary, then the method does nothing. Re-login can
     * be forced by using option "prompt" set to "login".
     * 
     * @param options {Object} Options.
     * @param options.prompt {string} (optional) One of "" (default), "none" (check login state without user interaction), "login" (re-request authentication).
     * @param options.acrValues (optional) One of: 0 (allow log in as anonymous), 1 (require non-anonymous user).
     * @param options.accessToken {string} (optional) Authentication token to use for login. Currently, only id_token (JWT) is supported.
     * @param options.tokenTypeHint {string} (optional) Hint about the type of the authentication token (accessToken in options) if it
     *   isn't standard id_token. Supported values depend on OpenID Connect server. uuOS9 server supports these values:
     * 
     * * "urn:ietf:params:oauth:token-type:jwt-uuos8" - indicates that the token being passed to the login was originally issued by uuOS8
     * 
     * @return Promise resolved after the login ends. The resolved value is this session instance, identity of logged in user can be obtained
     *   via sessionInstance.{@link UuOidc.Session#getIdentity getIdentity()}. Rejection value is one of:
     * 
     *   * false - user refused to log in
     *   * Error - any other error such as network problems, ...
     * 
     * @method UuOidc.Session#login
     */

  }, {
    key: "login",
    value: function login(options) {
      // NOTE For backward compatibility within version 1.x.y, this method must accept also snake_cased options keys (access_token, ...).

      // convert keys in options to snake_case (that's what is used in the code base of this library as OpenID & OAuth uses it too)
      var opts;
      if (options) opts = Object.keys(options).reduce(function (r, k) {
        return r[_StringUtil2.default.toSnakeCase(k)] = options[k], r;
      }, {});

      return this._login(opts, true);
    }

    // NOTE Uses snake_case in options because that's how OpenID & OAuth is specified.

  }, {
    key: "_login",
    value: function _login(options) {
      var _this3 = this;

      var updateSessionWithLoginResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var opts = Object.assign({}, options);

      // there's a special case in which we support providing uuOS8 token
      var os8Token;
      if (opts.token_type_hint === "urn:ietf:params:oauth:token-type:jwt-uuos8") {
        os8Token = opts.access_token;
        delete opts.access_token;
        delete opts.token_type_hint;
      }

      // use accessToken directly if it's provided
      var accessToken = opts.access_token;
      delete opts.access_token;

      var doLogin = function doLogin() {
        _this3._loginInProgress.push(1);

        // if calling Session.login() with no parameters, log in as non-anonymous user
        if (Object.keys(opts).length == 0) opts["acr_values"] = 1;

        // if we have user then login only if options indicate that we have to
        if (!accessToken && _this3._loginCtx) {
          var useCurrent = true;
          if (opts["prompt"] || opts["max_age"] || opts["access_token"]) useCurrent = false; // TODO Check max_age in more detail and use current if we're within the limit.

          // check required login level of assurance
          var acr_values = (opts["acr_values"] != null ? opts["acr_values"] + "" : "").split(/\s+/);
          var identity = _this3.getIdentity();
          if (acr_values.every(function (v) {
            return Number(v) > identity.loginLevelOfAssurance;
          })) useCurrent = false; // all acceptable login levels of assurance, that are requested, are greater than current one => do the login

          // check current token expiration
          if (_this3._authResponseExpired(_this3._loginCtx.authResponse)) useCurrent = false; // our token expired => do the login

          // use current token if everything seems fine
          if (useCurrent) {
            _this3._loginInProgress.pop();
            return Promise.resolve(_this3);
          }
        }

        // login using implicit flow
        var authResponse = accessToken ? { id_token: accessToken } : null;
        var state;
        var nonce = accessToken || "nonce" in opts ? opts["nonce"] : _this3.nonce;

        // NOTE Clicking a button, which launches this login method, can result in
        // at most 1 Promise resolution. If 2 or more Promises are chained, mobile
        // devices such as iPhone 4 will block popup opening. That's why this._optionsMergedPromise
        // is wrapped via PromiseUtil which then allows us here to call our "then" function immediately
        // if the this._optionsMergedPromise has already been resolved.
        // TODO Maybe reimplement by using some sort of ImmediatePromiseWrapper which in case of .then(fn)
        // will invoke the fn immediately. Note that Promise chaining must be somehow resolved which is
        // not trivial.
        var authResponsePromise = Promise.resolve(authResponse || _PromiseUtil2.default.immediateThen(_this3._optionsMergedPromise, function () {
          // handle uuOS8 token - we need to obtain standard OIDC id_token and start OIDC session (set session cookie) - we'll
          // do this by exchanging tokens via non-standard endpoint for uuOS8
          if (os8Token) {
            nonce = null;
            var os8Auth = new _Os8Auth2.default({
              serverUri: _this3.serverUri,
              clientId: _this3.clientId,
              redirectUri: _this3.implicitFlowRedirectUri
            });
            return os8Auth.grantExchangeToken({
              subject_token: os8Token
            });
          }

          // authenticate using implicit flow
          opts.nonce = nonce;
          opts.state = state = Math.random().toString(32).substr(2);
          return _ImplicitFlow2.default.login({
            serverUri: _this3.serverUri,
            clientId: _this3.clientId,
            redirectUri: _this3.implicitFlowRedirectUri,
            loginParams: opts
          });
        }, function (e) {
          return Promise.reject(e);
        }));
        return authResponsePromise.then(function (authResponse) {
          // ImplicitFlow response validation: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthResponseValidation
          // 1. process only recognized fields in response (id_token, expires_in, ...)
          // 2. validate implicit flow callback response ("state")
          // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
          //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
          //     ii. validate signature
          //    iii. validate nonce
          // 4. validate access_token

          // 2.i. validate state
          if (state && authResponse.state !== state) throw new Error("Invalid 'state' in received token. Expected " + state + " but got " + authResponse.state + ". Token: " + JSON.stringify(authResponse));

          // 2.ii. validate expiration
          if (_this3._authResponseExpired(authResponse)) throw new Error("Token expired " + JSON.stringify(authResponse));

          // 3. validate id_token with nonce
          return _this3._validateIdToken(authResponse.id_token, nonce).then(function (claims) {
            if (updateSessionWithLoginResult !== false) {
              _this3._loginCtx = new _SessionContext2.default(opts, authResponse, claims);
              _this3._runListeners();
            }
            return _this3;
          });
        }).then(function (r) {
          _this3._loginInProgress.pop();
          return r;
        }, function (e) {
          _this3._loginInProgress.pop();
          return Promise.reject(e);
        });
      };

      // wait for session restoring in case that this instance of the session is the "main" session
      return this === Session.currentSession && !accessToken && !os8Token && Object.keys(opts).length === 0 ? _PromiseUtil2.default.immediateThen(Session.initPromise, doLogin) : doLogin();
    }

    /**
     * @return Promise resolved after the user gets logged out.
     * @method UuOidc.Session#logout
     */

  }, {
    key: "logout",
    value: function logout() {
      var _this4 = this;

      if (!this._loginCtx) return Promise.resolve();

      // TODO Logout using end_session_endpoint when it's implemented on server-side.
      // logout using uuOidc-specific logout endpoint for now
      return this._optionsMergedPromise.then(function () {
        return new Promise(function (resolve, reject) {
          var oidcServerUri = _this4.serverUri;
          var logoutCallbackUri = _this4.implicitFlowRedirectUri;
          var logoutUrl = oidcServerUri + "/logout?redirect_uri=" + encodeURIComponent(logoutCallbackUri);
          new _IframeComponent2.default({
            url: logoutUrl,
            onResult: function onResult(result) {
              // assume that the user is now logged out (regardless of result)
              delete _this4._loginCtx;
              _this4._runListeners();
              resolve();
            }
          }).render();
        });
      });
    }

    /**
     * Returns token and its type for calling commands. Returned object contains following fields:
     * 
     * * tokenType - the type of the token, such as "Bearer",
     * * token - the token itself.
     * 
     * If the user is not logged in, null is returned.
     * 
     * @param {(string|UuApp.Uri.Uri)} callUri (optional) Command URI that is going to be called with the token.
     * @return Object containing token and its type, or null if user is not logged in.
     * @method UuOidc.Session#getCallToken
     */

  }, {
    key: "getCallToken",
    value: function getCallToken(callUri) {
      var authResponse = (this._loginCtx || {}).authResponse;
      if (!authResponse) return null;
      var result = {
        tokenType: authResponse.token_type || null,
        token: authResponse.id_token || null
      };
      return result;
    }
  }, {
    key: "_authResponseExpired",
    value: function _authResponseExpired(authResponse) {
      var now = new Date().getTime() / 1000;
      var leeway = 60;
      var expired = false;
      if (!authResponse.issued_at) authResponse.issued_at = now;
      if (authResponse.expires_at) expired = expired || authResponse.expires_at < now - leeway;
      if (authResponse.expires_in && authResponse.issued_at) expired = expired || Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway;
      return expired;
    }

    /**
     * @return {Promise<Object>} Promise resolved to JWT claims or rejected with validation error.
     */

  }, {
    key: "_validateIdToken",
    value: function _validateIdToken(token, nonce) {
      var _this5 = this;

      // 3. validate id_token => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
      //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
      //         1. -Decrypt JWE - not supported.
      //         2. +REQUIRED validate 'iss'
      //         3. +REQUIRED validate 'aud'
      //         4. -SHOULD validate multiple 'aud' vs. 'azp'
      //         5. -SHOULD validate 'azp'
      //         6. -REQUIRED <applicable only for token_endpoint, not for implicit flow>
      //         7. -SHOULD validate 'alg' in header vs. 'alg' sent during client registration
      //         8. -REQUIRED <for MAC-based algos> - not supported (we use RSA)
      //         9. +REQUIRED current time < 'exp'
      //        10. +CAN check 'iat'
      //        11. +REQUIRED (for implicit flow) validate nonce
      //        12. -SHOULD check if 'acr' is appropriate
      //        13. -SHOULD check if 'auth_time' was requested.
      //     ii. validate signature
      //    iii. validate nonce

      return this._optionsMergedPromise.then(function () {
        return _Discovery2.default.getMetadata(_this5.serverUri).then(function (metadata) {
          var verifyOptions = {
            // NOTE IE11 doesn't have RS512 (but it has "RS256" and "RS384").
            alg: ["RS256"], // 3.i.7. (we'll allow only RSA algorithms for signature verification)
            iss: [metadata.issuer], // 3.i.2.
            // aud: this.clientId, // 3.i.3. TODO We don't have the proper value.
            // 3.i.9. - 'exp' is checked automatically if present in JWT claims (as well as 'iat', 'nbf') 
            gracePeriod: 300
          };
          return _Jwt2.default.decode(token, verifyOptions, function (jwtHeader) {
            // 3.ii.
            if (!jwtHeader.alg || !jwtHeader.alg.match(/^RS\d+$/)) throw new Error("Invalid token. Only RSA signature is supported, but token uses algorithm '" + jwtHeader.alg + "'. Token: " + token);
            var keyType = "RSA";

            // check algorithm in token (whether it's really supported by the server)
            var supportedAlgs = metadata.id_token_signing_alg_values_supported || [];
            if (supportedAlgs.indexOf(jwtHeader.alg) == -1) throw new Error("Invalid token. Token was signed using algorithm '" + jwtHeader.alg + "' but the OIDC server '" + _this5.serverUri + "' supports only " + JSON.stringify(supportedAlgs) + ". Token: " + token);

            // pick the key from JWK Set
            var jwks = new _Jwks2.default({ serverUri: _this5.serverUri });
            return jwks.getKey(jwtHeader.kid, keyType).catch(function (e) {
              throw new Error("Invalid token. Unable to match key from JWT header to list of keys used by OpenID Connect server " + _this5.serverUri + ". Token: " + token, e);
            });
          }).then(function (claims) {
            // 3.i.11., 3.iii. validate nonce
            if (nonce && claims.nonce !== nonce) throw new _InvalidTokenError2.default("Invalid nonce in ID token claims. Expected " + nonce + " but got " + claims.nonce);
            return claims;
          });
        });
      });
    }
  }]);

  return Session;
}();

exports.default = Session;


function toFullUrl(path) {
  var a = document.createElement("a");
  a.href = path;
  return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
}

/**
 * Current session.
 * 
 * @name UuOidc.Session.currentSession
 * @type UuOidc.Session
 */
var currentSession;
var allowAutoInitSession = true;
Object.defineProperty(Session, "currentSession", {
  get: function get() {
    if (allowAutoInitSession && !currentSession) {
      currentSession = new Session(_uu_appg01_core.Util.Config); // TODO As it is now, accessing Session.currentSession prior to invoking Config.init will use defaults-only (for whole page duration).
      currentSession.initComplete = false;
      currentSession.initPromise = Session.initPromise;
    }
    return currentSession;
  },
  set: function set(value) {
    allowAutoInitSession = false;
    currentSession = value;
  }
});

var finalizeInit;
/**
 * Promise resolved after session initialization (restoring state) finishes.
 * 
 * @type {Promise<UuOidc.Session>}
 * @name UuOidc.Session.initPromise 
 */
/**
 * Promise resolved after session initialization (restoring state) finishes.
 * Note that this field is available only on a session instance that is
 * created automatically during page load.
 * 
 * @type {Promise<UuOidc.Session>}
 * @name UuOidc.Session#initPromise 
 */
Session.initPromise = _PromiseUtil2.default.wrapForImmediateThen(new Promise(function (resolve, reject) {
  finalizeInit = function finalizeInit(isOk, result) {
    Session.initComplete = true;
    Session.currentSession.initComplete = true;
    if (!isOk) console.log("Session initialization failed:", result);
    resolve(Session.currentSession); // always resolve as success even if checking session state failed
    return Session.initPromise;
  };
}));

/**
 * Whether the session initialization performed during page load has already completed.
 * 
 * @type {boolean}
 * @name UuOidc.Session.initComplete
 */
/**
 * Whether the session initialization performed during page load has already completed.
 * Note that this field is available only on a session instance that is
 * created automatically during page load.
 * 
 * @type {boolean}
 * @name UuOidc.Session#initComplete
 */
Session.initComplete = false;

function tryAutoLogin() {
  if (Session.currentSession.isAuthenticated() || Session.currentSession._loginInProgress.length > 0) return;

  // if there's access_token parameter in current URL, consider it as the id_token of the user
  var id_token;
  location.search.replace(/[?&]access_token=([^&#]*)/, function (m, g) {
    id_token = decodeURIComponent(g.replace(/\+/g, " "));
  });
  if (id_token) {
    return Session.currentSession._login({
      access_token: id_token,
      nonce: null
    });
  }

  // TODO Maybe we should use localStorage/sessionStorage too so that navigating between pages won't unnecessarily trigger
  // re-login every time.

  // try to login with no user interaction
  return Session.currentSession._login({
    prompt: "none", // no user interaction
    acr_values: "1" // non-anonymous user
  }).catch(function (e) {
    if (e && (typeof e === "undefined" ? "undefined" : _typeof(e)) == "object" && typeof e["error_description"] == "string" && e["error_description"].match(/interaction/i) && e["error_description"].match(/required/i)) return; // everything is fine, we just aren't logged in
    throw e; // some other error happenned
  });
}

// try to login without prompting user (only for browser environment)
var isBrowser = new Function("try {return this===window;}catch(e){ return false;}")();
if (isBrowser) {
  // wait until DOM is ready because we need BODY element to be present due to how implicit flow works
  _Dom2.default.domReady.then(function () {
    return Promise.resolve(tryAutoLogin()); // ASAP login, possibly from URL parameter
  }).then(finalizeInit.bind(null, true), finalizeInit.bind(null, false));
} else {
  finalizeInit(true);
}