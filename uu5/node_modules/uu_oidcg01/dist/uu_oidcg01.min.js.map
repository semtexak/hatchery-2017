{"version":3,"sources":["webpack:///uu_oidcg01@2.0.2/srcwebpack/universalModuleDefinition","webpack:///uu_oidcg01@2.0.2/srcuu_oidcg01.min.js","webpack:///uu_oidcg01@2.0.2/srcwebpack/bootstrap bd7b4e17d247392050ef","webpack:///uu_oidcg01@2.0.2/src../.tmp/index.js","webpack:///uu_oidcg01@2.0.2/src./discovery/Discovery.js","webpack:///uu_oidcg01@2.0.2/src./jwt/InvalidTokenError.js","webpack:///uu_oidcg01@2.0.2/src./ui/IframeComponent.js","webpack:///uu_oidcg01@2.0.2/src./util/PromiseUtil.js","webpack:///uu_oidcg01@2.0.2/srcexternal {\"amd\":\"uu_appg01_core\",\"commonjs\":\"uu_appg01_core\",\"commonjs2\":\"uu_appg01_core\",\"root\":\"UuApp\"}","webpack:///uu_oidcg01@2.0.2/src./Session.js","webpack:///uu_oidcg01@2.0.2/src./flow/ImplicitFlow.js","webpack:///uu_oidcg01@2.0.2/src./ui/CallbackHandler.js","webpack:///uu_oidcg01@2.0.2/src./util/Base64Url.js","webpack:///uu_oidcg01@2.0.2/src./util/HttpClient.js","webpack:///uu_oidcg01@2.0.2/src./util/StringUtil.js","webpack:///uu_oidcg01@2.0.2/srcexternal {\"amd\":\"module\",\"commonjs\":\"module\",\"commonjs2\":\"module\",\"root\":\"undefined\"}","webpack:///uu_oidcg01@2.0.2/src./Defaults.js","webpack:///uu_oidcg01@2.0.2/src./SessionContext.js","webpack:///uu_oidcg01@2.0.2/src./SessionHandler.js","webpack:///uu_oidcg01@2.0.2/src./index.js","webpack:///uu_oidcg01@2.0.2/src./jwks/Jwks.js","webpack:///uu_oidcg01@2.0.2/src./jwt/Jwt.js","webpack:///uu_oidcg01@2.0.2/src./jwt/JwtVerifierJsrsasign.js","webpack:///uu_oidcg01@2.0.2/src./jwt/JwtVerifierWebCrypto.js","webpack:///uu_oidcg01@2.0.2/src./ui/PopupComponent.js","webpack:///uu_oidcg01@2.0.2/src./util/Dom.js","webpack:///uu_oidcg01@2.0.2/src./util/Uuid.js","webpack:///uu_oidcg01@2.0.2/src./uuos8/Os8Auth.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_5__","__WEBPACK_EXTERNAL_MODULE_12__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","mod","uri","document","currentScript","Array","prototype","slice","getElementsByTagName","src","toString","split","join","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_HttpClient","_HttpClient2","_PromiseUtil","_PromiseUtil2","oidcMetadataCache","getMetadata","aIssuerUri","issuerUri","replace","metadata","discoveryEndpoint","wrapForImmediateThen","get","catch","e","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","_uu_appg01_core","InvalidTokenError","_Errors$Error","getPrototypeOf","apply","arguments","Error","_CallbackHandler","_CallbackHandler2","IframeComponent","initAttrs","attrs","assign","state","iframe","contentWindow","registerForCallback","finalize","aLoginResult","destroy","onResult","bind","render","createElement","style","cssText","url","body","appendChild","parentNode","removeChild","unregisterForCallback","promise","then","v","_immediateValue","_immediateError","immediateThen","thenFn","catchFn","toFullUrl","path","a","href","tryAutoLogin","Session","currentSession","isAuthenticated","_loginInProgress","length","id_token","location","search","g","decodeURIComponent","_login","access_token","nonce","prompt","acr_values","_typeof","match","Symbol","iterator","_createClass","defineProperties","target","props","i","descriptor","key","protoProps","staticProps","_Defaults","_Defaults2","_ImplicitFlow","_ImplicitFlow2","_SessionContext","_SessionContext2","_Uuid","_Uuid2","_Jwt","_Jwt2","_InvalidTokenError","_InvalidTokenError2","_Jwks","_Jwks2","_Discovery","_Discovery2","_Os8Auth","_Os8Auth2","_Dom","_Dom2","_StringUtil","_StringUtil2","_IframeComponent","_IframeComponent2","options","_this","_optionsMergedPromise","Promise","resolve","initPromise","env","serverUri","clientId","implicitFlowRedirectUri","sessionCheckInterval","baseUrl","baseURI","pathname","charAt","timeout","Math","max","check","_this2","_loginCtx","setTimeout","_runListeners","listeners","addIdentityChangeListener","listener","push","removeIdentityChangeListener","idx","indexOf","splice","identity","getIdentity","forEach","it","random","substr","_sessionRefreshTimeout","clearTimeout","claims","getClaims","expiresAt","LEEWAY","now","Date","getTime","delay","autoLogoutAfter","opts","keys","reduce","r","k","toSnakeCase","os8Token","_this3","updateSessionWithLoginResult","undefined","token_type_hint","accessToken","doLogin","useCurrent","every","Number","loginLevelOfAssurance","_authResponseExpired","authResponse","pop","authResponsePromise","os8Auth","redirectUri","grantExchangeToken","subject_token","login","loginParams","reject","JSON","stringify","_validateIdToken","_this4","oidcServerUri","logoutCallbackUri","logoutUrl","encodeURIComponent","result","callUri","tokenType","token_type","token","leeway","expired","issued_at","expires_at","expires_in","_this5","verifyOptions","alg","iss","issuer","gracePeriod","decode","jwtHeader","keyType","supportedAlgs","id_token_signing_alg_values_supported","jwks","getKey","kid","allowAutoInitSession","Util","Config","initComplete","set","finalizeInit","isOk","console","log","isBrowser","Function","domReady","_PopupComponent","_PopupComponent2","ImplicitFlow","oidcMetadata","scope","response_type","client_id","redirect_uri","loginParamsParts","loginUrl","authorization_endpoint","LoginVisualComponent","loginVisualComponent","getAuthResponseFromCallback","error","aLoginCallbackResult","eqlIdx","VC_CALLBACK_FN_NAME","window","aSourceWindow","loginWindows","loginWindow","component","warn","Base64Url","encodeAscii","txtAscii","btoa","encode","txtUtf8","unescape","decodeToAscii","base64Url","base64","atob","ascii","escape","xhrJson","method","extraSettingFn","xhr","XMLHttpRequest","open","withCredentials","setRequestHeader","onreadystatechange","readyState","status","json","parse","responseText","err","send","post","aText","toLowerCase","SessionContext","loginOptions","name","email","uuIdentity","levelOfAssurance","_interopRequireWildcard","newObj","hasOwnProperty","SessionHandler","request","nextInterceptorFn","runWith","extraLoginParams","count","UuApp","AbortError","usedLoginParams","session","baseUri","getCallToken","callToken","data","authToken","headers","response","wwwAuthenticate","valueMap","map","trim","decodeUriWithPlus","relevantValues","filter","hasCustomAuthn","_Session2","txt","_Session","_SessionHandler","_SessionHandler2","UuOidc","jwkSetCache","cacheBustCounter","_class","keyId","_getKey","forceKeySetReload","jwkSetMeta","jwks_uri","jwkSet","kty","_Base64Url","_Base64Url2","_JwtVerifierWebCrypto","_JwtVerifierWebCrypto2","_JwtVerifierJsrsasign","_JwtVerifierJsrsasign2","hasWebCrypto","crypto","subtle","importKey","useWebCrypto","protocol","verifier","DEFAULT_ALG","verifyOpts","getKeyFn","tokenParts","header","headerB64U","headerStr","typ","verify","valid","bodyStr","_module","_module2","scriptUri","jsrsasign","Verifier","loadPromise","continueFn","isMin","System","import","script","onload","onerror","head","keyInst","KEYUTIL","jws","JWS","verifyJWT","asciiToUint8Array","Uint8Array","charCodeAt","asArray","isArray","toTimeString","seconds","toISOString","webCryptoAlgorithm","hash","usedKey","use","webCryptoKey","signatureB64U","signatureBytes","dataBytes","algorithm","importError","cause","signatureValid","throwError","failedClaim","sub","aud","bodyV","some","bv","verifyAt","exp","nbf","iat","jti","PopupComponent","closeCheckInterval","closeCheck","closed","rect","width","height","left","screen","availWidth","availLeft","top","availHeight","availTop","setInterval","close","clearInterval","domReadyPromise","addEventListener","generateUuid","uuid","Os8Auth","parameters","params","urlParams","urlParamsParts"],"mappings":"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","file":"uu_oidcg01.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uu_appg01_core\"), require(\"module\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UuOidc\", [\"uu_appg01_core\", \"module\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UuOidc\"] = factory(require(\"uu_appg01_core\"), require(\"module\"));\n\telse\n\t\troot[\"UuOidc\"] = factory(root[\"UuApp\"], root[\"undefined\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_12__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uu_appg01_core\"), require(\"module\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"UuOidc\", [\"uu_appg01_core\", \"module\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"UuOidc\"] = factory(require(\"uu_appg01_core\"), require(\"module\"));\n\telse\n\t\troot[\"UuOidc\"] = factory(root[\"UuApp\"], root[\"undefined\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_12__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar mod=__webpack_require__(12);\n\t  var uri = ((mod ? mod.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName(\"script\"), -1)[0] || {}).src) || \"\").toString();\n\t  __webpack_require__.p=uri.split(/\\//).slice(0, -1).join(\"/\") + \"/\"; // runtime publicPath configuration required for proper linking of styles, background images, ...\n\t  module.exports = __webpack_require__(16);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _HttpClient = __webpack_require__(10);\n\t\n\tvar _HttpClient2 = _interopRequireDefault(_HttpClient);\n\t\n\tvar _PromiseUtil = __webpack_require__(4);\n\t\n\tvar _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar oidcMetadataCache = {}; // stores Promises\n\t\n\texports.default = {\n\t  /**\n\t   * @return Promise resolving to OIDC discovery metadata for given issuerUri.\n\t   */\n\t  getMetadata: function getMetadata(aIssuerUri) {\n\t    var issuerUri = aIssuerUri.replace(/\\/+$/, \"\"); // strip trailing slash(es) (this also normalizes it as a key to cache)\n\t    var metadata = oidcMetadataCache[issuerUri];\n\t    if (metadata) return metadata;\n\t    var discoveryEndpoint = issuerUri + \"/.well-known/openid-configuration\";\n\t    return oidcMetadataCache[issuerUri] = _PromiseUtil2.default.wrapForImmediateThen(_HttpClient2.default.get(discoveryEndpoint).catch(function (e) {\n\t      delete oidcMetadataCache[issuerUri]; // don't cache errors so that e.g. clicking a button 2nd time (after network is up again) has chance to work\n\t      throw e;\n\t    }));\n\t  }\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _uu_appg01_core = __webpack_require__(5);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar InvalidTokenError = function (_Errors$Error) {\n\t  _inherits(InvalidTokenError, _Errors$Error);\n\t\n\t  function InvalidTokenError() {\n\t    _classCallCheck(this, InvalidTokenError);\n\t\n\t    return _possibleConstructorReturn(this, (InvalidTokenError.__proto__ || Object.getPrototypeOf(InvalidTokenError)).apply(this, arguments));\n\t  }\n\t\n\t  return InvalidTokenError;\n\t}(_uu_appg01_core.Error.Error);\n\t\n\texports.default = InvalidTokenError;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _CallbackHandler = __webpack_require__(8);\n\t\n\tvar _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Visual component for attempting user login/logout on a background in an iframe. Usable only for prompt=\"none\" cases.\n\t * After login/logout initAttrs.onResult(authResultUrl) is called as callback.\n\t * \n\t * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.\n\t * @param initAttrs.onResult The callback to call after login/logout finishes.\n\t */\n\tvar IframeComponent = function IframeComponent(initAttrs) {\n\t  var attrs = Object.assign({}, initAttrs);\n\t  var state = {\n\t    iframe: null\n\t  };\n\t  Object.defineProperty(state, \"loginWindow\", {\n\t    get: function get() {\n\t      try {\n\t        // needs try-catch depending on which phase we're being asked (might be during redirect, ..., which can be cross-domain)\n\t        return state.iframe != null ? state.iframe.contentWindow : null;\n\t      } catch (e) {\n\t        // ignore\n\t      }\n\t      return null;\n\t    }\n\t  });\n\t\n\t  // add self to the list of openend loginWindows\n\t  _CallbackHandler2.default.registerForCallback(this, state);\n\t\n\t  // finalization callback (for this component instance) called after login from redirect_uri page\n\t  this.finalize = function (aLoginResult) {\n\t    // cleanup & do the callback\n\t    this.destroy();\n\t    if (attrs.onResult) attrs.onResult(aLoginResult);\n\t  }.bind(this);\n\t\n\t  // TODO Maybe use timeout ~30s and destroy in case that something is seriously wrong (network errors, ...).\n\t\n\t  this.render = function () {\n\t    if (!state.iframe) {\n\t      state.iframe = document.createElement(\"iframe\");\n\t      state.iframe.style.cssText = \"position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;\";\n\t      state.iframe.src = attrs.url;\n\t      document.body.appendChild(state.iframe);\n\t    }\n\t  };\n\t\n\t  this.destroy = function () {\n\t    if (state.iframe && state.iframe.parentNode) state.iframe.parentNode.removeChild(state.iframe);\n\t    this.destroy = function () {};\n\t    _CallbackHandler2.default.unregisterForCallback(this);\n\t  };\n\t};\n\t\n\texports.default = IframeComponent;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  /**\n\t   * Wraps Promise so that it can then be used in immediateThen function.\n\t   */\n\t  wrapForImmediateThen: function wrapForImmediateThen(promise) {\n\t    promise.then(function (v) {\n\t      return promise._immediateValue = v;\n\t    }, function (e) {\n\t      return promise._immediateError = e;\n\t    });\n\t    return promise;\n\t  },\n\t\n\t  /**\n\t   * If promise has already been resolved, thenFn is called immediately (or catchFn in\n\t   * case that the promise has been rejected). Otherwise thenFn and catchFn callbacks\n\t   * are simply registered via promise.then(thenFn, catchFn).\n\t   * \n\t   * Note that this works only on promises that were wrapped via #wrapForImmediateThen\n\t   * function.\n\t   * \n\t   * @return Return value of thenFn/catchFn (if invoked immediately) or promise.then(thenFn, catchFn).\n\t   */\n\t  immediateThen: function immediateThen(promise, thenFn, catchFn) {\n\t    if (\"_immediateValue\" in promise) return typeof thenFn == \"function\" ? thenFn(promise._immediateValue) : promise._immediateValue;\n\t    if (\"_immediateError\" in promise) {\n\t      if (typeof catchFn == \"function\") return catchFn(promise._immediateError);\n\t      throw promise._immediateError;\n\t    }\n\t    return promise.then(thenFn, catchFn);\n\t  }\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _uu_appg01_core = __webpack_require__(5);\n\t\n\tvar _Defaults = __webpack_require__(13);\n\t\n\tvar _Defaults2 = _interopRequireDefault(_Defaults);\n\t\n\tvar _ImplicitFlow = __webpack_require__(7);\n\t\n\tvar _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);\n\t\n\tvar _SessionContext = __webpack_require__(14);\n\t\n\tvar _SessionContext2 = _interopRequireDefault(_SessionContext);\n\t\n\tvar _Uuid = __webpack_require__(23);\n\t\n\tvar _Uuid2 = _interopRequireDefault(_Uuid);\n\t\n\tvar _Jwt = __webpack_require__(18);\n\t\n\tvar _Jwt2 = _interopRequireDefault(_Jwt);\n\t\n\tvar _InvalidTokenError = __webpack_require__(2);\n\t\n\tvar _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);\n\t\n\tvar _Jwks = __webpack_require__(17);\n\t\n\tvar _Jwks2 = _interopRequireDefault(_Jwks);\n\t\n\tvar _Discovery = __webpack_require__(1);\n\t\n\tvar _Discovery2 = _interopRequireDefault(_Discovery);\n\t\n\tvar _Os8Auth = __webpack_require__(24);\n\t\n\tvar _Os8Auth2 = _interopRequireDefault(_Os8Auth);\n\t\n\tvar _Dom = __webpack_require__(22);\n\t\n\tvar _Dom2 = _interopRequireDefault(_Dom);\n\t\n\tvar _PromiseUtil = __webpack_require__(4);\n\t\n\tvar _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);\n\t\n\tvar _StringUtil = __webpack_require__(11);\n\t\n\tvar _StringUtil2 = _interopRequireDefault(_StringUtil);\n\t\n\tvar _IframeComponent = __webpack_require__(3);\n\t\n\tvar _IframeComponent2 = _interopRequireDefault(_IframeComponent);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Error = _uu_appg01_core.Error.Error;\n\t\n\tvar Session = function () {\n\t\n\t  /**\n\t   * Creates new Session with specified options.\n\t   * \n\t   * @class UuOidc.Session\n\t   * @classdesc\n\t   * \n\t   * Session handling via OpenID Connect server.\n\t   * \n\t   * **Configuration**\n\t   * \n\t   * Login via OpenID Connect server **requires a special callback HTML page be present on the domain where application is running**. The callback\n\t   * HTML page should be copied from the contents of this library (callbacks/oidc-callback.html) to the application and URL path to it must be\n\t   * configured as described below - configuration parameter \"uuoidc.redirectUri\".\n\t   * \n\t   * Following global configuration parameters are used for initializing {@link UuOidc.Session.currentSession Session.currentSession}:\n\t   * \n\t   * * **uuoidc.clientId** - OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.\n\t   *   Default is auto-generated which means that the application will be treated as an anonymous application and therefore might not be authorized for\n\t   *   accessing most of user data.\n\t   * * **uuoidc.redirectUri** - Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application\n\t   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative\n\t   *   to document.baseURI (current URL). Default is \"callbacks/oidc-callback.html\".\n\t   * * **uuoidc.serverUri** - OpenID Connect server to perform login / logout against. Default is \"https://oidc.plus4u.net/uu-oidcg01-main/0-0\".\n\t   * * **uuoidc.sessionCheckInterval** - how often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds. Default is 60.\n\t   * \n\t   * @param options {Object|UuApp.Util.Config} Options.\n\t   * @param options.serverUri OpenID Connect server to perform login / logout against.\n\t   * @param options.clientId OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.\n\t   * @param options.redirectUri Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application\n\t   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative\n\t   *   to document.baseURI (current URL).\n\t   * @param options.sessionCheckInterval How often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.\n\t   */\n\t  function Session(options) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Session);\n\t\n\t    if (!options) throw new Error(\"Session must be initialized with proper options or UuApp.Util.Config.\");\n\t    this._optionsMergedPromise = _PromiseUtil2.default.wrapForImmediateThen(Promise.resolve(options && typeof options.get == \"function\" ? options.initPromise : options).then(function (env) {\n\t      if (env && typeof env.get == \"function\") {\n\t        _this.serverUri = env.get(\"uuoidc.serverUri\", false);\n\t        _this.clientId = env.get(\"uuoidc.clientId\", false);\n\t        _this.implicitFlowRedirectUri = env.get(\"uuoidc.redirectUri\", false);\n\t        _this.sessionCheckInterval = env.get(\"uuoidc.sessionCheckInterval\", false);\n\t      } else if (env) {\n\t        _this.serverUri = env[\"serverUri\"];\n\t        _this.clientId = env[\"clientId\"];\n\t        _this.implicitFlowRedirectUri = env[\"redirectUri\"];\n\t        _this.sessionCheckInterval = env[\"uuoidc.sessionCheckInterval\"];\n\t      }\n\t      if (_this.serverUri == null) _this.serverUri = _Defaults2.default.serverUri;\n\t      if (_this.clientId == null) _this.clientId = \"uu-oidc:unregistered-client:\" + (0, _Uuid2.default)();\n\t      if (_this.sessionCheckInterval == null) _this.sessionCheckInterval = _Defaults2.default.sessionCheckInterval;\n\t      if (!_this.implicitFlowRedirectUri) {\n\t        // console.warn(\"Session login will work only with directly provided access token because no callback URL for OpenID Connect server was specified in\" + \n\t        //   \" the configuration. To support login via popup, specify redirectUri when creating session, or initialize UuApp.Util.Config with \\\"uuoidc.redirectUri\\\" option.\");\n\t        _this.implicitFlowRedirectUri = \"callbacks/oidc-callback.html\";\n\t      }\n\t      // if redirect URI is relative then absolutize it (relative to current document.baseURI)\n\t      if (!_this.implicitFlowRedirectUri.match(/^[a-z]+:/i)) {\n\t        // no protocol present\n\t        var baseUrl = toFullUrl(document.baseURI || location.pathname).replace(/^([^?#]*\\/).*/, \"$1\");\n\t        if (_this.implicitFlowRedirectUri.charAt(0) != \"/\") _this.implicitFlowRedirectUri = toFullUrl(baseUrl + _this.implicitFlowRedirectUri);else _this.implicitFlowRedirectUri = toFullUrl(_this.implicitFlowRedirectUri);\n\t      }\n\t\n\t      // add session state checking which, in case that we were logged in and a logout\n\t      // against OIDC is detected (e.g. in another browser tab), will log us out\n\t      // TODO This is a hotfix solution - proper way is that there's a component scoped by serverUri which performs the session checks.\n\t      var timeout = Math.max(5, _this.sessionCheckInterval) * 1000;\n\t      var check = function () {\n\t        var _this2 = this;\n\t\n\t        // if not logged in then just plan another check (we don't want to auto-login in this tab if user logs in another browser tab)\n\t        if (!this._loginCtx) return setTimeout(check, timeout);\n\t\n\t        // check login state via login (but don't actually use the newly issued token)\n\t        this._login({\n\t          acr_values: \"1\",\n\t          prompt: \"none\"\n\t        }, false).then(function () {\n\t          // still logged in => just plan another check\n\t          setTimeout(check, timeout);\n\t        }, function (e) {\n\t          // assume logout\n\t          delete _this2._loginCtx;\n\t          _this2._runListeners();\n\t          setTimeout(check, timeout);\n\t        });\n\t      }.bind(_this);\n\t      setTimeout(check, timeout);\n\t    }));\n\t    this._loginInProgress = [];\n\t\n\t    var listeners = [];\n\t    /**\n\t     * @return {boolean} True iff the user is authenticated (logged in).\n\t     * @method UuOidc.Session#isAuthenticated\n\t     */\n\t    this.isAuthenticated = function () {\n\t      return !!_this._loginCtx;\n\t    };\n\t    /**\n\t     * Adds listener for changes of user identity (logins / logouts).\n\t     * \n\t     * @param {Function(Object)} listener The listener function to add. The function receives identity object or null.\n\t     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeIdentityChangeListener}).\n\t     * @see UuOidc.Session#getIdentity\n\t     * @method UuOidc.Session#addIdentityChangeListener\n\t     */\n\t    this.addIdentityChangeListener = function (listener) {\n\t      listeners.push(listener);\n\t      return _this.removeIdentityChangeListener.bind(_this, listener);\n\t    };\n\t    /**\n\t     * Removes listener for changes of user identity (logins / logouts).\n\t     * \n\t     * @param {Function(Object)} listener The listener to remove.\n\t     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).\n\t     * @method UuOidc.Session#removeIdentityChangeListener\n\t     */\n\t    this.removeIdentityChangeListener = function (listener) {\n\t      var idx = listeners.indexOf(listener);\n\t      if (idx != -1) listeners.splice(idx, 1);\n\t      return idx != -1;\n\t    };\n\t    this._runListeners = function () {\n\t      var identity = _this.getIdentity();\n\t      listeners.forEach(function (it) {\n\t        return it.call(_this, identity);\n\t      });\n\t    };\n\t\n\t    this.nonce = Math.random().toString(32).substr(2);\n\t\n\t    // add planning & executing of token refresh when its nearing expiration\n\t    // NOTE This assumes that each token refresh ends with running the identity-change listeners.\n\t    this.addIdentityChangeListener(function (identity) {\n\t      // console.log(\"Identity change:\", identity);\n\t      if (_this._sessionRefreshTimeout) {\n\t        clearTimeout(_this._sessionRefreshTimeout);\n\t        delete _this._sessionRefreshTimeout;\n\t      }\n\t      var claims = _this.getClaims();\n\t      var expiresAt = (claims || {})[\"exp\"];\n\t      if (!expiresAt) return;\n\t      expiresAt = expiresAt * 1000; // let it be in milliseconds\n\t      var LEEWAY = 5 * 60 * 1000;\n\t      var now = new Date().getTime();\n\t      var delay = expiresAt - now - LEEWAY;\n\t      if (delay < 0) delay = 0;\n\t      // expiresAt = now + 30000;\n\t      // delay = 20000;\n\t      // console.log(\"Planning token refresh in \", delay, \"ms.\");\n\t      _this._sessionRefreshTimeout = setTimeout(function () {\n\t        delete _this._sessionRefreshTimeout;\n\t        // refresh token by calling login() un-interactively\n\t        _this._login({\n\t          prompt: \"none\", // no user interaction\n\t          acr_values: \"1\" // non-anonymous user\n\t        }).catch(function (e) {\n\t          if (_this._sessionRefreshTimeout) return; // identity changed in-between (maybe due to login with directly provided access_token)\n\t          // refresh failed => perform logout few seconds before the token expires\n\t          var autoLogoutAfter = Math.max(0, expiresAt - new Date().getTime() - 30 * 1000);\n\t          // console.log(\"Token refresh failed - will perform auto-logout in\", autoLogoutAfter, \"ms.\");\n\t          _this._sessionRefreshTimeout = setTimeout(function () {\n\t            delete _this._loginCtx;\n\t            _this._runListeners();\n\t          }, autoLogoutAfter);\n\t        });\n\t      }, delay);\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Returns identity of currently logged in user or null if not logged in. The identity contains following fields:\n\t   * \n\t   * * id\n\t   * * name\n\t   * * uuIdentity\n\t   * * email\n\t   * * levelOfAssurance\n\t   * * loginLevelOfAssurance\n\t   * \n\t   * @return {Object} Identity of currently logged in user or null if not logged in.\n\t   * @method UuOidc.Session#getIdentity\n\t   */\n\t\n\t\n\t  _createClass(Session, [{\n\t    key: \"getIdentity\",\n\t    value: function getIdentity() {\n\t      return this._loginCtx ? this._loginCtx.getIdentity() : null;\n\t    }\n\t\n\t    /**\n\t     * Returns all claims present in the token (or null if not logged in).\n\t     * \n\t     * @method UuOidc.Session#getClaims\n\t     */\n\t\n\t  }, {\n\t    key: \"getClaims\",\n\t    value: function getClaims() {\n\t      return this._loginCtx ? this._loginCtx.getClaims() : null;\n\t    }\n\t\n\t    /**\n\t     * Login against OpenID Connect server. If no or empty options are used, user will be required to\n\t     * log in as non-anonymous user (as if { acrValues: 1 } was used). If user is already logged in\n\t     * and options don't indicate that a re-login is necessary, then the method does nothing. Re-login can\n\t     * be forced by using option \"prompt\" set to \"login\".\n\t     * \n\t     * @param options {Object} Options.\n\t     * @param options.prompt {string} (optional) One of \"\" (default), \"none\" (check login state without user interaction), \"login\" (re-request authentication).\n\t     * @param options.acrValues (optional) One of: 0 (allow log in as anonymous), 1 (require non-anonymous user).\n\t     * @param options.accessToken {string} (optional) Authentication token to use for login. Currently, only id_token (JWT) is supported.\n\t     * @param options.tokenTypeHint {string} (optional) Hint about the type of the authentication token (accessToken in options) if it\n\t     *   isn't standard id_token. Supported values depend on OpenID Connect server. uuOS9 server supports these values:\n\t     * \n\t     * * \"urn:ietf:params:oauth:token-type:jwt-uuos8\" - indicates that the token being passed to the login was originally issued by uuOS8\n\t     * \n\t     * @return Promise resolved after the login ends. The resolved value is this session instance, identity of logged in user can be obtained\n\t     *   via sessionInstance.{@link UuOidc.Session#getIdentity getIdentity()}. Rejection value is one of:\n\t     * \n\t     *   * false - user refused to log in\n\t     *   * Error - any other error such as network problems, ...\n\t     * \n\t     * @method UuOidc.Session#login\n\t     */\n\t\n\t  }, {\n\t    key: \"login\",\n\t    value: function login(options) {\n\t      // NOTE For backward compatibility within version 1.x.y, this method must accept also snake_cased options keys (access_token, ...).\n\t\n\t      // convert keys in options to snake_case (that's what is used in the code base of this library as OpenID & OAuth uses it too)\n\t      var opts;\n\t      if (options) opts = Object.keys(options).reduce(function (r, k) {\n\t        return r[_StringUtil2.default.toSnakeCase(k)] = options[k], r;\n\t      }, {});\n\t\n\t      return this._login(opts, true);\n\t    }\n\t\n\t    // NOTE Uses snake_case in options because that's how OpenID & OAuth is specified.\n\t\n\t  }, {\n\t    key: \"_login\",\n\t    value: function _login(options) {\n\t      var _this3 = this;\n\t\n\t      var updateSessionWithLoginResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t      var opts = Object.assign({}, options);\n\t\n\t      // there's a special case in which we support providing uuOS8 token\n\t      var os8Token;\n\t      if (opts.token_type_hint === \"urn:ietf:params:oauth:token-type:jwt-uuos8\") {\n\t        os8Token = opts.access_token;\n\t        delete opts.access_token;\n\t        delete opts.token_type_hint;\n\t      }\n\t\n\t      // use accessToken directly if it's provided\n\t      var accessToken = opts.access_token;\n\t      delete opts.access_token;\n\t\n\t      var doLogin = function doLogin() {\n\t        _this3._loginInProgress.push(1);\n\t\n\t        // if calling Session.login() with no parameters, log in as non-anonymous user\n\t        if (Object.keys(opts).length == 0) opts[\"acr_values\"] = 1;\n\t\n\t        // if we have user then login only if options indicate that we have to\n\t        if (!accessToken && _this3._loginCtx) {\n\t          var useCurrent = true;\n\t          if (opts[\"prompt\"] || opts[\"max_age\"] || opts[\"access_token\"]) useCurrent = false; // TODO Check max_age in more detail and use current if we're within the limit.\n\t\n\t          // check required login level of assurance\n\t          var acr_values = (opts[\"acr_values\"] != null ? opts[\"acr_values\"] + \"\" : \"\").split(/\\s+/);\n\t          var identity = _this3.getIdentity();\n\t          if (acr_values.every(function (v) {\n\t            return Number(v) > identity.loginLevelOfAssurance;\n\t          })) useCurrent = false; // all acceptable login levels of assurance, that are requested, are greater than current one => do the login\n\t\n\t          // check current token expiration\n\t          if (_this3._authResponseExpired(_this3._loginCtx.authResponse)) useCurrent = false; // our token expired => do the login\n\t\n\t          // use current token if everything seems fine\n\t          if (useCurrent) {\n\t            _this3._loginInProgress.pop();\n\t            return Promise.resolve(_this3);\n\t          }\n\t        }\n\t\n\t        // login using implicit flow\n\t        var authResponse = accessToken ? { id_token: accessToken } : null;\n\t        var state;\n\t        var nonce = accessToken || \"nonce\" in opts ? opts[\"nonce\"] : _this3.nonce;\n\t\n\t        // NOTE Clicking a button, which launches this login method, can result in\n\t        // at most 1 Promise resolution. If 2 or more Promises are chained, mobile\n\t        // devices such as iPhone 4 will block popup opening. That's why this._optionsMergedPromise\n\t        // is wrapped via PromiseUtil which then allows us here to call our \"then\" function immediately\n\t        // if the this._optionsMergedPromise has already been resolved.\n\t        // TODO Maybe reimplement by using some sort of ImmediatePromiseWrapper which in case of .then(fn)\n\t        // will invoke the fn immediately. Note that Promise chaining must be somehow resolved which is\n\t        // not trivial.\n\t        var authResponsePromise = Promise.resolve(authResponse || _PromiseUtil2.default.immediateThen(_this3._optionsMergedPromise, function () {\n\t          // handle uuOS8 token - we need to obtain standard OIDC id_token and start OIDC session (set session cookie) - we'll\n\t          // do this by exchanging tokens via non-standard endpoint for uuOS8\n\t          if (os8Token) {\n\t            nonce = null;\n\t            var os8Auth = new _Os8Auth2.default({\n\t              serverUri: _this3.serverUri,\n\t              clientId: _this3.clientId,\n\t              redirectUri: _this3.implicitFlowRedirectUri\n\t            });\n\t            return os8Auth.grantExchangeToken({\n\t              subject_token: os8Token\n\t            });\n\t          }\n\t\n\t          // authenticate using implicit flow\n\t          opts.nonce = nonce;\n\t          opts.state = state = Math.random().toString(32).substr(2);\n\t          return _ImplicitFlow2.default.login({\n\t            serverUri: _this3.serverUri,\n\t            clientId: _this3.clientId,\n\t            redirectUri: _this3.implicitFlowRedirectUri,\n\t            loginParams: opts\n\t          });\n\t        }, function (e) {\n\t          return Promise.reject(e);\n\t        }));\n\t        return authResponsePromise.then(function (authResponse) {\n\t          // ImplicitFlow response validation: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthResponseValidation\n\t          // 1. process only recognized fields in response (id_token, expires_in, ...)\n\t          // 2. validate implicit flow callback response (\"state\")\n\t          // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation\n\t          //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n\t          //     ii. validate signature\n\t          //    iii. validate nonce\n\t          // 4. validate access_token\n\t\n\t          // 2.i. validate state\n\t          if (state && authResponse.state !== state) throw new Error(\"Invalid 'state' in received token. Expected \" + state + \" but got \" + authResponse.state + \". Token: \" + JSON.stringify(authResponse));\n\t\n\t          // 2.ii. validate expiration\n\t          if (_this3._authResponseExpired(authResponse)) throw new Error(\"Token expired \" + JSON.stringify(authResponse));\n\t\n\t          // 3. validate id_token with nonce\n\t          return _this3._validateIdToken(authResponse.id_token, nonce).then(function (claims) {\n\t            if (updateSessionWithLoginResult !== false) {\n\t              _this3._loginCtx = new _SessionContext2.default(opts, authResponse, claims);\n\t              _this3._runListeners();\n\t            }\n\t            return _this3;\n\t          });\n\t        }).then(function (r) {\n\t          _this3._loginInProgress.pop();\n\t          return r;\n\t        }, function (e) {\n\t          _this3._loginInProgress.pop();\n\t          return Promise.reject(e);\n\t        });\n\t      };\n\t\n\t      // wait for session restoring in case that this instance of the session is the \"main\" session\n\t      return this === Session.currentSession && !accessToken && !os8Token && Object.keys(opts).length === 0 ? _PromiseUtil2.default.immediateThen(Session.initPromise, doLogin) : doLogin();\n\t    }\n\t\n\t    /**\n\t     * @return Promise resolved after the user gets logged out.\n\t     * @method UuOidc.Session#logout\n\t     */\n\t\n\t  }, {\n\t    key: \"logout\",\n\t    value: function logout() {\n\t      var _this4 = this;\n\t\n\t      if (!this._loginCtx) return Promise.resolve();\n\t\n\t      // TODO Logout using end_session_endpoint when it's implemented on server-side.\n\t      // logout using uuOidc-specific logout endpoint for now\n\t      return this._optionsMergedPromise.then(function () {\n\t        return new Promise(function (resolve, reject) {\n\t          var oidcServerUri = _this4.serverUri;\n\t          var logoutCallbackUri = _this4.implicitFlowRedirectUri;\n\t          var logoutUrl = oidcServerUri + \"/logout?redirect_uri=\" + encodeURIComponent(logoutCallbackUri);\n\t          new _IframeComponent2.default({\n\t            url: logoutUrl,\n\t            onResult: function onResult(result) {\n\t              // assume that the user is now logged out (regardless of result)\n\t              delete _this4._loginCtx;\n\t              _this4._runListeners();\n\t              resolve();\n\t            }\n\t          }).render();\n\t        });\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Returns token and its type for calling commands. Returned object contains following fields:\n\t     * \n\t     * * tokenType - the type of the token, such as \"Bearer\",\n\t     * * token - the token itself.\n\t     * \n\t     * If the user is not logged in, null is returned.\n\t     * \n\t     * @param {(string|UuApp.Uri.Uri)} callUri (optional) Command URI that is going to be called with the token.\n\t     * @return Object containing token and its type, or null if user is not logged in.\n\t     * @method UuOidc.Session#getCallToken\n\t     */\n\t\n\t  }, {\n\t    key: \"getCallToken\",\n\t    value: function getCallToken(callUri) {\n\t      var authResponse = (this._loginCtx || {}).authResponse;\n\t      if (!authResponse) return null;\n\t      var result = {\n\t        tokenType: authResponse.token_type || null,\n\t        token: authResponse.id_token || null\n\t      };\n\t      return result;\n\t    }\n\t  }, {\n\t    key: \"_authResponseExpired\",\n\t    value: function _authResponseExpired(authResponse) {\n\t      var now = new Date().getTime() / 1000;\n\t      var leeway = 60;\n\t      var expired = false;\n\t      if (!authResponse.issued_at) authResponse.issued_at = now;\n\t      if (authResponse.expires_at) expired = expired || authResponse.expires_at < now - leeway;\n\t      if (authResponse.expires_in && authResponse.issued_at) expired = expired || Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway;\n\t      return expired;\n\t    }\n\t\n\t    /**\n\t     * @return {Promise<Object>} Promise resolved to JWT claims or rejected with validation error.\n\t     */\n\t\n\t  }, {\n\t    key: \"_validateIdToken\",\n\t    value: function _validateIdToken(token, nonce) {\n\t      var _this5 = this;\n\t\n\t      // 3. validate id_token => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation\n\t      //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n\t      //         1. -Decrypt JWE - not supported.\n\t      //         2. +REQUIRED validate 'iss'\n\t      //         3. +REQUIRED validate 'aud'\n\t      //         4. -SHOULD validate multiple 'aud' vs. 'azp'\n\t      //         5. -SHOULD validate 'azp'\n\t      //         6. -REQUIRED <applicable only for token_endpoint, not for implicit flow>\n\t      //         7. -SHOULD validate 'alg' in header vs. 'alg' sent during client registration\n\t      //         8. -REQUIRED <for MAC-based algos> - not supported (we use RSA)\n\t      //         9. +REQUIRED current time < 'exp'\n\t      //        10. +CAN check 'iat'\n\t      //        11. +REQUIRED (for implicit flow) validate nonce\n\t      //        12. -SHOULD check if 'acr' is appropriate\n\t      //        13. -SHOULD check if 'auth_time' was requested.\n\t      //     ii. validate signature\n\t      //    iii. validate nonce\n\t\n\t      return this._optionsMergedPromise.then(function () {\n\t        return _Discovery2.default.getMetadata(_this5.serverUri).then(function (metadata) {\n\t          var verifyOptions = {\n\t            // NOTE IE11 doesn't have RS512 (but it has \"RS256\" and \"RS384\").\n\t            alg: [\"RS256\"], // 3.i.7. (we'll allow only RSA algorithms for signature verification)\n\t            iss: [metadata.issuer], // 3.i.2.\n\t            // aud: this.clientId, // 3.i.3. TODO We don't have the proper value.\n\t            // 3.i.9. - 'exp' is checked automatically if present in JWT claims (as well as 'iat', 'nbf') \n\t            gracePeriod: 300\n\t          };\n\t          return _Jwt2.default.decode(token, verifyOptions, function (jwtHeader) {\n\t            // 3.ii.\n\t            if (!jwtHeader.alg || !jwtHeader.alg.match(/^RS\\d+$/)) throw new Error(\"Invalid token. Only RSA signature is supported, but token uses algorithm '\" + jwtHeader.alg + \"'. Token: \" + token);\n\t            var keyType = \"RSA\";\n\t\n\t            // check algorithm in token (whether it's really supported by the server)\n\t            var supportedAlgs = metadata.id_token_signing_alg_values_supported || [];\n\t            if (supportedAlgs.indexOf(jwtHeader.alg) == -1) throw new Error(\"Invalid token. Token was signed using algorithm '\" + jwtHeader.alg + \"' but the OIDC server '\" + _this5.serverUri + \"' supports only \" + JSON.stringify(supportedAlgs) + \". Token: \" + token);\n\t\n\t            // pick the key from JWK Set\n\t            var jwks = new _Jwks2.default({ serverUri: _this5.serverUri });\n\t            return jwks.getKey(jwtHeader.kid, keyType).catch(function (e) {\n\t              throw new Error(\"Invalid token. Unable to match key from JWT header to list of keys used by OpenID Connect server \" + _this5.serverUri + \". Token: \" + token, e);\n\t            });\n\t          }).then(function (claims) {\n\t            // 3.i.11., 3.iii. validate nonce\n\t            if (nonce && claims.nonce !== nonce) throw new _InvalidTokenError2.default(\"Invalid nonce in ID token claims. Expected \" + nonce + \" but got \" + claims.nonce);\n\t            return claims;\n\t          });\n\t        });\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Session;\n\t}();\n\t\n\texports.default = Session;\n\t\n\t\n\tfunction toFullUrl(path) {\n\t  var a = document.createElement(\"a\");\n\t  a.href = path;\n\t  return a.href.toString(); // browser-normalized URL (removed \"../\" sequences, ...)\n\t}\n\t\n\t/**\n\t * Current session.\n\t * \n\t * @name UuOidc.Session.currentSession\n\t * @type UuOidc.Session\n\t */\n\tvar currentSession;\n\tvar allowAutoInitSession = true;\n\tObject.defineProperty(Session, \"currentSession\", {\n\t  get: function get() {\n\t    if (allowAutoInitSession && !currentSession) {\n\t      currentSession = new Session(_uu_appg01_core.Util.Config); // TODO As it is now, accessing Session.currentSession prior to invoking Config.init will use defaults-only (for whole page duration).\n\t      currentSession.initComplete = false;\n\t      currentSession.initPromise = Session.initPromise;\n\t    }\n\t    return currentSession;\n\t  },\n\t  set: function set(value) {\n\t    allowAutoInitSession = false;\n\t    currentSession = value;\n\t  }\n\t});\n\t\n\tvar finalizeInit;\n\t/**\n\t * Promise resolved after session initialization (restoring state) finishes.\n\t * \n\t * @type {Promise<UuOidc.Session>}\n\t * @name UuOidc.Session.initPromise \n\t */\n\t/**\n\t * Promise resolved after session initialization (restoring state) finishes.\n\t * Note that this field is available only on a session instance that is\n\t * created automatically during page load.\n\t * \n\t * @type {Promise<UuOidc.Session>}\n\t * @name UuOidc.Session#initPromise \n\t */\n\tSession.initPromise = _PromiseUtil2.default.wrapForImmediateThen(new Promise(function (resolve, reject) {\n\t  finalizeInit = function finalizeInit(isOk, result) {\n\t    Session.initComplete = true;\n\t    Session.currentSession.initComplete = true;\n\t    if (!isOk) console.log(\"Session initialization failed:\", result);\n\t    resolve(Session.currentSession); // always resolve as success even if checking session state failed\n\t    return Session.initPromise;\n\t  };\n\t}));\n\t\n\t/**\n\t * Whether the session initialization performed during page load has already completed.\n\t * \n\t * @type {boolean}\n\t * @name UuOidc.Session.initComplete\n\t */\n\t/**\n\t * Whether the session initialization performed during page load has already completed.\n\t * Note that this field is available only on a session instance that is\n\t * created automatically during page load.\n\t * \n\t * @type {boolean}\n\t * @name UuOidc.Session#initComplete\n\t */\n\tSession.initComplete = false;\n\t\n\tfunction tryAutoLogin() {\n\t  if (Session.currentSession.isAuthenticated() || Session.currentSession._loginInProgress.length > 0) return;\n\t\n\t  // if there's access_token parameter in current URL, consider it as the id_token of the user\n\t  var id_token;\n\t  location.search.replace(/[?&]access_token=([^&#]*)/, function (m, g) {\n\t    id_token = decodeURIComponent(g.replace(/\\+/g, \" \"));\n\t  });\n\t  if (id_token) {\n\t    return Session.currentSession._login({\n\t      access_token: id_token,\n\t      nonce: null\n\t    });\n\t  }\n\t\n\t  // TODO Maybe we should use localStorage/sessionStorage too so that navigating between pages won't unnecessarily trigger\n\t  // re-login every time.\n\t\n\t  // try to login with no user interaction\n\t  return Session.currentSession._login({\n\t    prompt: \"none\", // no user interaction\n\t    acr_values: \"1\" // non-anonymous user\n\t  }).catch(function (e) {\n\t    if (e && (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) == \"object\" && typeof e[\"error_description\"] == \"string\" && e[\"error_description\"].match(/interaction/i) && e[\"error_description\"].match(/required/i)) return; // everything is fine, we just aren't logged in\n\t    throw e; // some other error happenned\n\t  });\n\t}\n\t\n\t// try to login without prompting user (only for browser environment)\n\tvar isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\")();\n\tif (isBrowser) {\n\t  // wait until DOM is ready because we need BODY element to be present due to how implicit flow works\n\t  _Dom2.default.domReady.then(function () {\n\t    return Promise.resolve(tryAutoLogin()); // ASAP login, possibly from URL parameter\n\t  }).then(finalizeInit.bind(null, true), finalizeInit.bind(null, false));\n\t} else {\n\t  finalizeInit(true);\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Discovery = __webpack_require__(1);\n\t\n\tvar _Discovery2 = _interopRequireDefault(_Discovery);\n\t\n\tvar _PromiseUtil = __webpack_require__(4);\n\t\n\tvar _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);\n\t\n\tvar _PopupComponent = __webpack_require__(21);\n\t\n\tvar _PopupComponent2 = _interopRequireDefault(_PopupComponent);\n\t\n\tvar _IframeComponent = __webpack_require__(3);\n\t\n\tvar _IframeComponent2 = _interopRequireDefault(_IframeComponent);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar ImplicitFlow = {\n\t  /**\n\t   * @param options.serverUri\n\t   * @param options.clientId\n\t   * @param options.redirectUri\n\t   * @param options.loginVisualComponent\n\t   * @param options.loginParams\n\t   */\n\t  login: function login(options) {\n\t    var opts = options || {};\n\t\n\t    // check that required data is available\n\t    var serverUri = opts.serverUri;\n\t    if (!serverUri) throw new Error(\"ImplicitFlow.login requires option 'serverUri'.\");\n\t    var clientId = opts.clientId;\n\t    if (!clientId) throw new Error(\"ImplicitFlow.login requires option 'clientId'.\");\n\t    var redirectUri = opts.redirectUri;\n\t    if (!redirectUri) throw new Error(\"ImplicitFlow.login requires option 'redirectUri'.\");\n\t\n\t    // NOTE Using PromiseUtil.immediateThen which will run our \"then\" callback immediately if\n\t    // the Discovery.getMetadata is already resolved. The idea is that this login could have\n\t    // been triggered from \"click\" event and we need to open popup window within this event's\n\t    // lifetime or within single Promise (but not Promise chain because that doesn't work on\n\t    // iPhones).\n\t    return _PromiseUtil2.default.immediateThen(_Discovery2.default.getMetadata(serverUri), function (oidcMetadata) {\n\t      // prepare login URL\n\t      var loginParams = Object.assign({ scope: \"openid\" }, opts.loginParams, {\n\t        response_type: \"id_token token\",\n\t        client_id: clientId,\n\t        redirect_uri: redirectUri\n\t      });\n\t      var loginParamsParts = [];\n\t      for (var k in loginParams) {\n\t        var v = loginParams[k];\n\t        if (v == null) continue;\n\t        loginParamsParts.push(encodeURIComponent(k) + \"=\" + encodeURIComponent(v + \"\"));\n\t      }\n\t      var loginUrl = oidcMetadata.authorization_endpoint + \"?\" + loginParamsParts.join(\"&\");\n\t\n\t      // display visual component for logging in (popup window)\n\t      var LoginVisualComponent = opts.loginVisualComponent || (loginParams.prompt != \"none\" ? _PopupComponent2.default : _IframeComponent2.default);\n\t      return new Promise(function (resolve, reject) {\n\t        new LoginVisualComponent({\n\t          url: loginUrl,\n\t          onResult: function onResult(aLoginResult) {\n\t            var authResponse = ImplicitFlow.getAuthResponseFromCallback(aLoginResult);\n\t            if (authResponse === false) return reject(new Error(\"User refused to sign in or the operation didn't complete successfully, e.g. due to popup blocking.\"));\n\t\n\t            // resolve the promise successfully with the token (iff there's no \"error\" field)\n\t            if (authResponse.error) reject(authResponse);else resolve(authResponse);\n\t          }\n\t        }).render();\n\t      });\n\t    }, function (e) {\n\t      return Promise.reject(e);\n\t    });\n\t  },\n\t\n\t  /**\n\t   * \n\t   * @param {*} aLoginCallbackResult \n\t   * @return One of: \n\t   * * false - user refused to log in (or popups are blocked)\n\t   * * object with \"error\" field set - an error\n\t   * * object - the OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...\n\t   */\n\t  getAuthResponseFromCallback: function getAuthResponseFromCallback(aLoginCallbackResult) {\n\t    if (aLoginCallbackResult === false) return aLoginCallbackResult;\n\t\n\t    // extract login token\n\t    // example of successful aLoginCallbackResult: \"...#access_token=UUOIDCAT-27a13a6e626a40c49e036cbab55f3e27&id_token=eyJ0eXAiOi...&token_type=Bearer&expires_in=7200&scope=openid\" \n\t    // example of error aLoginCallbackResult:      \"...#error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR\"\n\t    var authResponse = {};\n\t    aLoginCallbackResult.replace(/^[^#]*#?/, \"\").split(/&/).forEach(function (it) {\n\t      var eqlIdx = it.indexOf(\"=\");\n\t      var key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\\+/g, \" \"));\n\t      var value = decodeURIComponent((eqlIdx == -1 ? \"\" : it.substr(eqlIdx + 1)).replace(/\\+/g, \" \"));\n\t      authResponse[key] = value;\n\t    });\n\t    return authResponse;\n\t  }\n\t};\n\t\n\texports.default = ImplicitFlow;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// login callback handling\n\tvar VC_CALLBACK_FN_NAME = \"uuOidcCallbackFn\"; // !!! Must be in sync with the one in callbacks/oidc-callback.html.\n\t\n\t// make sure that callback works correctly even if multiple invocations using visual component below were\n\t// done (e.g. user clicked 2 different buttons for command invocations which each opened a login popup\n\t// and are now displayed both)\n\tif (typeof window != \"undefined\" && !window[VC_CALLBACK_FN_NAME]) {\n\t  window[VC_CALLBACK_FN_NAME] = function (aLoginResult, aSourceWindow) {\n\t    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;\n\t    // received callback from a popup => find out which component is using the source window and notify it\n\t    for (var i = 0; i < loginWindows.length; ++i) {\n\t      var p = loginWindows[i];\n\t      if (p.state.loginWindow == aSourceWindow) {\n\t        p.component.finalize(aLoginResult);\n\t        return;\n\t      }\n\t    }\n\t    console.warn(\"Received unexpected callback from window\", aSourceWindow, \"Passed result was:\", aLoginResult, \"Ignoring the callback.\");\n\t  };\n\t  window[VC_CALLBACK_FN_NAME].loginWindows = [];\n\t}\n\t\n\texports.default = {\n\t  registerForCallback: function registerForCallback(component, state) {\n\t    window[VC_CALLBACK_FN_NAME].loginWindows.push({ component: component, state: state });\n\t  },\n\t  unregisterForCallback: function unregisterForCallback(component) {\n\t    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;\n\t    for (var i = 0; i < loginWindows.length; ++i) {\n\t      // remove self from opened loginWindows\n\t      if (loginWindows[i].component === component) {\n\t        loginWindows.splice(i, 1);\n\t        break;\n\t      }\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar Base64Url = {\n\t  /**\n\t   * @param txtAscii Ascii string to encode (each character is in range 0-255).\n\t   * @return {string} Provided string encoded to Base64Url encoding.\n\t   */\n\t  encodeAscii: function encodeAscii(txtAscii) {\n\t    if (!txtAscii) return txtAscii;\n\t    return btoa(txtAscii).replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n\t  },\n\t  /**\n\t   * @param txtUtf8 UTF-8 string to encode.\n\t   * @return {string} Provided string encoded to Base64Url encoding.\n\t   */\n\t  encode: function encode(txtUtf8) {\n\t    if (!txtUtf8) return txtUtf8;\n\t    return Base64Url.encodeAscii(unescape(encodeURIComponent(txtUtf8)));\n\t  },\n\t  /**\n\t   * @return {string} Base64Url decoded to an Ascii string (each character is in range 0-255).\n\t   */\n\t  decodeToAscii: function decodeToAscii(base64Url) {\n\t    if (!base64Url) return null;\n\t    var base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\t    return atob(base64);\n\t  },\n\t  /**\n\t   * @return {string} Base64Url decoded to a UTF-8 string.\n\t   */\n\t  decode: function decode(base64Url) {\n\t    var ascii = Base64Url.decodeToAscii(base64Url);\n\t    return ascii != null ? decodeURIComponent(escape(ascii)) : null;\n\t  }\n\t};\n\texports.default = Base64Url;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// helper for invoking Ajax requests and returning Promise\n\tfunction xhrJson(method, url, body, extraSettingFn) {\n\t  return new Promise(function (resolve, reject) {\n\t    var xhr = new XMLHttpRequest();\n\t    xhr.open(method, url, true);\n\t    xhr.withCredentials = true;\n\t    xhr.setRequestHeader(\"Accept\", \"application/json\");\n\t    xhr.onreadystatechange = function (e) {\n\t      if (xhr.readyState == 4) {\n\t        if (xhr.status >= 200 && xhr.status < 300) {\n\t          try {\n\t            var json = JSON.parse(xhr.responseText);\n\t            resolve(json);\n\t          } catch (err) {\n\t            reject(err);\n\t          }\n\t        } else {\n\t          reject(new Error(\"Server responded with status \" + xhr.status)); // TODO Better error.\n\t        }\n\t      }\n\t    };\n\t    xhr.withCredentials = true;\n\t    if (extraSettingFn) extraSettingFn(xhr);\n\t    xhr.send(body);\n\t  });\n\t}\n\t\n\texports.default = {\n\t  get: function get() {\n\t    return xhrJson.bind(this, \"GET\").apply(this, Array.prototype.slice.call(arguments));\n\t  },\n\t  post: function post() {\n\t    return xhrJson.bind(this, \"POST\").apply(this, Array.prototype.slice.call(arguments));\n\t  }\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  toSnakeCase: function toSnakeCase(aText) {\n\t    return (aText || \"\").replace(/[A-Z]/g, function (m) {\n\t      return \"_\" + m.toLowerCase();\n\t    });\n\t  }\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_12__;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t// NOTE If changed, update also JSDoc in Session.js.\n\texports.default = {\n\t    serverUri: \"https://oidc.plus4u.net/uu-oidcg01-main/0-0\",\n\t    sessionCheckInterval: 60\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar SessionContext = function SessionContext(loginOptions, authResponse, claims) {\n\t  _classCallCheck(this, SessionContext);\n\t\n\t  this.loginOptions = loginOptions;\n\t  this.authResponse = authResponse;\n\t  this.claims = claims;\n\t\n\t  this.getClaims = function () {\n\t    return claims;\n\t  };\n\t\n\t  var identity;\n\t  this.getIdentity = function () {\n\t    if (identity) return identity;\n\t    return identity = {\n\t      id: claims[\"sub\"],\n\t      name: claims[\"name\"],\n\t      email: claims[\"email\"],\n\t      uuIdentity: claims[\"uu_identity\"],\n\t      levelOfAssurance: Number(claims[\"loa\"]),\n\t      loginLevelOfAssurance: Number(claims[\"acr\"])\n\t    };\n\t  };\n\t};\n\t\n\texports.default = SessionContext;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = SessionHandler;\n\t\n\tvar _uu_appg01_core = __webpack_require__(5);\n\t\n\tvar UuApp = _interopRequireWildcard(_uu_appg01_core);\n\t\n\tvar _Session = __webpack_require__(6);\n\t\n\tvar _Session2 = _interopRequireDefault(_Session);\n\t\n\tvar _StringUtil = __webpack_require__(11);\n\t\n\tvar _StringUtil2 = _interopRequireDefault(_StringUtil);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\t// NOTE Interceptor expects gateway present, i.e. it must be added after UriHandler.\n\t\n\t/**\n\t * @class UuOidc.SessionHandler\n\t * @classdesc\n\t * Interceptor for Client which authenticates command calls by using user from\n\t * current / specified session. Additionally, if server responds with authentication challenge\n\t * (e.g. user needs to login with more secure realm or re-login due to inactivity), the interceptor\n\t * performs session login and calls the command again.\n\t * \n\t * Interceptor is skipped if there's request header \"authorization\" set for the command call, even\n\t * if the header value is null.\n\t * \n\t * **Configuration**\n\t * \n\t * Interceptor recognizes following options for command call:\n\t * \n\t * * uuoidc.loginParameters - object with extra parameters for login. See {@link UuOidc.Session#login} for supported values.\n\t * * session - the session to use for authentication. By default {@link UuOidc.Session.currentSession Session.currentSession} is used.\n\t * \n\t * **Error handling**\n\t * \n\t * Interceptor might cause the command call to fail with these errors (in addition to standard Client ones):\n\t * \n\t * * UuApp.Error.AbortError - in case that the command requires user to be logged in but the user refused to do so.\n\t */\n\tfunction SessionHandler(request, options, nextInterceptorFn) {\n\t  var hasCustomAuthn = \"authorization\" in request.headers;\n\t  if (hasCustomAuthn) return nextInterceptorFn(request, options);\n\t\n\t  var session = options.session || _Session2.default.currentSession;\n\t  var loginParams = options[\"uuoidc.loginParameters\"];\n\t  if (loginParams) loginParams = Object.keys(loginParams).reduce(function (r, k) {\n\t    return r[_StringUtil2.default.toSnakeCase(k)] = loginParams[k], r;\n\t  }, {});\n\t  var count = 0;\n\t\n\t  function runWith(extraLoginParams) {\n\t    if (++count > 5) throw new UuApp.Error.AbortError(\"Command invocation stopped because user was not able to fulfill login requirements for the command within \" + count + \" attempts.\");\n\t\n\t    // depending on presence of login parameters, either perform the log-in or just use the current user (even if not logged in)\n\t    var usedLoginParams = Object.assign({}, loginParams, extraLoginParams);\n\t    return (Object.keys(usedLoginParams).length > 0 ? session._login(usedLoginParams, true) : Promise.resolve(session)).catch(function (e) {\n\t      // if user login failed then abort or throw\n\t      if (e === false) throw new UuApp.Error.AbortError(\"Command invocation stopped because user refused to log in.\");\n\t      throw new UuApp.Error.Error(\"Command invocation stopped because of a login error.\", e);\n\t    }).then(function (session) {\n\t      var isAuthenticated = session.isAuthenticated();\n\t      if (isAuthenticated) {\n\t        var baseUri = request.uri.baseUri;\n\t        return Promise.resolve(session.getCallToken(baseUri.toString())).then(function (callToken) {\n\t          return { isAuthenticated: isAuthenticated, callToken: callToken };\n\t        });\n\t      }\n\t      return { isAuthenticated: isAuthenticated, callToken: null };\n\t    }).then(function (data) {\n\t      var isAuthenticated = data.isAuthenticated;\n\t      var callToken = data.callToken;\n\t      var authToken = callToken ? callToken.token : null;\n\t      if (authToken) request.headers[\"authorization\"] = [callToken.tokenType || \"Bearer\", authToken].join(\" \");\n\t      return nextInterceptorFn(request, options).catch(function (response) {\n\t        // check for special response values in WWW-Authenticate response header which indicates\n\t        // that we shall run login procedure with additional parameters and then try again the same command\n\t        var wwwAuthenticate = response.headers(\"www-authenticate\");\n\t        if (wwwAuthenticate) {\n\t          var valueMap = {};\n\t          wwwAuthenticate.replace(/^\\S+\\s+/, \"\").split(/,/).map(function (it) {\n\t            return it.trim();\n\t          }).forEach(function (it) {\n\t            // remove \"Bearer \"\n\t            var idx = it.indexOf(\"=\");\n\t            var key = decodeUriWithPlus(idx == -1 ? it : it.substr(0, idx));\n\t            var value = decodeUriWithPlus(idx == -1 ? \"\" : it.substr(idx + 1));\n\t            valueMap[key] = decodeUriWithPlus(value);\n\t          });\n\t\n\t          var relevantValues = Object.keys(valueMap).filter(function (key) {\n\t            return key.match(/^(max_age|acr_values|prompt|scope)$/);\n\t          }).reduce(function (r, k) {\n\t            return r[k] = valueMap[k], r;\n\t          }, {});\n\t          // if there's any of relevant keys in the WWW-Authenticate response header then\n\t          // re-run the whole OIDC Handler with those values sent to login\n\t          if (Object.keys(relevantValues).length > 0) return runWith(relevantValues);\n\t\n\t          // OI if we weren't logged in at the time of invocation and there's wwwAuthenticate then re-run also\n\t          if (!isAuthenticated) return runWith({ acr_values: \"1\" }); // require non-anonymous\n\t        }\n\t        return Promise.reject(response);\n\t      });\n\t    });\n\t  }\n\t  return runWith(null);\n\t}\n\t\n\tfunction decodeUriWithPlus(txt) {\n\t  return decodeURIComponent(txt.replace(/\\+/g, \" \"));\n\t}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.SessionHandler = exports.Session = undefined;\n\t\n\tvar _Session = __webpack_require__(6);\n\t\n\tvar _Session2 = _interopRequireDefault(_Session);\n\t\n\tvar _SessionHandler = __webpack_require__(15);\n\t\n\tvar _SessionHandler2 = _interopRequireDefault(_SessionHandler);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// make UuOidc always present in global variable so that there're no issues\n\t// with detecting it (even during load via SystemJS)\n\tif (typeof window !== \"undefined\") window.UuOidc = { Session: _Session2.default, SessionHandler: _SessionHandler2.default };\n\t\n\texports.Session = _Session2.default;\n\texports.SessionHandler = _SessionHandler2.default;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Discovery = __webpack_require__(1);\n\t\n\tvar _Discovery2 = _interopRequireDefault(_Discovery);\n\t\n\tvar _HttpClient = __webpack_require__(10);\n\t\n\tvar _HttpClient2 = _interopRequireDefault(_HttpClient);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar jwkSetCache = {};\n\tvar cacheBustCounter = 0;\n\t\n\t// JWK - JSON Web Key https://tools.ietf.org/html/rfc7517\n\t\n\tvar _class = function () {\n\t  function _class(options) {\n\t    _classCallCheck(this, _class);\n\t\n\t    if (!options || !options.serverUri) throw new Error(\"Jwks must be initialized with options containing serverUri.\");\n\t    this.options = options;\n\t  }\n\t\n\t  _createClass(_class, [{\n\t    key: \"getKey\",\n\t    value: function getKey(keyId, keyType) {\n\t      return this._getKey(keyId, keyType, false);\n\t    }\n\t  }, {\n\t    key: \"_getKey\",\n\t    value: function _getKey(keyId, keyType, forceKeySetReload) {\n\t      var _this = this;\n\t\n\t      // load set of OIDC server JSON Web Key-s\n\t      return _Discovery2.default.getMetadata(this.options.serverUri).then(function (metadata) {\n\t        // TODO Use also localStorage cache as optimization.\n\t        var jwkSetMeta = jwkSetCache[metadata.jwks_uri];\n\t        if (!jwkSetMeta || forceKeySetReload) {\n\t          var url = metadata.jwks_uri;\n\t          if (forceKeySetReload) url = url.replace(/(\\?.*)?$/, function (m) {\n\t            return \"?cachebust=\" + Date.now().toString(36) + \"_\" + (cacheBustCounter++).toString(36) + (m ? \"&\" + m.substr(1) : \"\");\n\t          });\n\t          jwkSetMeta = jwkSetCache[metadata.jwks_uri] = _HttpClient2.default.get(url).then(function (value) {\n\t            return { jwkSet: value, url: url };\n\t          });\n\t        }\n\t        return jwkSetMeta;\n\t      }).then(function (jwkSetMeta) {\n\t        var jwkSet = jwkSetMeta.jwkSet;\n\t        // choose key by id & type\n\t        var keys = jwkSet.keys;\n\t        if (keyId) keys = keys.filter(function (it) {\n\t          return it.kid === keyId;\n\t        }); // if specific key ID is used then use it (note that there might still be multiple of keys in the result)\n\t        if (keyType) keys = keys.filter(function (it) {\n\t          return it.kty === keyType;\n\t        });\n\t        // keys = keys.filter(it => it.use === \"sig\" || (it.key_ops||[]).indexOf(\"verify\") !== -1 || (!it.key_ops && !it.use)); // consider only keys for verification / signing (or unspecified)\n\t        if (keys.length != 1) {\n\t          // try force-reloading of the JWK set because the URL from which we downloaded it might have been previously cached by browser\n\t          // and the server might have changed keys (e.g. due to restart or just because it changes them from time to time)\n\t          if (!forceKeySetReload) return _this._getKey(keyId, keyType, true);\n\t          throw new Error(\"There's \" + keys.length + \" JSON Web Key(s) in JWK Set with kid='\" + keyId + \"' kty='\" + keyType + \"'. There must be exactly 1. JWK Set has been downloaded from: \" + jwkSetMeta.url);\n\t        }\n\t        return keys[0];\n\t      });\n\t    }\n\t  }]);\n\n\t  return _class;\n\t}();\n\n\texports.default = _class;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Base64Url = __webpack_require__(9);\n\t\n\tvar _Base64Url2 = _interopRequireDefault(_Base64Url);\n\t\n\tvar _InvalidTokenError = __webpack_require__(2);\n\t\n\tvar _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);\n\t\n\tvar _JwtVerifierWebCrypto = __webpack_require__(20);\n\t\n\tvar _JwtVerifierWebCrypto2 = _interopRequireDefault(_JwtVerifierWebCrypto);\n\t\n\tvar _JwtVerifierJsrsasign = __webpack_require__(19);\n\t\n\tvar _JwtVerifierJsrsasign2 = _interopRequireDefault(_JwtVerifierJsrsasign);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// JWT - JSON Web Token https://tools.ietf.org/html/rfc7519\n\t//     - JSON (containing claims) encoded in a JWS / JWE structure\n\t// JWS - JSON Web Signature https://tools.ietf.org/html/rfc7515\n\t// JWE - JSON Web Encryption https://tools.ietf.org/html/rfc7516\n\t\n\t// NOTE WebCrypto API works only via https://* or http://localhost (rare exception), but not on http://localhost.plus4u.net\n\t// so we're falling back to on-demand loaded jsrsasign library (which will be therefore used mostly during development,\n\t// but not on production; it's ~90kB of minified code).\n\tvar hasWebCrypto = typeof crypto != \"undefined\" && crypto.subtle && crypto.subtle.importKey;\n\tvar useWebCrypto = hasWebCrypto && (typeof location == \"undefined\" || location.protocol == \"https:\");\n\tvar verifier = useWebCrypto ? _JwtVerifierWebCrypto2.default : _JwtVerifierJsrsasign2.default;\n\t\n\tvar DEFAULT_ALG = \"RS256\";\n\texports.default = {\n\t  /**\n\t   * \n\t   */\n\t  decode: function decode(token, verifyOpts, getKeyFn) {\n\t    var tokenParts;\n\t    var header;\n\t    return Promise.resolve().then(function () {\n\t      if (typeof token != \"string\") throw new Error(\"Invalid JSON Web Token - it must be a string (result of JWS / JWE Compact Serialization as per RFC7515 / RFC7516).\");\n\t      tokenParts = token.split(\".\");\n\t      if (tokenParts.length != 3) throw new Error(\"Unsupported JSON Web Token - the token doesn't consist of header+body+signature (only JWS Compact Serialization is supported - RFC7515, section-3). Token: \" + token);\n\t\n\t      // parse header\n\t      var headerB64U = tokenParts[0];\n\t      var headerStr = _Base64Url2.default.decode(headerB64U);\n\t      header = JSON.parse(headerStr);\n\t      if (header.typ != \"JWT\") throw new Error(\"Invalid JSON Web Token - the header 'typ' field is not set to 'JWT'. Token: \" + token);\n\t\n\t      // get key\n\t      return getKeyFn(header);\n\t    }).then(function (key) {\n\t      // NOTE Check the whole importKey call if adding support for other key types.\n\t      if (!key || key.kty != \"RSA\") throw new Error(\"Unsupported key type. Only RSA keys are supported for JSON Web Token signature verification. Key: \" + JSON.stringify(key));\n\t      // always verify algorithm against the one is JOSE header\n\t      var alg = key.alg || DEFAULT_ALG;\n\t      if (alg !== header.alg) throw new _InvalidTokenError2.default(\"Invalid JSON Web Token or wrong verification key - algorithms don't match. Token uses '\" + header.alg + \"', verification key uses '\" + key.alg + \"' (with default of '\" + DEFAULT_ALG + \"'). Token: \" + token + \" Key: \" + JSON.stringify(key));\n\t\n\t      return verifier.verify(key, alg, verifyOpts, header, tokenParts, token);\n\t    }).then(function (valid) {\n\t      if (!valid) throw new _InvalidTokenError2.default(\"Invalid JSON Web Token: \" + token);\n\t      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);\n\t      var body = JSON.parse(bodyStr);\n\t      return body;\n\t    });\n\t  }\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _module = __webpack_require__(12);\n\t\n\tvar _module2 = _interopRequireDefault(_module);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar scriptUri = ((_module2.default ? _module2.default.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName(\"script\"), -1)[0] || {}).src) || \"\").toString();\n\tvar jsrsasign = undefined;\n\tvar Verifier = {\n\t  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {\n\t    var _this = this;\n\t\n\t    return Promise.resolve().then(function () {\n\t      // load jsrsasign library on 1st verification\n\t      if (jsrsasign === undefined) {\n\t        var continueFn = Verifier.verify.bind(_this, key, alg, verifyOpts, header, tokenParts, token);\n\t        var isMin = scriptUri.indexOf(\".min.\") != -1;\n\t        var baseUrl = scriptUri.replace(/^(.*\\/).*/, \"$1\");\n\t        var url = baseUrl + \"jsrsasign\" + (isMin ? \".min\" : \"\") + \".js\";\n\t        var loadPromise;\n\t        if (typeof System != \"undefined\") loadPromise = System.import(url);else loadPromise = new Promise(function (resolve, reject) {\n\t          var script = document.createElement(\"script\");\n\t          script.onload = function () {\n\t            resolve(window[\"Jsrsasign\"]);\n\t          };\n\t          script.onerror = function (e) {\n\t            reject(e);\n\t          };\n\t          script.src = url;\n\t          document.head.appendChild(script);\n\t        });\n\t        return loadPromise.then(function (obj) {\n\t          jsrsasign = obj || null;\n\t          return continueFn();\n\t        }, function (e) {\n\t          console.error(e);\n\t          jsrsasign = null;\n\t          return continueFn();\n\t        });\n\t      }\n\t      if (!jsrsasign) throw new Error(\"Unable to verify token because jsrsasign library failed to load.\");\n\t\n\t      // var exampleKey = {\"kty\":\"RSA\",\"e\":\"AQAB\",\"n\":\"yXxJt2xevNsgGGGFfX5e22Jvy0_Eopgkumz7mJ7ScWlPfsMsAi8BZsF7nbDjA3T3v2vy2_-DaLDg-z-BjRwQIPL1LRzQGeDDSVmPcZtbexqkpjouxZ6-abpefSAFX5cA8NJ5h4JknFJWAsxxKEw4Ogy6XFd_BEaDmyXlLcV65Bs\",\"alg\":\"RS256\",\"kid\":\"rJZx5vzX1FOt_Nt8sB8jUA\",\"use\":\"sig\"};\n\t      // var pem = KEYUTIL.getPEM(jsrsasign.KEYUTIL.getKey(exampleKey));\n\t      //   =>\n\t      // -----BEGIN PUBLIC KEY-----\n\t      // MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDJfEm3bF682yAYYYV9fl7bYm/L\n\t      // T8SimCS6bPuYntJxaU9+wywCLwFmwXudsOMDdPe/a/Lb/4NosOD7P4GNHBAg8vUt\n\t      // HNAZ4MNJWY9xm1t7GqSmOi7Fnr5pul59IAVflwDw0nmHgmScUlYCzHEoTDg6DLpc\n\t      // V38ERoObJeUtxXrkGwIDAQAB\n\t      // -----END PUBLIC KEY-----\n\t\n\t      // do the verification\n\t      var keyInst = jsrsasign.KEYUTIL.getKey(key);\n\t      var result = jsrsasign.jws.JWS.verifyJWT(token, keyInst, verifyOpts); // see lib/jsrsasign-.../jws-3.3.js\n\t      return result || Promise.reject(new Error(\"Token is not valid. Token: \" + token));\n\t    });\n\t  }\n\t};\n\t\n\tmodule.exports = Verifier;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _Base64Url = __webpack_require__(9);\n\t\n\tvar _Base64Url2 = _interopRequireDefault(_Base64Url);\n\t\n\tvar _InvalidTokenError = __webpack_require__(2);\n\t\n\tvar _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tmodule.exports = {\n\t  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {\n\t    var webCryptoAlgorithm = {\n\t      name: \"RSASSA-PKCS1-v1_5\",\n\t      hash: { name: \"SHA-\" + alg.substr(2) }\n\t    };\n\t    // MS Edge throws error if the key contains field \"use\" => remove it\n\t    // https://connect.microsoft.com/IE/feedback/details/2242108/webcryptoapi-importing-jwk-with-use-field-fails\n\t    var usedKey = JSON.parse(JSON.stringify(key));\n\t    delete usedKey.use;\n\t\n\t    return crypto.subtle.importKey(\"jwk\", usedKey, webCryptoAlgorithm, false, [\"verify\"]).then(function (webCryptoKey) {\n\t      // validate signature\n\t      var signatureB64U = tokenParts[2];\n\t      var data = tokenParts[0] + \".\" + tokenParts[1];\n\t      var signatureBytes = asciiToUint8Array(_Base64Url2.default.decodeToAscii(signatureB64U));\n\t      var dataBytes = asciiToUint8Array(data);\n\t      return crypto.subtle.verify(webCryptoKey.algorithm, webCryptoKey, signatureBytes, dataBytes);\n\t    }, function (importError) {\n\t      var e = new Error(\"Unable to verify JSON Web Token - importing key via WebCrypto API failed.\\nKey: \" + JSON.stringify(usedKey) + \"\\nToken: \" + token + \"\\nError: \" + importError);\n\t      e.cause = importError;\n\t      return Promise.reject(e);\n\t    }).then(function (signatureValid) {\n\t      if (!signatureValid) throw new _InvalidTokenError2.default(\"Invalid JSON Web Token - signature is not valid. Token: \" + token);\n\t      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);\n\t      var body = JSON.parse(bodyStr);\n\t      var throwError = function throwError(txt, failedClaim) {\n\t        throw new _InvalidTokenError2.default(\"Invalid token: \" + txt + \"\\nFailed claim: \" + JSON.stringify(failedClaim) + \"\\nIssued by: \" + JSON.stringify(body.iss) + \"\\nVerification options: \" + JSON.stringify(verifyOpts) + \"\\nToken: \" + token);\n\t      };\n\t\n\t      // verify claims\n\t\n\t      // 'alg' is always checked\n\t      if (!verifyOpts.alg) throw new Error(\"Unable to verify JWT claim - 'alg' field must be always given for verification.\");\n\t      if (verifyOpts.alg.indexOf(header.alg) == -1) throwError(\"Algorithm \" + JSON.stringify(header.alg) + \" used by token is not valid - expected one of \" + JSON.stringify(verifyOpts.alg) + \".\", \"alg\");\n\t\n\t      // 'iss'\n\t      var v;\n\t      v = asArray(verifyOpts.iss);\n\t      if (v && v.indexOf(body.iss) === -1) throwError(\"Issuer URI \" + JSON.stringify(body.iss) + \" in token is not valid - expected one of \" + JSON.stringify(v) + \". Token was issued by different OpenID Connect server or it was forged.\", \"iss\");\n\t\n\t      // 'sub'\n\t      v = asArray(verifyOpts.sub);\n\t      if (v && v.indexOf(body.sub) === -1) throwError(\"Subject \" + JSON.stringify(body.sub) + \" in token is not valid - expected one of \" + JSON.stringify(v) + \".\", \"sub\");\n\t\n\t      // 'aud' - all values from verifyOpts.aud must be present in body.aud \n\t      v = asArray(verifyOpts.aud);\n\t      var bodyV = asArray(body.aud) || [];\n\t      if (v && bodyV.some(function (bv) {\n\t        return v.indexOf(bv) == -1;\n\t      })) throwError(\"Audience list \" + JSON.stringify(bodyV) + \" in token is not valid - some of following values are missing: \" + JSON.stringify(v) + \".\", \"aud\");\n\t\n\t      // time validity: (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)\n\t      var now = Date.now() / 1000;\n\t      if (verifyOpts.verifyAt) now = verifyOpts.verifyAt;\n\t      var gracePeriod = verifyOpts.gracePeriod || 0;\n\t\n\t      // 'exp' - expires\n\t      if (typeof body.exp === \"number\" && body.exp + gracePeriod < now) throwError(\"Token already expired at \" + toTimeString(body.exp) + \", current time is \" + toTimeString(now) + \".\", \"exp\");\n\t\n\t      // 'nbf' - not before\n\t      if (typeof body.nbf === \"number\" && now < body.nbf - gracePeriod) throwError(\"Token is not yet valid - it will become valid at \" + toTimeString(body.nbf) + \", current time is \" + toTimeString(now) + \". Check that your system time is correctly set.\", \"nbf\");\n\t\n\t      // 'iat' - issued at time\n\t      if (typeof body.iat === \"number\" && now < body.iat - gracePeriod) throwError(\"Token seems to have been issued in the future - \" + toTimeString(body.iat) + \", current time is \" + toTimeString(now) + \". Check that your system time is correctly set.\", \"iat\");\n\t\n\t      // 'jti' - JWT id\n\t      if (verifyOpts.jti && body.jti !== verifyOpts.jti) throwError(\"Token ID \" + JSON.stringify(body.jti) + \" not valid - expected \" + JSON.stringify(verifyOpts.jti) + \".\", \"jti\");\n\t\n\t      return true;\n\t    });\n\t  }\n\t};\n\t\n\tfunction asciiToUint8Array(ascii) {\n\t  return new Uint8Array(ascii.split(\"\").map(function (c) {\n\t    return c.charCodeAt(0);\n\t  }));\n\t}\n\tfunction asArray(value) {\n\t  if (value == null) return null;\n\t  if (Array.isArray(value)) return value;\n\t  return [value];\n\t}\n\tfunction toTimeString(seconds) {\n\t  return new Date(seconds * 1000).toISOString().replace(/T/, \" \");\n\t}\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _CallbackHandler = __webpack_require__(8);\n\t\n\tvar _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Default visual component for presenting login/logout prompt to the user. It displays the\n\t * URL in a popup window and waits until the user logs in / closes the window. After that\n\t * initAttrs.onResult(authResultUrl) is called as callback.\n\t * \n\t * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.\n\t * @param initAttrs.onResult The callback to call after login finishes. If the login finished\n\t *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.\n\t *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which\n\t *   contains the authentication response in fragment). \n\t */\n\tvar PopupComponent = function PopupComponent(initAttrs) {\n\t  var attrs = Object.assign({}, initAttrs);\n\t  var state = {\n\t    loginWindow: null,\n\t    closeCheckInterval: null\n\t  };\n\t\n\t  // add self to the list of opened loginWindows\n\t  _CallbackHandler2.default.registerForCallback(this, state);\n\t\n\t  this.finalize = function (result) {\n\t    // cleanup & do the callback\n\t    this.destroy();\n\t    if (attrs.onResult) attrs.onResult(result);\n\t  }.bind(this);\n\t\n\t  var closeCheck = function () {\n\t    if (!state.loginWindow || !state.loginWindow.closed) return;\n\t    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value \"false\"\n\t  }.bind(this);\n\t\n\t  this.render = function () {\n\t    var _this = this;\n\t\n\t    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)\n\t    if (!state.loginWindow) {\n\t      var rect = { width: 599, height: 600 };\n\t      rect.left = (screen.availWidth - rect.width) / 2 + screen.availLeft;\n\t      rect.top = (screen.availHeight - rect.height) / 2 + screen.availTop;\n\t      state.loginWindow = window.open(attrs.url, \"_blank\", \"toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=\" + rect.width + \",height=\" + rect.height + \",top=\" + rect.top + \",left=\" + rect.left);\n\t      if (!state.loginWindow) {\n\t        // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in\n\t        Promise.resolve().then(function () {\n\t          return _this.finalize(false);\n\t        }); // finalize in async way\n\t      } else {\n\t        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);\n\t      }\n\t    }\n\t  };\n\t\n\t  this.destroy = function () {\n\t    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();\n\t    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);\n\t    this.destroy = function () {};\n\t    _CallbackHandler2.default.unregisterForCallback(this);\n\t  };\n\t};\n\t\n\texports.default = PopupComponent;\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\")();\n\tvar domReadyPromise = isBrowser ? document.readyState === \"interactive\" || document.readyState === \"complete\" ? Promise.resolve() : new Promise(function (resolve) {\n\t  document.addEventListener(\"DOMContentLoaded\", resolve, false);\n\t}) : Promise.resolve();\n\t\n\texports.default = {\n\t  domReady: domReadyPromise\n\t};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = generateUuid;\n\tfunction generateUuid() {\n\t  // generate UUID (RFC4122 version 4 compliant) for the event ID\n\t  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n\t  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t    var r = Math.random() * 16 | 0,\n\t        v = c == 'x' ? r : r & 0x3 | 0x8;\n\t    return v.toString(16);\n\t  });\n\t  return uuid;\n\t}\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _IframeComponent = __webpack_require__(3);\n\t\n\tvar _IframeComponent2 = _interopRequireDefault(_IframeComponent);\n\t\n\tvar _ImplicitFlow = __webpack_require__(7);\n\t\n\tvar _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Os8Auth = function () {\n\t\n\t  /**\n\t   * @param options.serverUri\n\t   * @param options.clientId\n\t   * @param options.redirectUri\n\t   */\n\t  function Os8Auth(options) {\n\t    _classCallCheck(this, Os8Auth);\n\t\n\t    if (!options || !options.serverUri || !options.clientId || !options.redirectUri) throw new Error(\"Os8Auth must be initialized with options containing serverUri, clientId and redirectUri.\");\n\t    this.options = options;\n\t  }\n\t\n\t  /**\n\t   * @param parameters\n\t   * @param parameters.subject_token\n\t   */\n\t\n\t\n\t  _createClass(Os8Auth, [{\n\t    key: \"grantExchangeToken\",\n\t    value: function grantExchangeToken(parameters) {\n\t      var params = parameters || {};\n\t      if (!params.subject_token) throw new Error(\"Os8Auth.grantExchangeToken must be called with parameter subject_token.\");\n\t      var urlParams = Object.assign({}, params, {\n\t        response_type: \"id_token token\",\n\t        client_id: this.options.clientId,\n\t        redirect_uri: this.options.redirectUri\n\t      });\n\t      var urlParamsParts = Object.keys(urlParams).filter(function (k) {\n\t        return urlParams[k] != null;\n\t      }).map(function (k) {\n\t        return encodeURIComponent(k) + \"=\" + encodeURIComponent(urlParams[k] + \"\");\n\t      });\n\t      var url = this.options.serverUri.replace(/\\/*$/, \"/\") + \"exchangeOs8Token\" + \"?\" + urlParamsParts.join(\"&\");\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        new _IframeComponent2.default({\n\t          url: url,\n\t          onResult: function onResult(aLoginResult) {\n\t            var authResponse = _ImplicitFlow2.default.getAuthResponseFromCallback(aLoginResult);\n\t            if (!authResponse || authResponse.error) reject(authResponse);else resolve(authResponse);\n\t          }\n\t        }).render();\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Os8Auth;\n\t}();\n\t\n\texports.default = Os8Auth;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// uu_oidcg01.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bd7b4e17d247392050ef","var mod=require(\"module\");\n  var uri = ((mod ? mod.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName(\"script\"), -1)[0] || {}).src) || \"\").toString();\n  __webpack_public_path__=uri.split(/\\//).slice(0, -1).join(\"/\") + \"/\"; // runtime publicPath configuration required for proper linking of styles, background images, ...\n  module.exports = require(\"__project__/index.js\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../.tmp/index.js\n// module id = 0\n// module chunks = 0","import HttpClient from \"../util/HttpClient.js\";\nimport PromiseUtil from \"../util/PromiseUtil.js\";\n\nvar oidcMetadataCache = {}; // stores Promises\n\nexport default {\n  /**\n   * @return Promise resolving to OIDC discovery metadata for given issuerUri.\n   */\n  getMetadata: function (aIssuerUri) {\n    var issuerUri = aIssuerUri.replace(/\\/+$/, \"\"); // strip trailing slash(es) (this also normalizes it as a key to cache)\n    var metadata = oidcMetadataCache[issuerUri];\n    if (metadata) return metadata;\n    var discoveryEndpoint = issuerUri + \"/.well-known/openid-configuration\";\n    return oidcMetadataCache[issuerUri] = PromiseUtil.wrapForImmediateThen(HttpClient.get(discoveryEndpoint).catch(e => {\n      delete oidcMetadataCache[issuerUri]; // don't cache errors so that e.g. clicking a button 2nd time (after network is up again) has chance to work\n      throw e;\n    }));\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./discovery/Discovery.js","import {Error as Errors} from \"uu_appg01_core\";\n\nexport default class InvalidTokenError extends Errors.Error {}\n\n\n// WEBPACK FOOTER //\n// ./jwt/InvalidTokenError.js","import CallbackHandler from \"./CallbackHandler.js\";\n\n/**\n * Visual component for attempting user login/logout on a background in an iframe. Usable only for prompt=\"none\" cases.\n * After login/logout initAttrs.onResult(authResultUrl) is called as callback.\n * \n * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.\n * @param initAttrs.onResult The callback to call after login/logout finishes.\n */\nvar IframeComponent = function (initAttrs) {\n  var attrs = Object.assign({}, initAttrs);\n  var state = {\n    iframe: null\n  };\n  Object.defineProperty(state, \"loginWindow\", {\n    get: function () {\n      try { // needs try-catch depending on which phase we're being asked (might be during redirect, ..., which can be cross-domain)\n        return (state.iframe != null ? state.iframe.contentWindow : null);\n      } catch (e) {\n        // ignore\n      }\n      return null;\n    }\n  });\n\n  // add self to the list of openend loginWindows\n  CallbackHandler.registerForCallback(this, state);\n\n  // finalization callback (for this component instance) called after login from redirect_uri page\n  this.finalize = function (aLoginResult) {\n    // cleanup & do the callback\n    this.destroy();\n    if (attrs.onResult) attrs.onResult(aLoginResult);\n  }.bind(this);\n\n  // TODO Maybe use timeout ~30s and destroy in case that something is seriously wrong (network errors, ...).\n\n  this.render = function () {\n    if (!state.iframe) {\n      state.iframe = document.createElement(\"iframe\");\n      state.iframe.style.cssText = \"position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;\";\n      state.iframe.src = attrs.url;\n      document.body.appendChild(state.iframe);\n    }\n  };\n\n  this.destroy = function () {\n    if (state.iframe && state.iframe.parentNode) state.iframe.parentNode.removeChild(state.iframe);\n    this.destroy = function () {};\n    CallbackHandler.unregisterForCallback(this);\n  };\n};\n\nexport default IframeComponent;\n\n\n// WEBPACK FOOTER //\n// ./ui/IframeComponent.js","export default {\n  /**\n   * Wraps Promise so that it can then be used in immediateThen function.\n   */\n  wrapForImmediateThen: function (promise) {\n    promise.then(v => promise._immediateValue = v, e => promise._immediateError = e);\n    return promise;\n  },\n\n  /**\n   * If promise has already been resolved, thenFn is called immediately (or catchFn in\n   * case that the promise has been rejected). Otherwise thenFn and catchFn callbacks\n   * are simply registered via promise.then(thenFn, catchFn).\n   * \n   * Note that this works only on promises that were wrapped via #wrapForImmediateThen\n   * function.\n   * \n   * @return Return value of thenFn/catchFn (if invoked immediately) or promise.then(thenFn, catchFn).\n   */\n  immediateThen: function (promise, thenFn, catchFn) {\n    if (\"_immediateValue\" in promise) return (typeof thenFn == \"function\" ? thenFn(promise._immediateValue) : promise._immediateValue);\n    if (\"_immediateError\" in promise) {\n      if (typeof catchFn == \"function\") return catchFn(promise._immediateError);\n      throw promise._immediateError;\n    }\n    return promise.then(thenFn, catchFn);\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./util/PromiseUtil.js","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"amd\":\"uu_appg01_core\",\"commonjs\":\"uu_appg01_core\",\"commonjs2\":\"uu_appg01_core\",\"root\":\"UuApp\"}\n// module id = 5\n// module chunks = 0","import {Util, Error as Errors} from \"uu_appg01_core\";\nimport Defaults from \"./Defaults.js\";\nimport ImplicitFlow from \"./flow/ImplicitFlow.js\";\nimport SessionContext from \"./SessionContext.js\";\nimport generateUuid from \"./util/Uuid.js\";\nimport Jwt from \"./jwt/Jwt.js\";\nimport InvalidTokenError from \"./jwt/InvalidTokenError.js\";\nimport Jwks from \"./jwks/Jwks.js\";\nimport Discovery from \"./discovery/Discovery.js\";\nimport Os8Auth from \"./uuos8/Os8Auth.js\";\nimport Dom from \"./util/Dom.js\";\nimport PromiseUtil from \"./util/PromiseUtil.js\";\nimport StringUtil from \"./util/StringUtil.js\";\nimport IframeComponent from \"./ui/IframeComponent.js\";\n\nvar Error = Errors.Error;\nexport default class Session {\n\n  /**\n   * Creates new Session with specified options.\n   * \n   * @class UuOidc.Session\n   * @classdesc\n   * \n   * Session handling via OpenID Connect server.\n   * \n   * **Configuration**\n   * \n   * Login via OpenID Connect server **requires a special callback HTML page be present on the domain where application is running**. The callback\n   * HTML page should be copied from the contents of this library (callbacks/oidc-callback.html) to the application and URL path to it must be\n   * configured as described below - configuration parameter \"uuoidc.redirectUri\".\n   * \n   * Following global configuration parameters are used for initializing {@link UuOidc.Session.currentSession Session.currentSession}:\n   * \n   * * **uuoidc.clientId** - OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.\n   *   Default is auto-generated which means that the application will be treated as an anonymous application and therefore might not be authorized for\n   *   accessing most of user data.\n   * * **uuoidc.redirectUri** - Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application\n   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative\n   *   to document.baseURI (current URL). Default is \"callbacks/oidc-callback.html\".\n   * * **uuoidc.serverUri** - OpenID Connect server to perform login / logout against. Default is \"https://oidc.plus4u.net/uu-oidcg01-main/0-0\".\n   * * **uuoidc.sessionCheckInterval** - how often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds. Default is 60.\n   * \n   * @param options {Object|UuApp.Util.Config} Options.\n   * @param options.serverUri OpenID Connect server to perform login / logout against.\n   * @param options.clientId OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.\n   * @param options.redirectUri Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application\n   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative\n   *   to document.baseURI (current URL).\n   * @param options.sessionCheckInterval How often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.\n   */\n  constructor(options) {\n    if (!options) throw new Error(\"Session must be initialized with proper options or UuApp.Util.Config.\");\n    this._optionsMergedPromise = PromiseUtil.wrapForImmediateThen(Promise.resolve(options && typeof options.get == \"function\" ? options.initPromise : options).then(env => {\n      if (env && typeof env.get == \"function\") {\n        this.serverUri = env.get(\"uuoidc.serverUri\", false);\n        this.clientId = env.get(\"uuoidc.clientId\", false);\n        this.implicitFlowRedirectUri = env.get(\"uuoidc.redirectUri\", false);\n        this.sessionCheckInterval = env.get(\"uuoidc.sessionCheckInterval\", false);\n      } else if (env) {\n        this.serverUri = env[\"serverUri\"];\n        this.clientId = env[\"clientId\"];\n        this.implicitFlowRedirectUri = env[\"redirectUri\"];\n        this.sessionCheckInterval = env[\"uuoidc.sessionCheckInterval\"];\n      }\n      if (this.serverUri == null) this.serverUri = Defaults.serverUri;\n      if (this.clientId == null) this.clientId = \"uu-oidc:unregistered-client:\" + generateUuid();\n      if (this.sessionCheckInterval == null) this.sessionCheckInterval = Defaults.sessionCheckInterval;\n      if (!this.implicitFlowRedirectUri) {\n        // console.warn(\"Session login will work only with directly provided access token because no callback URL for OpenID Connect server was specified in\" + \n        //   \" the configuration. To support login via popup, specify redirectUri when creating session, or initialize UuApp.Util.Config with \\\"uuoidc.redirectUri\\\" option.\");\n        this.implicitFlowRedirectUri = \"callbacks/oidc-callback.html\";\n      }\n      // if redirect URI is relative then absolutize it (relative to current document.baseURI)\n      if (!this.implicitFlowRedirectUri.match(/^[a-z]+:/i)) { // no protocol present\n        var baseUrl = toFullUrl(document.baseURI || location.pathname).replace(/^([^?#]*\\/).*/, \"$1\");\n        if (this.implicitFlowRedirectUri.charAt(0) != \"/\") this.implicitFlowRedirectUri = toFullUrl(baseUrl + this.implicitFlowRedirectUri);\n        else this.implicitFlowRedirectUri = toFullUrl(this.implicitFlowRedirectUri);\n      }\n\n      // add session state checking which, in case that we were logged in and a logout\n      // against OIDC is detected (e.g. in another browser tab), will log us out\n      // TODO This is a hotfix solution - proper way is that there's a component scoped by serverUri which performs the session checks.\n      var timeout = Math.max(5, this.sessionCheckInterval) * 1000;\n      var check = function () {\n        // if not logged in then just plan another check (we don't want to auto-login in this tab if user logs in another browser tab)\n        if (!this._loginCtx) return setTimeout(check, timeout);\n\n        // check login state via login (but don't actually use the newly issued token)\n        this._login({\n          acr_values: \"1\",\n          prompt: \"none\"\n        }, false).then(() => {\n          // still logged in => just plan another check\n          setTimeout(check, timeout);\n        }, (e) => {\n          // assume logout\n          delete this._loginCtx;\n          this._runListeners();\n          setTimeout(check, timeout);\n        });\n      }.bind(this);\n      setTimeout(check, timeout);\n    }));\n    this._loginInProgress = [];\n\n    var listeners = [];\n    /**\n     * @return {boolean} True iff the user is authenticated (logged in).\n     * @method UuOidc.Session#isAuthenticated\n     */\n    this.isAuthenticated = () => !!this._loginCtx;\n    /**\n     * Adds listener for changes of user identity (logins / logouts).\n     * \n     * @param {Function(Object)} listener The listener function to add. The function receives identity object or null.\n     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeIdentityChangeListener}).\n     * @see UuOidc.Session#getIdentity\n     * @method UuOidc.Session#addIdentityChangeListener\n     */\n    this.addIdentityChangeListener = (listener) => {\n      listeners.push(listener);\n      return this.removeIdentityChangeListener.bind(this, listener);\n    };\n    /**\n     * Removes listener for changes of user identity (logins / logouts).\n     * \n     * @param {Function(Object)} listener The listener to remove.\n     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).\n     * @method UuOidc.Session#removeIdentityChangeListener\n     */\n    this.removeIdentityChangeListener = (listener) => {\n      var idx = listeners.indexOf(listener);\n      if (idx != -1) listeners.splice(idx, 1);\n      return idx != -1;\n    };\n    this._runListeners = () => {\n      var identity = this.getIdentity();\n      listeners.forEach((it) => it.call(this, identity));\n    };\n\n    this.nonce = Math.random().toString(32).substr(2);\n\n    // add planning & executing of token refresh when its nearing expiration\n    // NOTE This assumes that each token refresh ends with running the identity-change listeners.\n    this.addIdentityChangeListener((identity) => {\n      // console.log(\"Identity change:\", identity);\n      if (this._sessionRefreshTimeout) {\n        clearTimeout(this._sessionRefreshTimeout);\n        delete this._sessionRefreshTimeout;\n      }\n      var claims = this.getClaims();\n      var expiresAt = (claims||{})[\"exp\"];\n      if (!expiresAt) return;\n      expiresAt = expiresAt * 1000; // let it be in milliseconds\n      var LEEWAY = 5 * 60 * 1000;\n      var now = new Date().getTime();\n      var delay = expiresAt - now - LEEWAY;\n      if (delay < 0) delay = 0;\n      // expiresAt = now + 30000;\n      // delay = 20000;\n      // console.log(\"Planning token refresh in \", delay, \"ms.\");\n      this._sessionRefreshTimeout = setTimeout(() => {\n        delete this._sessionRefreshTimeout;\n        // refresh token by calling login() un-interactively\n        this._login({\n          prompt: \"none\", // no user interaction\n          acr_values: \"1\" // non-anonymous user\n        }).catch((e) => {\n          if (this._sessionRefreshTimeout) return; // identity changed in-between (maybe due to login with directly provided access_token)\n          // refresh failed => perform logout few seconds before the token expires\n          var autoLogoutAfter = Math.max(0, expiresAt - new Date().getTime() - 30 * 1000);\n          // console.log(\"Token refresh failed - will perform auto-logout in\", autoLogoutAfter, \"ms.\");\n          this._sessionRefreshTimeout = setTimeout(() => {\n            delete this._loginCtx;\n            this._runListeners();\n          }, autoLogoutAfter);\n        });\n      }, delay);\n    });\n  }\n\n  /**\n   * Returns identity of currently logged in user or null if not logged in. The identity contains following fields:\n   * \n   * * id\n   * * name\n   * * uuIdentity\n   * * email\n   * * levelOfAssurance\n   * * loginLevelOfAssurance\n   * \n   * @return {Object} Identity of currently logged in user or null if not logged in.\n   * @method UuOidc.Session#getIdentity\n   */\n  getIdentity() {\n    return (this._loginCtx ? this._loginCtx.getIdentity() : null);\n  }\n\n  /**\n   * Returns all claims present in the token (or null if not logged in).\n   * \n   * @method UuOidc.Session#getClaims\n   */\n  getClaims() {\n    return (this._loginCtx ? this._loginCtx.getClaims() : null);\n  }\n\n  /**\n   * Login against OpenID Connect server. If no or empty options are used, user will be required to\n   * log in as non-anonymous user (as if { acrValues: 1 } was used). If user is already logged in\n   * and options don't indicate that a re-login is necessary, then the method does nothing. Re-login can\n   * be forced by using option \"prompt\" set to \"login\".\n   * \n   * @param options {Object} Options.\n   * @param options.prompt {string} (optional) One of \"\" (default), \"none\" (check login state without user interaction), \"login\" (re-request authentication).\n   * @param options.acrValues (optional) One of: 0 (allow log in as anonymous), 1 (require non-anonymous user).\n   * @param options.accessToken {string} (optional) Authentication token to use for login. Currently, only id_token (JWT) is supported.\n   * @param options.tokenTypeHint {string} (optional) Hint about the type of the authentication token (accessToken in options) if it\n   *   isn't standard id_token. Supported values depend on OpenID Connect server. uuOS9 server supports these values:\n   * \n   * * \"urn:ietf:params:oauth:token-type:jwt-uuos8\" - indicates that the token being passed to the login was originally issued by uuOS8\n   * \n   * @return Promise resolved after the login ends. The resolved value is this session instance, identity of logged in user can be obtained\n   *   via sessionInstance.{@link UuOidc.Session#getIdentity getIdentity()}. Rejection value is one of:\n   * \n   *   * false - user refused to log in\n   *   * Error - any other error such as network problems, ...\n   * \n   * @method UuOidc.Session#login\n   */\n  login(options) {\n    // NOTE For backward compatibility within version 1.x.y, this method must accept also snake_cased options keys (access_token, ...).\n\n    // convert keys in options to snake_case (that's what is used in the code base of this library as OpenID & OAuth uses it too)\n    var opts;\n    if (options) opts = Object.keys(options).reduce((r, k) => (r[StringUtil.toSnakeCase(k)] = options[k], r), {});\n\n    return this._login(opts, true);\n  }\n\n  // NOTE Uses snake_case in options because that's how OpenID & OAuth is specified.\n  _login(options, updateSessionWithLoginResult = true) {\n    var opts = Object.assign({}, options);\n\n    // there's a special case in which we support providing uuOS8 token\n    var os8Token;\n    if (opts.token_type_hint === \"urn:ietf:params:oauth:token-type:jwt-uuos8\") {\n      os8Token = opts.access_token;\n      delete opts.access_token;\n      delete opts.token_type_hint;\n    }\n\n    // use accessToken directly if it's provided\n    var accessToken = opts.access_token;\n    delete opts.access_token;\n\n    var doLogin = () => {\n      this._loginInProgress.push(1);\n      \n      // if calling Session.login() with no parameters, log in as non-anonymous user\n      if (Object.keys(opts).length == 0) opts[\"acr_values\"] = 1;\n\n      // if we have user then login only if options indicate that we have to\n      if (!accessToken && this._loginCtx) {\n        var useCurrent = true;\n        if (opts[\"prompt\"] || opts[\"max_age\"] || opts[\"access_token\"]) useCurrent = false; // TODO Check max_age in more detail and use current if we're within the limit.\n\n        // check required login level of assurance\n        var acr_values = (opts[\"acr_values\"] != null ? opts[\"acr_values\"]+\"\" : \"\").split(/\\s+/);\n        var identity = this.getIdentity();\n        if (acr_values.every(v => Number(v) > identity.loginLevelOfAssurance)) useCurrent = false; // all acceptable login levels of assurance, that are requested, are greater than current one => do the login\n\n        // check current token expiration\n        if (this._authResponseExpired(this._loginCtx.authResponse)) useCurrent = false; // our token expired => do the login\n\n        // use current token if everything seems fine\n        if (useCurrent) {\n          this._loginInProgress.pop();\n          return Promise.resolve(this);\n        }\n      }\n\n      // login using implicit flow\n      var authResponse = accessToken ? { id_token: accessToken } : null;\n      var state;\n      var nonce = (accessToken || \"nonce\" in opts ? opts[\"nonce\"] : this.nonce);\n\n      // NOTE Clicking a button, which launches this login method, can result in\n      // at most 1 Promise resolution. If 2 or more Promises are chained, mobile\n      // devices such as iPhone 4 will block popup opening. That's why this._optionsMergedPromise\n      // is wrapped via PromiseUtil which then allows us here to call our \"then\" function immediately\n      // if the this._optionsMergedPromise has already been resolved.\n      // TODO Maybe reimplement by using some sort of ImmediatePromiseWrapper which in case of .then(fn)\n      // will invoke the fn immediately. Note that Promise chaining must be somehow resolved which is\n      // not trivial.\n      var authResponsePromise = Promise.resolve(authResponse || PromiseUtil.immediateThen(this._optionsMergedPromise, () => {\n        // handle uuOS8 token - we need to obtain standard OIDC id_token and start OIDC session (set session cookie) - we'll\n        // do this by exchanging tokens via non-standard endpoint for uuOS8\n        if (os8Token) {\n          nonce = null;\n          var os8Auth = new Os8Auth({\n            serverUri: this.serverUri,\n            clientId: this.clientId,\n            redirectUri: this.implicitFlowRedirectUri\n          });\n          return os8Auth.grantExchangeToken({\n            subject_token: os8Token\n          });\n        }\n\n        // authenticate using implicit flow\n        opts.nonce = nonce;\n        opts.state = state = Math.random().toString(32).substr(2);\n        return ImplicitFlow.login({\n          serverUri: this.serverUri,\n          clientId: this.clientId,\n          redirectUri: this.implicitFlowRedirectUri,\n          loginParams: opts\n        });\n      }, (e) => Promise.reject(e)));\n      return authResponsePromise.then((authResponse) => {\n        // ImplicitFlow response validation: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthResponseValidation\n        // 1. process only recognized fields in response (id_token, expires_in, ...)\n        // 2. validate implicit flow callback response (\"state\")\n        // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation\n        //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n        //     ii. validate signature\n        //    iii. validate nonce\n        // 4. validate access_token\n\n        // 2.i. validate state\n        if (state && authResponse.state !== state) throw new Error(\"Invalid 'state' in received token. Expected \" + state + \" but got \" + authResponse.state + \". Token: \" + JSON.stringify(authResponse));\n\n        // 2.ii. validate expiration\n        if (this._authResponseExpired(authResponse)) throw new Error(\"Token expired \" + JSON.stringify(authResponse));\n\n        // 3. validate id_token with nonce\n        return this._validateIdToken(authResponse.id_token, nonce).then(claims => {\n          if (updateSessionWithLoginResult !== false) {\n            this._loginCtx = new SessionContext(opts, authResponse, claims);\n            this._runListeners();\n          }\n          return this;\n        });\n      }).then(r => {\n        this._loginInProgress.pop();\n        return r;\n      }, e => {\n        this._loginInProgress.pop();\n        return Promise.reject(e);\n      });\n    };\n\n    // wait for session restoring in case that this instance of the session is the \"main\" session\n    return this === Session.currentSession && !accessToken && !os8Token && Object.keys(opts).length === 0 ? PromiseUtil.immediateThen(Session.initPromise, doLogin) : doLogin();\n  }\n\n  /**\n   * @return Promise resolved after the user gets logged out.\n   * @method UuOidc.Session#logout\n   */\n  logout() {\n    if (!this._loginCtx) return Promise.resolve();\n\n    // TODO Logout using end_session_endpoint when it's implemented on server-side.\n    // logout using uuOidc-specific logout endpoint for now\n    return this._optionsMergedPromise.then(() => {\n      return new Promise((resolve, reject) => {\n        var oidcServerUri = this.serverUri;\n        var logoutCallbackUri = this.implicitFlowRedirectUri;\n        var logoutUrl = oidcServerUri + \"/logout?redirect_uri=\" + encodeURIComponent(logoutCallbackUri);\n        new IframeComponent({\n          url: logoutUrl,\n          onResult: (result) => {\n            // assume that the user is now logged out (regardless of result)\n            delete this._loginCtx;\n            this._runListeners();\n            resolve();\n          }\n        }).render();\n      });\n    });\n  }\n\n  /**\n   * Returns token and its type for calling commands. Returned object contains following fields:\n   * \n   * * tokenType - the type of the token, such as \"Bearer\",\n   * * token - the token itself.\n   * \n   * If the user is not logged in, null is returned.\n   * \n   * @param {(string|UuApp.Uri.Uri)} callUri (optional) Command URI that is going to be called with the token.\n   * @return Object containing token and its type, or null if user is not logged in.\n   * @method UuOidc.Session#getCallToken\n   */\n  getCallToken(callUri) {\n    var authResponse = (this._loginCtx || {}).authResponse;\n    if (!authResponse) return null;\n    var result = {\n      tokenType: authResponse.token_type || null,\n      token: authResponse.id_token || null\n    };\n    return result;\n  }\n\n  _authResponseExpired(authResponse) {\n    var now = new Date().getTime() / 1000;\n    var leeway = 60;\n    var expired = false;\n    if (!authResponse.issued_at) authResponse.issued_at = now;\n    if (authResponse.expires_at) expired = expired || (authResponse.expires_at < now - leeway);\n    if (authResponse.expires_in && authResponse.issued_at) expired = expired || (Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway);\n    return expired;\n  }\n\n  /**\n   * @return {Promise<Object>} Promise resolved to JWT claims or rejected with validation error.\n   */\n  _validateIdToken(token, nonce) {\n    // 3. validate id_token => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation\n    //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n    //         1. -Decrypt JWE - not supported.\n    //         2. +REQUIRED validate 'iss'\n    //         3. +REQUIRED validate 'aud'\n    //         4. -SHOULD validate multiple 'aud' vs. 'azp'\n    //         5. -SHOULD validate 'azp'\n    //         6. -REQUIRED <applicable only for token_endpoint, not for implicit flow>\n    //         7. -SHOULD validate 'alg' in header vs. 'alg' sent during client registration\n    //         8. -REQUIRED <for MAC-based algos> - not supported (we use RSA)\n    //         9. +REQUIRED current time < 'exp'\n    //        10. +CAN check 'iat'\n    //        11. +REQUIRED (for implicit flow) validate nonce\n    //        12. -SHOULD check if 'acr' is appropriate\n    //        13. -SHOULD check if 'auth_time' was requested.\n    //     ii. validate signature\n    //    iii. validate nonce\n\n    return this._optionsMergedPromise.then(() => {\n      return Discovery.getMetadata(this.serverUri).then(metadata => {\n        var verifyOptions = {\n          // NOTE IE11 doesn't have RS512 (but it has \"RS256\" and \"RS384\").\n          alg: [\"RS256\"], // 3.i.7. (we'll allow only RSA algorithms for signature verification)\n          iss: [metadata.issuer], // 3.i.2.\n          // aud: this.clientId, // 3.i.3. TODO We don't have the proper value.\n          // 3.i.9. - 'exp' is checked automatically if present in JWT claims (as well as 'iat', 'nbf') \n          gracePeriod: 300\n        };\n        return Jwt.decode(token, verifyOptions, (jwtHeader) => { // 3.ii.\n          if (!jwtHeader.alg || !jwtHeader.alg.match(/^RS\\d+$/)) throw new Error(\"Invalid token. Only RSA signature is supported, but token uses algorithm '\" + jwtHeader.alg + \"'. Token: \" + token);\n          var keyType = \"RSA\";\n\n          // check algorithm in token (whether it's really supported by the server)\n          var supportedAlgs = metadata.id_token_signing_alg_values_supported || [];\n          if (supportedAlgs.indexOf(jwtHeader.alg) == -1) throw new Error(\"Invalid token. Token was signed using algorithm '\" + jwtHeader.alg + \"' but the OIDC server '\" + this.serverUri + \"' supports only \" + JSON.stringify(supportedAlgs) + \". Token: \" + token);\n\n          // pick the key from JWK Set\n          var jwks = new Jwks({ serverUri: this.serverUri });\n          return jwks.getKey(jwtHeader.kid, keyType).catch(e => {\n            throw new Error(\"Invalid token. Unable to match key from JWT header to list of keys used by OpenID Connect server \" + this.serverUri + \". Token: \" + token, e);\n          });\n        }).then(claims => {\n          // 3.i.11., 3.iii. validate nonce\n          if (nonce && claims.nonce !== nonce) throw new InvalidTokenError(\"Invalid nonce in ID token claims. Expected \" + nonce + \" but got \" + claims.nonce);\n          return claims;\n        });\n      });\n    });\n  }\n}\n\nfunction toFullUrl(path) {\n  var a = document.createElement(\"a\");\n  a.href = path;\n  return a.href.toString(); // browser-normalized URL (removed \"../\" sequences, ...)\n}\n\n/**\n * Current session.\n * \n * @name UuOidc.Session.currentSession\n * @type UuOidc.Session\n */\nvar currentSession;\nvar allowAutoInitSession = true;\nObject.defineProperty(Session, \"currentSession\", {\n  get: function () {\n    if (allowAutoInitSession && !currentSession) {\n      currentSession = new Session(Util.Config); // TODO As it is now, accessing Session.currentSession prior to invoking Config.init will use defaults-only (for whole page duration).\n      currentSession.initComplete = false;\n      currentSession.initPromise = Session.initPromise;\n    }\n    return currentSession;\n  },\n  set: function (value) {\n    allowAutoInitSession = false;\n    currentSession = value;\n  }\n});\n\nvar finalizeInit;\n/**\n * Promise resolved after session initialization (restoring state) finishes.\n * \n * @type {Promise<UuOidc.Session>}\n * @name UuOidc.Session.initPromise \n */\n/**\n * Promise resolved after session initialization (restoring state) finishes.\n * Note that this field is available only on a session instance that is\n * created automatically during page load.\n * \n * @type {Promise<UuOidc.Session>}\n * @name UuOidc.Session#initPromise \n */\nSession.initPromise = PromiseUtil.wrapForImmediateThen(new Promise((resolve, reject) => {\n  finalizeInit = (isOk, result) => {\n    Session.initComplete = true;\n    Session.currentSession.initComplete = true;\n    if (!isOk) console.log(\"Session initialization failed:\", result);\n    resolve(Session.currentSession); // always resolve as success even if checking session state failed\n    return Session.initPromise;\n  };\n}));\n\n/**\n * Whether the session initialization performed during page load has already completed.\n * \n * @type {boolean}\n * @name UuOidc.Session.initComplete\n */\n/**\n * Whether the session initialization performed during page load has already completed.\n * Note that this field is available only on a session instance that is\n * created automatically during page load.\n * \n * @type {boolean}\n * @name UuOidc.Session#initComplete\n */\nSession.initComplete = false;\n\n\nfunction tryAutoLogin() {\n  if (Session.currentSession.isAuthenticated() || Session.currentSession._loginInProgress.length > 0) return;\n\n  // if there's access_token parameter in current URL, consider it as the id_token of the user\n  var id_token;\n  location.search.replace(/[?&]access_token=([^&#]*)/, function (m, g) {\n    id_token = decodeURIComponent(g.replace(/\\+/g, \" \"));\n  });\n  if (id_token) {\n    return Session.currentSession._login({\n      access_token: id_token,\n      nonce: null\n    });\n  }\n\n  // TODO Maybe we should use localStorage/sessionStorage too so that navigating between pages won't unnecessarily trigger\n  // re-login every time.\n\n  // try to login with no user interaction\n  return Session.currentSession._login({\n    prompt: \"none\", // no user interaction\n    acr_values: \"1\" // non-anonymous user\n  }).catch(e => {\n    if (e && typeof e == \"object\" && typeof e[\"error_description\"] == \"string\" && e[\"error_description\"].match(/interaction/i) && e[\"error_description\"].match(/required/i)) return; // everything is fine, we just aren't logged in\n    throw e; // some other error happenned\n  });\n}\n\n// try to login without prompting user (only for browser environment)\nvar isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\")();\nif (isBrowser) {\n  // wait until DOM is ready because we need BODY element to be present due to how implicit flow works\n  Dom.domReady.then(() => {\n    return Promise.resolve(tryAutoLogin()); // ASAP login, possibly from URL parameter\n  }).then(finalizeInit.bind(null, true), finalizeInit.bind(null, false));\n} else {\n  finalizeInit(true);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./Session.js","import Discovery from \"../discovery/Discovery.js\";\nimport PromiseUtil from \"../util/PromiseUtil.js\";\nimport PopupComponent from \"../ui/PopupComponent.js\";\nimport IframeComponent from \"../ui/IframeComponent.js\";\n\nvar ImplicitFlow = {\n  /**\n   * @param options.serverUri\n   * @param options.clientId\n   * @param options.redirectUri\n   * @param options.loginVisualComponent\n   * @param options.loginParams\n   */\n  login: function (options) {\n    var opts = options || {};\n\n    // check that required data is available\n    var serverUri = opts.serverUri;\n    if (!serverUri) throw new Error(\"ImplicitFlow.login requires option 'serverUri'.\");\n    var clientId = opts.clientId;\n    if (!clientId) throw new Error(\"ImplicitFlow.login requires option 'clientId'.\");\n    var redirectUri = opts.redirectUri;\n    if (!redirectUri) throw new Error(\"ImplicitFlow.login requires option 'redirectUri'.\");\n\n    // NOTE Using PromiseUtil.immediateThen which will run our \"then\" callback immediately if\n    // the Discovery.getMetadata is already resolved. The idea is that this login could have\n    // been triggered from \"click\" event and we need to open popup window within this event's\n    // lifetime or within single Promise (but not Promise chain because that doesn't work on\n    // iPhones).\n    return PromiseUtil.immediateThen(Discovery.getMetadata(serverUri), (oidcMetadata) => {\n      // prepare login URL\n      var loginParams = Object.assign({ scope: \"openid\" }, opts.loginParams, {\n        response_type: \"id_token token\",\n        client_id: clientId,\n        redirect_uri: redirectUri\n      });\n      var loginParamsParts = [];\n      for (var k in loginParams) {\n        var v = loginParams[k];\n        if (v == null) continue;\n        loginParamsParts.push(encodeURIComponent(k) + \"=\" + encodeURIComponent(v + \"\"));\n      }\n      var loginUrl = oidcMetadata.authorization_endpoint + \"?\" + loginParamsParts.join(\"&\");\n\n      // display visual component for logging in (popup window)\n      var LoginVisualComponent = opts.loginVisualComponent || (loginParams.prompt != \"none\" ? PopupComponent : IframeComponent);\n      return new Promise(function (resolve, reject) {\n        new LoginVisualComponent({\n          url: loginUrl,\n          onResult: function (aLoginResult) {\n            var authResponse = ImplicitFlow.getAuthResponseFromCallback(aLoginResult);\n            if (authResponse === false) return reject(new Error(\"User refused to sign in or the operation didn't complete successfully, e.g. due to popup blocking.\"));\n\n            // resolve the promise successfully with the token (iff there's no \"error\" field)\n            if (authResponse.error) reject(authResponse);\n            else resolve(authResponse);\n          }\n        }).render();\n      });\n    }, (e) => {\n      return Promise.reject(e);\n    });\n  },\n\n  /**\n   * \n   * @param {*} aLoginCallbackResult \n   * @return One of: \n   * * false - user refused to log in (or popups are blocked)\n   * * object with \"error\" field set - an error\n   * * object - the OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...\n   */\n  getAuthResponseFromCallback(aLoginCallbackResult) {\n    if (aLoginCallbackResult === false) return aLoginCallbackResult;\n\n    // extract login token\n    // example of successful aLoginCallbackResult: \"...#access_token=UUOIDCAT-27a13a6e626a40c49e036cbab55f3e27&id_token=eyJ0eXAiOi...&token_type=Bearer&expires_in=7200&scope=openid\" \n    // example of error aLoginCallbackResult:      \"...#error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR\"\n    var authResponse = {};\n    aLoginCallbackResult.replace(/^[^#]*#?/, \"\").split(/&/).forEach(it => { \n      var eqlIdx = it.indexOf(\"=\");\n      var key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\\+/g, \" \"));\n      var value = decodeURIComponent((eqlIdx == -1 ? \"\" : it.substr(eqlIdx+1)).replace(/\\+/g, \" \"));\n      authResponse[key] = value;\n    });\n    return authResponse;\n  }\n};\n\n\nexport default ImplicitFlow;\n\n\n// WEBPACK FOOTER //\n// ./flow/ImplicitFlow.js","// login callback handling\nvar VC_CALLBACK_FN_NAME = \"uuOidcCallbackFn\"; // !!! Must be in sync with the one in callbacks/oidc-callback.html.\n\n// make sure that callback works correctly even if multiple invocations using visual component below were\n// done (e.g. user clicked 2 different buttons for command invocations which each opened a login popup\n// and are now displayed both)\nif (typeof window != \"undefined\" && !window[VC_CALLBACK_FN_NAME]) {\n  window[VC_CALLBACK_FN_NAME] = function (aLoginResult, aSourceWindow) {\n    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;\n    // received callback from a popup => find out which component is using the source window and notify it\n    for (var i = 0; i < loginWindows.length; ++i) {\n      var p = loginWindows[i];\n      if (p.state.loginWindow == aSourceWindow) {\n        p.component.finalize(aLoginResult);\n        return;\n      } \n    }\n    console.warn(\"Received unexpected callback from window\", aSourceWindow, \"Passed result was:\", aLoginResult, \"Ignoring the callback.\");\n  };\n  window[VC_CALLBACK_FN_NAME].loginWindows = [];\n}\n\nexport default {\n  registerForCallback(component, state) {\n    window[VC_CALLBACK_FN_NAME].loginWindows.push({component: component, state: state});\n  },\n\n  unregisterForCallback(component) {\n    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;\n    for (var i=0; i<loginWindows.length; ++i) { // remove self from opened loginWindows\n      if (loginWindows[i].component === component) {\n        loginWindows.splice(i, 1);\n        break;\n      }\n    }\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./ui/CallbackHandler.js","var Base64Url = {\n  /**\n   * @param txtAscii Ascii string to encode (each character is in range 0-255).\n   * @return {string} Provided string encoded to Base64Url encoding.\n   */\n  encodeAscii: (txtAscii) => {\n    if (!txtAscii) return txtAscii;\n    return btoa(txtAscii).replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  },\n  /**\n   * @param txtUtf8 UTF-8 string to encode.\n   * @return {string} Provided string encoded to Base64Url encoding.\n   */\n  encode: (txtUtf8) => {\n    if (!txtUtf8) return txtUtf8;\n    return Base64Url.encodeAscii(unescape(encodeURIComponent(txtUtf8)));\n  },\n  /**\n   * @return {string} Base64Url decoded to an Ascii string (each character is in range 0-255).\n   */\n  decodeToAscii: (base64Url) => {\n    if (!base64Url) return null;\n    var base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    return atob(base64);\n  },\n  /**\n   * @return {string} Base64Url decoded to a UTF-8 string.\n   */\n  decode: (base64Url) => {\n    var ascii = Base64Url.decodeToAscii(base64Url);\n    return (ascii != null ? decodeURIComponent(escape(ascii)) : null);\n  }\n};\nexport default Base64Url;\n\n\n// WEBPACK FOOTER //\n// ./util/Base64Url.js","// helper for invoking Ajax requests and returning Promise\nfunction xhrJson(method, url, body, extraSettingFn) {\n  return new Promise(function (resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(method, url, true);\n    xhr.withCredentials = true;\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n    xhr.onreadystatechange = function (e) {\n      if (xhr.readyState == 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          try {\n            var json = JSON.parse(xhr.responseText);\n            resolve(json);\n          } catch (err) {\n            reject(err);\n          }\n        } else {\n          reject(new Error(\"Server responded with status \" + xhr.status)); // TODO Better error.\n        }\n      }\n    };\n    xhr.withCredentials = true;\n    if (extraSettingFn) extraSettingFn(xhr);\n    xhr.send(body);\n  });\n}\n\nexport default {\n  get: function () {\n    return xhrJson.bind(this, \"GET\").apply(this, Array.prototype.slice.call(arguments));\n  },\n  post: function () {\n    return xhrJson.bind(this, \"POST\").apply(this, Array.prototype.slice.call(arguments));\n  }\n};\n\n\n// WEBPACK FOOTER //\n// ./util/HttpClient.js","export default {\n  toSnakeCase(aText) {\n    return (aText || \"\").replace(/[A-Z]/g, m => \"_\" + m.toLowerCase());\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./util/StringUtil.js","module.exports = __WEBPACK_EXTERNAL_MODULE_12__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"amd\":\"module\",\"commonjs\":\"module\",\"commonjs2\":\"module\",\"root\":\"undefined\"}\n// module id = 12\n// module chunks = 0","// NOTE If changed, update also JSDoc in Session.js.\nexport default {\n    serverUri: \"https://oidc.plus4u.net/uu-oidcg01-main/0-0\",\n    sessionCheckInterval: 60\n};\n\n\n// WEBPACK FOOTER //\n// ./Defaults.js","export default class SessionContext {\n  constructor(loginOptions, authResponse, claims) {\n    this.loginOptions = loginOptions;\n    this.authResponse = authResponse;\n    this.claims = claims;\n\n    this.getClaims = () => claims;\n\n    var identity;\n    this.getIdentity = () => {\n      if (identity) return identity;\n      return (identity = {\n        id: claims[\"sub\"],\n        name: claims[\"name\"],\n        email: claims[\"email\"],\n        uuIdentity: claims[\"uu_identity\"],\n        levelOfAssurance: Number(claims[\"loa\"]),\n        loginLevelOfAssurance: Number(claims[\"acr\"])\n      });\n    };\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./SessionContext.js","import * as UuApp from \"uu_appg01_core\";\nimport Session from \"./Session.js\";\nimport StringUtil from \"./util/StringUtil.js\";\n\n // NOTE Interceptor expects gateway present, i.e. it must be added after UriHandler.\n\n/**\n * @class UuOidc.SessionHandler\n * @classdesc\n * Interceptor for Client which authenticates command calls by using user from\n * current / specified session. Additionally, if server responds with authentication challenge\n * (e.g. user needs to login with more secure realm or re-login due to inactivity), the interceptor\n * performs session login and calls the command again.\n * \n * Interceptor is skipped if there's request header \"authorization\" set for the command call, even\n * if the header value is null.\n * \n * **Configuration**\n * \n * Interceptor recognizes following options for command call:\n * \n * * uuoidc.loginParameters - object with extra parameters for login. See {@link UuOidc.Session#login} for supported values.\n * * session - the session to use for authentication. By default {@link UuOidc.Session.currentSession Session.currentSession} is used.\n * \n * **Error handling**\n * \n * Interceptor might cause the command call to fail with these errors (in addition to standard Client ones):\n * \n * * UuApp.Error.AbortError - in case that the command requires user to be logged in but the user refused to do so.\n */\nexport default function SessionHandler(request, options, nextInterceptorFn) {\n  var hasCustomAuthn = \"authorization\" in request.headers;\n  if (hasCustomAuthn) return nextInterceptorFn(request, options);\n\n  var session = options.session || Session.currentSession;\n  var loginParams = options[\"uuoidc.loginParameters\"];\n  if (loginParams) loginParams = Object.keys(loginParams).reduce((r, k) => (r[StringUtil.toSnakeCase(k)] = loginParams[k], r), {});\n  var count = 0;\n\n  function runWith(extraLoginParams) {\n    if (++count > 5) throw new UuApp.Error.AbortError(\"Command invocation stopped because user was not able to fulfill login requirements for the command within \" + count + \" attempts.\");\n\n    // depending on presence of login parameters, either perform the log-in or just use the current user (even if not logged in)\n    var usedLoginParams = Object.assign({}, loginParams, extraLoginParams);\n    return (Object.keys(usedLoginParams).length > 0 ? session._login(usedLoginParams, true) : Promise.resolve(session)).catch(e => {\n      // if user login failed then abort or throw\n      if (e === false) throw new UuApp.Error.AbortError(\"Command invocation stopped because user refused to log in.\");\n      throw new UuApp.Error.Error(\"Command invocation stopped because of a login error.\", e);\n    }).then(function (session) {\n      var isAuthenticated = session.isAuthenticated();\n      if (isAuthenticated) {\n        var baseUri = request.uri.baseUri;\n        return Promise.resolve(session.getCallToken(baseUri.toString())).then(callToken => ({ isAuthenticated: isAuthenticated, callToken: callToken }));\n      }\n      return { isAuthenticated: isAuthenticated, callToken: null };\n    }).then(data => {\n      var isAuthenticated = data.isAuthenticated;\n      var callToken = data.callToken;\n      var authToken = (callToken ? callToken.token : null);\n      if (authToken) request.headers[\"authorization\"] = [callToken.tokenType || \"Bearer\", authToken].join(\" \");\n      return nextInterceptorFn(request, options).catch(response => {\n        // check for special response values in WWW-Authenticate response header which indicates\n        // that we shall run login procedure with additional parameters and then try again the same command\n        var wwwAuthenticate = response.headers(\"www-authenticate\");\n        if (wwwAuthenticate) {\n          var valueMap = {};\n          wwwAuthenticate.replace(/^\\S+\\s+/, \"\").split(/,/).map(it => it.trim()).forEach(it => { // remove \"Bearer \"\n            var idx = it.indexOf(\"=\");\n            var key = decodeUriWithPlus(idx == -1 ? it : it.substr(0, idx));\n            var value = decodeUriWithPlus(idx == -1 ? \"\" : it.substr(idx + 1));\n            valueMap[key] = decodeUriWithPlus(value);\n          });\n\n          var relevantValues = Object.keys(valueMap).filter(key => key.match(/^(max_age|acr_values|prompt|scope)$/)).reduce((r,k) => (r[k]=valueMap[k],r), {});\n          // if there's any of relevant keys in the WWW-Authenticate response header then\n          // re-run the whole OIDC Handler with those values sent to login\n          if (Object.keys(relevantValues).length > 0) return runWith(relevantValues);\n\n          // OI if we weren't logged in at the time of invocation and there's wwwAuthenticate then re-run also\n          if (!isAuthenticated) return runWith({ acr_values: \"1\" }); // require non-anonymous\n        }\n        return Promise.reject(response);\n      });\n    });\n  }\n  return runWith(null);\n}\n\nfunction decodeUriWithPlus(txt) {\n  return decodeURIComponent(txt.replace(/\\+/g, \" \"));\n}\n\n\n// WEBPACK FOOTER //\n// ./SessionHandler.js","import Session from \"./Session.js\";\nimport SessionHandler from \"./SessionHandler.js\";\n\n// make UuOidc always present in global variable so that there're no issues\n// with detecting it (even during load via SystemJS)\nif (typeof window !== \"undefined\") window.UuOidc = { Session, SessionHandler };\n\nexport { Session, SessionHandler };\n\n\n// WEBPACK FOOTER //\n// ./index.js","import Discovery from \"../discovery/Discovery.js\";\nimport HttpClient from \"../util/HttpClient.js\";\n\nvar jwkSetCache = {};\nvar cacheBustCounter = 0;\n\n// JWK - JSON Web Key https://tools.ietf.org/html/rfc7517\n\nexport default class {\n  constructor (options) {\n    if (!options || !options.serverUri) throw new Error(\"Jwks must be initialized with options containing serverUri.\");\n    this.options = options;\n  }\n\n  getKey(keyId, keyType) {\n    return this._getKey(keyId, keyType, false);\n  }\n\n  _getKey(keyId, keyType, forceKeySetReload) {\n    // load set of OIDC server JSON Web Key-s\n    return Discovery.getMetadata(this.options.serverUri).then(metadata => {\n      // TODO Use also localStorage cache as optimization.\n      var jwkSetMeta = jwkSetCache[metadata.jwks_uri];\n      if (!jwkSetMeta || forceKeySetReload) {\n        var url = metadata.jwks_uri;\n        if (forceKeySetReload) url = url.replace(/(\\?.*)?$/, m => \"?cachebust=\" + Date.now().toString(36) + \"_\" + (cacheBustCounter++).toString(36) + (m ? \"&\" + m.substr(1) : \"\"));\n        jwkSetMeta = jwkSetCache[metadata.jwks_uri] = HttpClient.get(url).then(value => ({ jwkSet: value, url: url }));\n      }\n      return jwkSetMeta;\n    }).then(jwkSetMeta => {\n      var jwkSet = jwkSetMeta.jwkSet;\n      // choose key by id & type\n      var keys = jwkSet.keys;\n      if (keyId) keys = keys.filter(it => it.kid === keyId); // if specific key ID is used then use it (note that there might still be multiple of keys in the result)\n      if (keyType) keys = keys.filter(it => it.kty === keyType);\n      // keys = keys.filter(it => it.use === \"sig\" || (it.key_ops||[]).indexOf(\"verify\") !== -1 || (!it.key_ops && !it.use)); // consider only keys for verification / signing (or unspecified)\n      if (keys.length != 1) {\n        // try force-reloading of the JWK set because the URL from which we downloaded it might have been previously cached by browser\n        // and the server might have changed keys (e.g. due to restart or just because it changes them from time to time)\n        if (!forceKeySetReload) return this._getKey(keyId, keyType, true);\n        throw new Error(\"There's \" + keys.length + \" JSON Web Key(s) in JWK Set with kid='\" + keyId + \"' kty='\" + keyType + \"'. There must be exactly 1. JWK Set has been downloaded from: \" + jwkSetMeta.url);\n      }\n      return keys[0];\n    });\n  } \n}\n\n\n// WEBPACK FOOTER //\n// ./jwks/Jwks.js","import Base64Url from \"../util/Base64Url.js\";\nimport InvalidTokenError from \"./InvalidTokenError.js\";\nimport JwtVerifierWebCrypto from \"./JwtVerifierWebCrypto.js\";\nimport JwtVerifierJsrsasign from \"./JwtVerifierJsrsasign.js\";\n\n// JWT - JSON Web Token https://tools.ietf.org/html/rfc7519\n//     - JSON (containing claims) encoded in a JWS / JWE structure\n// JWS - JSON Web Signature https://tools.ietf.org/html/rfc7515\n// JWE - JSON Web Encryption https://tools.ietf.org/html/rfc7516\n\n// NOTE WebCrypto API works only via https://* or http://localhost (rare exception), but not on http://localhost.plus4u.net\n// so we're falling back to on-demand loaded jsrsasign library (which will be therefore used mostly during development,\n// but not on production; it's ~90kB of minified code).\nvar hasWebCrypto = (typeof crypto != \"undefined\" && crypto.subtle && crypto.subtle.importKey);\nvar useWebCrypto = hasWebCrypto && (typeof location == \"undefined\" || location.protocol == \"https:\");\nvar verifier = (useWebCrypto ? JwtVerifierWebCrypto : JwtVerifierJsrsasign);\n\nvar DEFAULT_ALG = \"RS256\";\nexport default {\n  /**\n   * \n   */\n  decode: (token, verifyOpts, getKeyFn) => {\n    var tokenParts;\n    var header;\n    return Promise.resolve().then(() => {\n      if (typeof token != \"string\") throw new Error(\"Invalid JSON Web Token - it must be a string (result of JWS / JWE Compact Serialization as per RFC7515 / RFC7516).\");\n      tokenParts = token.split(\".\");\n      if (tokenParts.length != 3) throw new Error(\"Unsupported JSON Web Token - the token doesn't consist of header+body+signature (only JWS Compact Serialization is supported - RFC7515, section-3). Token: \" + token);\n\n      // parse header\n      var headerB64U = tokenParts[0];\n      var headerStr = Base64Url.decode(headerB64U);\n      header = JSON.parse(headerStr);\n      if (header.typ != \"JWT\") throw new Error(\"Invalid JSON Web Token - the header 'typ' field is not set to 'JWT'. Token: \" + token);\n\n      // get key\n      return getKeyFn(header);\n    }).then(key => {\n      // NOTE Check the whole importKey call if adding support for other key types.\n      if (!key || key.kty != \"RSA\") throw new Error(\"Unsupported key type. Only RSA keys are supported for JSON Web Token signature verification. Key: \" + JSON.stringify(key));\n      // always verify algorithm against the one is JOSE header\n      var alg = key.alg || DEFAULT_ALG;\n      if (alg !== header.alg) throw new InvalidTokenError(\"Invalid JSON Web Token or wrong verification key - algorithms don't match. Token uses '\" + header.alg + \"', verification key uses '\" + key.alg + \"' (with default of '\" + DEFAULT_ALG + \"'). Token: \" + token + \" Key: \" + JSON.stringify(key));\n\n      return verifier.verify(key, alg, verifyOpts, header, tokenParts, token);\n    }).then(valid => {\n      if (!valid) throw new InvalidTokenError(\"Invalid JSON Web Token: \" + token);\n      var bodyStr = Base64Url.decode(tokenParts[1]);\n      var body = JSON.parse(bodyStr);\n      return body;\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./jwt/Jwt.js","import mod from \"module\";\n\nvar scriptUri = ((mod ? mod.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName(\"script\"), -1)[0] || {}).src) || \"\").toString();\nvar jsrsasign = undefined;\nvar Verifier = {\n  verify: function (key, alg, verifyOpts, header, tokenParts, token) {\n    return Promise.resolve().then(() => {\n      // load jsrsasign library on 1st verification\n      if (jsrsasign === undefined) {\n        var continueFn = Verifier.verify.bind(this, key, alg, verifyOpts, header, tokenParts, token);\n        var isMin = scriptUri.indexOf(\".min.\") != -1;\n        var baseUrl = scriptUri.replace(/^(.*\\/).*/, \"$1\");\n        var url = baseUrl + \"jsrsasign\" + (isMin ? \".min\" : \"\") + \".js\";\n        var loadPromise;\n        if (typeof System != \"undefined\") loadPromise = System.import(url);\n        else loadPromise = new Promise((resolve, reject) => {\n          var script = document.createElement(\"script\");\n          script.onload = () => { resolve(window[\"Jsrsasign\"]); };\n          script.onerror = (e) => { reject(e); };\n          script.src = url;\n          document.head.appendChild(script);\n        });\n        return loadPromise.then((obj) => {\n          jsrsasign = obj || null;\n          return continueFn();\n        }, (e) => {\n          console.error(e);\n          jsrsasign = null;\n          return continueFn();\n        });\n      }\n      if (!jsrsasign) throw new Error(\"Unable to verify token because jsrsasign library failed to load.\");\n\n      // var exampleKey = {\"kty\":\"RSA\",\"e\":\"AQAB\",\"n\":\"yXxJt2xevNsgGGGFfX5e22Jvy0_Eopgkumz7mJ7ScWlPfsMsAi8BZsF7nbDjA3T3v2vy2_-DaLDg-z-BjRwQIPL1LRzQGeDDSVmPcZtbexqkpjouxZ6-abpefSAFX5cA8NJ5h4JknFJWAsxxKEw4Ogy6XFd_BEaDmyXlLcV65Bs\",\"alg\":\"RS256\",\"kid\":\"rJZx5vzX1FOt_Nt8sB8jUA\",\"use\":\"sig\"};\n      // var pem = KEYUTIL.getPEM(jsrsasign.KEYUTIL.getKey(exampleKey));\n      //   =>\n      // -----BEGIN PUBLIC KEY-----\n      // MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDJfEm3bF682yAYYYV9fl7bYm/L\n      // T8SimCS6bPuYntJxaU9+wywCLwFmwXudsOMDdPe/a/Lb/4NosOD7P4GNHBAg8vUt\n      // HNAZ4MNJWY9xm1t7GqSmOi7Fnr5pul59IAVflwDw0nmHgmScUlYCzHEoTDg6DLpc\n      // V38ERoObJeUtxXrkGwIDAQAB\n      // -----END PUBLIC KEY-----\n\n      // do the verification\n      var keyInst = jsrsasign.KEYUTIL.getKey(key);\n      var result = jsrsasign.jws.JWS.verifyJWT(token, keyInst, verifyOpts); // see lib/jsrsasign-.../jws-3.3.js\n      return result || Promise.reject(new Error(\"Token is not valid. Token: \" + token));\n    });\n  }\n}\n\nmodule.exports = Verifier;\n\n\n// WEBPACK FOOTER //\n// ./jwt/JwtVerifierJsrsasign.js","import Base64Url from \"../util/Base64Url.js\";\nimport InvalidTokenError from \"./InvalidTokenError.js\";\n\n\nmodule.exports = {\n  verify: function (key, alg, verifyOpts, header, tokenParts, token) {\n    var webCryptoAlgorithm = {\n      name: \"RSASSA-PKCS1-v1_5\",\n      hash: { name: \"SHA-\" + alg.substr(2) }\n    };\n    // MS Edge throws error if the key contains field \"use\" => remove it\n    // https://connect.microsoft.com/IE/feedback/details/2242108/webcryptoapi-importing-jwk-with-use-field-fails\n    var usedKey = JSON.parse(JSON.stringify(key));\n    delete usedKey.use;\n    \n    return crypto.subtle.importKey(\"jwk\", usedKey, webCryptoAlgorithm, false, [\"verify\"]).then(webCryptoKey => {\n      // validate signature\n      var signatureB64U  = tokenParts[2];\n      var data = tokenParts[0] + \".\" + tokenParts[1];\n      var signatureBytes = asciiToUint8Array(Base64Url.decodeToAscii(signatureB64U));\n      var dataBytes = asciiToUint8Array(data);\n      return crypto.subtle.verify(webCryptoKey.algorithm, webCryptoKey, signatureBytes, dataBytes);\n    }, (importError) => {\n      var e = new Error(`Unable to verify JSON Web Token - importing key via WebCrypto API failed.\\nKey: ${JSON.stringify(usedKey)}\\nToken: ${token}\\nError: ` + importError);\n      e.cause = importError;\n      return Promise.reject(e);\n    }).then(signatureValid => {\n      if (!signatureValid) throw new InvalidTokenError(\"Invalid JSON Web Token - signature is not valid. Token: \" + token);\n      var bodyStr = Base64Url.decode(tokenParts[1]);\n      var body = JSON.parse(bodyStr);\n      var throwError = (txt, failedClaim) => {\n        throw new InvalidTokenError(\"Invalid token: \" + txt + \"\\nFailed claim: \" + JSON.stringify(failedClaim) + \"\\nIssued by: \" + JSON.stringify(body.iss) + \"\\nVerification options: \" + JSON.stringify(verifyOpts) + \"\\nToken: \" + token);\n      }\n\n      // verify claims\n\n      // 'alg' is always checked\n      if (!verifyOpts.alg) throw new Error(\"Unable to verify JWT claim - 'alg' field must be always given for verification.\");\n      if (verifyOpts.alg.indexOf(header.alg) == -1) throwError(`Algorithm ${JSON.stringify(header.alg)} used by token is not valid - expected one of ${JSON.stringify(verifyOpts.alg)}.`, \"alg\");\n\n      // 'iss'\n      var v;\n      v = asArray(verifyOpts.iss);\n      if (v && v.indexOf(body.iss) === -1) throwError(`Issuer URI ${JSON.stringify(body.iss)} in token is not valid - expected one of ${JSON.stringify(v)}. Token was issued by different OpenID Connect server or it was forged.`, \"iss\");\n\n      // 'sub'\n      v = asArray(verifyOpts.sub);\n      if (v && v.indexOf(body.sub) === -1) throwError(`Subject ${JSON.stringify(body.sub)} in token is not valid - expected one of ${JSON.stringify(v)}.`, \"sub\");\n\n      // 'aud' - all values from verifyOpts.aud must be present in body.aud \n      v = asArray(verifyOpts.aud);\n      var bodyV = asArray(body.aud) || [];\n      if (v && bodyV.some(bv => v.indexOf(bv) == -1)) throwError(`Audience list ${JSON.stringify(bodyV)} in token is not valid - some of following values are missing: ${JSON.stringify(v)}.`, \"aud\");\n\n      // time validity: (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)\n      var now = Date.now() / 1000;\n      if (verifyOpts.verifyAt) now = verifyOpts.verifyAt;\n      var gracePeriod = verifyOpts.gracePeriod || 0;\n\n      // 'exp' - expires\n      if (typeof body.exp === \"number\" && body.exp + gracePeriod < now) throwError(`Token already expired at ${toTimeString(body.exp)}, current time is ${toTimeString(now)}.`, \"exp\");\n\n      // 'nbf' - not before\n      if (typeof body.nbf === \"number\" && now < body.nbf - gracePeriod) throwError(`Token is not yet valid - it will become valid at ${toTimeString(body.nbf)}, current time is ${toTimeString(now)}. Check that your system time is correctly set.`, \"nbf\");\n\n      // 'iat' - issued at time\n      if (typeof body.iat === \"number\" && now < body.iat - gracePeriod) throwError(`Token seems to have been issued in the future - ${toTimeString(body.iat)}, current time is ${toTimeString(now)}. Check that your system time is correctly set.`, \"iat\");\n\n      // 'jti' - JWT id\n      if (verifyOpts.jti && body.jti !== verifyOpts.jti) throwError(`Token ID ${JSON.stringify(body.jti)} not valid - expected ${JSON.stringify(verifyOpts.jti)}.`, \"jti\");\n\n      return true;\n    });\n  }\n}\n\n\nfunction asciiToUint8Array(ascii) {\n  return new Uint8Array(ascii.split(\"\").map(function (c) { return c.charCodeAt(0); }));\n}\nfunction asArray(value) {\n  if (value == null) return null;\n  if (Array.isArray(value)) return value;\n  return [value];\n}\nfunction toTimeString(seconds) {\n  return new Date(seconds*1000).toISOString().replace(/T/, \" \");\n}\n\n\n\n// WEBPACK FOOTER //\n// ./jwt/JwtVerifierWebCrypto.js","import CallbackHandler from \"./CallbackHandler.js\";\n\n/**\n * Default visual component for presenting login/logout prompt to the user. It displays the\n * URL in a popup window and waits until the user logs in / closes the window. After that\n * initAttrs.onResult(authResultUrl) is called as callback.\n * \n * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.\n * @param initAttrs.onResult The callback to call after login finishes. If the login finished\n *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.\n *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which\n *   contains the authentication response in fragment). \n */\nvar PopupComponent = function (initAttrs) {\n  var attrs = Object.assign({}, initAttrs);\n  var state = {\n    loginWindow: null,\n    closeCheckInterval: null\n  };\n\n  // add self to the list of opened loginWindows\n  CallbackHandler.registerForCallback(this, state);\n\n  this.finalize = function (result) {\n    // cleanup & do the callback\n    this.destroy();\n    if (attrs.onResult) attrs.onResult(result);\n  }.bind(this);\n\n  var closeCheck = function () {\n    if (!state.loginWindow || !state.loginWindow.closed) return;\n    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value \"false\"\n  }.bind(this);\n\n  this.render = function () {\n    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)\n    if (!state.loginWindow) {\n      var rect = { width: 599, height: 600 };\n      rect.left = (screen.availWidth - rect.width) / 2 + screen.availLeft;\n      rect.top = (screen.availHeight - rect.height) / 2 + screen.availTop;\n      state.loginWindow = window.open(attrs.url, \"_blank\", `toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=${rect.width},height=${rect.height},top=${rect.top},left=${rect.left}`);\n      if (!state.loginWindow) { // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in\n        Promise.resolve().then(() => this.finalize(false)); // finalize in async way\n      } else {\n        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);\n      }\n    }\n  };\n\n  this.destroy = function () {\n    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();\n    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);\n    this.destroy = function () {};\n    CallbackHandler.unregisterForCallback(this);\n  };\n}\n\nexport default PopupComponent;\n\n\n// WEBPACK FOOTER //\n// ./ui/PopupComponent.js","var isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\")();\nvar domReadyPromise = isBrowser ? (document.readyState === \"interactive\" || document.readyState === \"complete\" ? Promise.resolve() : new Promise((resolve) => {\n  document.addEventListener(\"DOMContentLoaded\", resolve, false);\n})) : Promise.resolve();\n\nexport default {\n  domReady: domReadyPromise\n};\n\n\n// WEBPACK FOOTER //\n// ./util/Dom.js","export default function generateUuid() {\n  // generate UUID (RFC4122 version 4 compliant) for the event ID\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n  var uuid= 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n    return v.toString(16);\n  });\n  return uuid;\n}\n\n\n// WEBPACK FOOTER //\n// ./util/Uuid.js","import IframeComponent from \"../ui/IframeComponent.js\";\nimport ImplicitFlow from \"../flow/ImplicitFlow.js\";\n\nexport default class Os8Auth {\n\n  /**\n   * @param options.serverUri\n   * @param options.clientId\n   * @param options.redirectUri\n   */\n  constructor(options) {\n    if (!options || !options.serverUri || !options.clientId || !options.redirectUri) throw new Error(\"Os8Auth must be initialized with options containing serverUri, clientId and redirectUri.\");\n    this.options = options;\n  }\n\n  /**\n   * @param parameters\n   * @param parameters.subject_token\n   */\n  grantExchangeToken(parameters) {\n    var params = parameters || {};\n    if (!params.subject_token) throw new Error(\"Os8Auth.grantExchangeToken must be called with parameter subject_token.\");\n    var urlParams = Object.assign({}, params, {\n      response_type: \"id_token token\",\n      client_id: this.options.clientId,\n      redirect_uri: this.options.redirectUri\n    });\n    var urlParamsParts = Object.keys(urlParams)\n      .filter(k => urlParams[k] != null)\n      .map(k => encodeURIComponent(k) + \"=\" + encodeURIComponent(urlParams[k] + \"\"));\n    var url = this.options.serverUri.replace(/\\/*$/, \"/\") + \"exchangeOs8Token\" + \"?\" + urlParamsParts.join(\"&\");\n\n    return new Promise(function (resolve, reject) {\n      new IframeComponent({\n        url: url,\n        onResult: function (aLoginResult) {\n          var authResponse = ImplicitFlow.getAuthResponseFromCallback(aLoginResult);\n          if (!authResponse || authResponse.error) reject(authResponse);\n          else resolve(authResponse);\n        }\n      }).render();\n    });\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./uuos8/Os8Auth.js"],"sourceRoot":""}