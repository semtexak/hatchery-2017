/*! uu_oidcg01, 2.0.2, 2017-08-08 09:21:35Z */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"), require("uu_appg01_core"));
	else if(typeof define === 'function' && define.amd)
		define("UuOidc", ["module", "uu_appg01_core"], factory);
	else if(typeof exports === 'object')
		exports["UuOidc"] = factory(require("module"), require("uu_appg01_core"));
	else
		root["UuOidc"] = factory(root["undefined"], root["UuApp"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_4__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!************************!*\
  !*** ../.tmp/index.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	var mod=__webpack_require__(/*! module */ 1);
	  var uri = ((mod ? mod.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
	  __webpack_require__.p=uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
	  module.exports = __webpack_require__(/*! __project__/index.js */ 2);

/***/ },
/* 1 */
/*!*********************************************************************************************!*\
  !*** external {"amd":"module","commonjs":"module","commonjs2":"module","root":"undefined"} ***!
  \*********************************************************************************************/
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SessionHandler = exports.Session = undefined;

	var _Session = __webpack_require__(/*! ./Session.js */ 3);

	var _Session2 = _interopRequireDefault(_Session);

	var _SessionHandler = __webpack_require__(/*! ./SessionHandler.js */ 24);

	var _SessionHandler2 = _interopRequireDefault(_SessionHandler);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// make UuOidc always present in global variable so that there're no issues
	// with detecting it (even during load via SystemJS)
	if (typeof window !== "undefined") window.UuOidc = { Session: _Session2.default, SessionHandler: _SessionHandler2.default };

	exports.Session = _Session2.default;
	exports.SessionHandler = _SessionHandler2.default;

/***/ },
/* 3 */
/*!********************!*\
  !*** ./Session.js ***!
  \********************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	var _Defaults = __webpack_require__(/*! ./Defaults.js */ 5);

	var _Defaults2 = _interopRequireDefault(_Defaults);

	var _ImplicitFlow = __webpack_require__(/*! ./flow/ImplicitFlow.js */ 6);

	var _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);

	var _SessionContext = __webpack_require__(/*! ./SessionContext.js */ 13);

	var _SessionContext2 = _interopRequireDefault(_SessionContext);

	var _Uuid = __webpack_require__(/*! ./util/Uuid.js */ 14);

	var _Uuid2 = _interopRequireDefault(_Uuid);

	var _Jwt = __webpack_require__(/*! ./jwt/Jwt.js */ 15);

	var _Jwt2 = _interopRequireDefault(_Jwt);

	var _InvalidTokenError = __webpack_require__(/*! ./jwt/InvalidTokenError.js */ 17);

	var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

	var _Jwks = __webpack_require__(/*! ./jwks/Jwks.js */ 20);

	var _Jwks2 = _interopRequireDefault(_Jwks);

	var _Discovery = __webpack_require__(/*! ./discovery/Discovery.js */ 7);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	var _Os8Auth = __webpack_require__(/*! ./uuos8/Os8Auth.js */ 21);

	var _Os8Auth2 = _interopRequireDefault(_Os8Auth);

	var _Dom = __webpack_require__(/*! ./util/Dom.js */ 22);

	var _Dom2 = _interopRequireDefault(_Dom);

	var _PromiseUtil = __webpack_require__(/*! ./util/PromiseUtil.js */ 9);

	var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

	var _StringUtil = __webpack_require__(/*! ./util/StringUtil.js */ 23);

	var _StringUtil2 = _interopRequireDefault(_StringUtil);

	var _IframeComponent = __webpack_require__(/*! ./ui/IframeComponent.js */ 12);

	var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Error = _uu_appg01_core.Error.Error;

	var Session = function () {

	  /**
	   * Creates new Session with specified options.
	   * 
	   * @class UuOidc.Session
	   * @classdesc
	   * 
	   * Session handling via OpenID Connect server.
	   * 
	   * **Configuration**
	   * 
	   * Login via OpenID Connect server **requires a special callback HTML page be present on the domain where application is running**. The callback
	   * HTML page should be copied from the contents of this library (callbacks/oidc-callback.html) to the application and URL path to it must be
	   * configured as described below - configuration parameter "uuoidc.redirectUri".
	   * 
	   * Following global configuration parameters are used for initializing {@link UuOidc.Session.currentSession Session.currentSession}:
	   * 
	   * * **uuoidc.clientId** - OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.
	   *   Default is auto-generated which means that the application will be treated as an anonymous application and therefore might not be authorized for
	   *   accessing most of user data.
	   * * **uuoidc.redirectUri** - Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application
	   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative
	   *   to document.baseURI (current URL). Default is "callbacks/oidc-callback.html".
	   * * **uuoidc.serverUri** - OpenID Connect server to perform login / logout against. Default is "https://oidc.plus4u.net/uu-oidcg01-main/0-0".
	   * * **uuoidc.sessionCheckInterval** - how often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds. Default is 60.
	   * 
	   * @param options {Object|UuApp.Util.Config} Options.
	   * @param options.serverUri OpenID Connect server to perform login / logout against.
	   * @param options.clientId OpenID Connect client ID (application ID as registered in OIDC server) that wants to know the identity of the user.
	   * @param options.redirectUri Redirect URI for OpenID Connect implicit flow. It must be on the same server as the running application
	   *   and must point to the HTML file (callbacks/oidc-callback.html) distributed with this OIDC client library. If a relative path is used, it's relative
	   *   to document.baseURI (current URL).
	   * @param options.sessionCheckInterval How often to check whether the user login state changed (e.g. logged out in another browser tab), in seconds.
	   */
	  function Session(options) {
	    var _this = this;

	    _classCallCheck(this, Session);

	    if (!options) throw new Error("Session must be initialized with proper options or UuApp.Util.Config.");
	    this._optionsMergedPromise = _PromiseUtil2.default.wrapForImmediateThen(Promise.resolve(options && typeof options.get == "function" ? options.initPromise : options).then(function (env) {
	      if (env && typeof env.get == "function") {
	        _this.serverUri = env.get("uuoidc.serverUri", false);
	        _this.clientId = env.get("uuoidc.clientId", false);
	        _this.implicitFlowRedirectUri = env.get("uuoidc.redirectUri", false);
	        _this.sessionCheckInterval = env.get("uuoidc.sessionCheckInterval", false);
	      } else if (env) {
	        _this.serverUri = env["serverUri"];
	        _this.clientId = env["clientId"];
	        _this.implicitFlowRedirectUri = env["redirectUri"];
	        _this.sessionCheckInterval = env["uuoidc.sessionCheckInterval"];
	      }
	      if (_this.serverUri == null) _this.serverUri = _Defaults2.default.serverUri;
	      if (_this.clientId == null) _this.clientId = "uu-oidc:unregistered-client:" + (0, _Uuid2.default)();
	      if (_this.sessionCheckInterval == null) _this.sessionCheckInterval = _Defaults2.default.sessionCheckInterval;
	      if (!_this.implicitFlowRedirectUri) {
	        // console.warn("Session login will work only with directly provided access token because no callback URL for OpenID Connect server was specified in" + 
	        //   " the configuration. To support login via popup, specify redirectUri when creating session, or initialize UuApp.Util.Config with \"uuoidc.redirectUri\" option.");
	        _this.implicitFlowRedirectUri = "callbacks/oidc-callback.html";
	      }
	      // if redirect URI is relative then absolutize it (relative to current document.baseURI)
	      if (!_this.implicitFlowRedirectUri.match(/^[a-z]+:/i)) {
	        // no protocol present
	        var baseUrl = toFullUrl(document.baseURI || location.pathname).replace(/^([^?#]*\/).*/, "$1");
	        if (_this.implicitFlowRedirectUri.charAt(0) != "/") _this.implicitFlowRedirectUri = toFullUrl(baseUrl + _this.implicitFlowRedirectUri);else _this.implicitFlowRedirectUri = toFullUrl(_this.implicitFlowRedirectUri);
	      }

	      // add session state checking which, in case that we were logged in and a logout
	      // against OIDC is detected (e.g. in another browser tab), will log us out
	      // TODO This is a hotfix solution - proper way is that there's a component scoped by serverUri which performs the session checks.
	      var timeout = Math.max(5, _this.sessionCheckInterval) * 1000;
	      var check = function () {
	        var _this2 = this;

	        // if not logged in then just plan another check (we don't want to auto-login in this tab if user logs in another browser tab)
	        if (!this._loginCtx) return setTimeout(check, timeout);

	        // check login state via login (but don't actually use the newly issued token)
	        this._login({
	          acr_values: "1",
	          prompt: "none"
	        }, false).then(function () {
	          // still logged in => just plan another check
	          setTimeout(check, timeout);
	        }, function (e) {
	          // assume logout
	          delete _this2._loginCtx;
	          _this2._runListeners();
	          setTimeout(check, timeout);
	        });
	      }.bind(_this);
	      setTimeout(check, timeout);
	    }));
	    this._loginInProgress = [];

	    var listeners = [];
	    /**
	     * @return {boolean} True iff the user is authenticated (logged in).
	     * @method UuOidc.Session#isAuthenticated
	     */
	    this.isAuthenticated = function () {
	      return !!_this._loginCtx;
	    };
	    /**
	     * Adds listener for changes of user identity (logins / logouts).
	     * 
	     * @param {Function(Object)} listener The listener function to add. The function receives identity object or null.
	     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link UuOidc.Session#removeIdentityChangeListener}).
	     * @see UuOidc.Session#getIdentity
	     * @method UuOidc.Session#addIdentityChangeListener
	     */
	    this.addIdentityChangeListener = function (listener) {
	      listeners.push(listener);
	      return _this.removeIdentityChangeListener.bind(_this, listener);
	    };
	    /**
	     * Removes listener for changes of user identity (logins / logouts).
	     * 
	     * @param {Function(Object)} listener The listener to remove.
	     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
	     * @method UuOidc.Session#removeIdentityChangeListener
	     */
	    this.removeIdentityChangeListener = function (listener) {
	      var idx = listeners.indexOf(listener);
	      if (idx != -1) listeners.splice(idx, 1);
	      return idx != -1;
	    };
	    this._runListeners = function () {
	      var identity = _this.getIdentity();
	      listeners.forEach(function (it) {
	        return it.call(_this, identity);
	      });
	    };

	    this.nonce = Math.random().toString(32).substr(2);

	    // add planning & executing of token refresh when its nearing expiration
	    // NOTE This assumes that each token refresh ends with running the identity-change listeners.
	    this.addIdentityChangeListener(function (identity) {
	      // console.log("Identity change:", identity);
	      if (_this._sessionRefreshTimeout) {
	        clearTimeout(_this._sessionRefreshTimeout);
	        delete _this._sessionRefreshTimeout;
	      }
	      var claims = _this.getClaims();
	      var expiresAt = (claims || {})["exp"];
	      if (!expiresAt) return;
	      expiresAt = expiresAt * 1000; // let it be in milliseconds
	      var LEEWAY = 5 * 60 * 1000;
	      var now = new Date().getTime();
	      var delay = expiresAt - now - LEEWAY;
	      if (delay < 0) delay = 0;
	      // expiresAt = now + 30000;
	      // delay = 20000;
	      // console.log("Planning token refresh in ", delay, "ms.");
	      _this._sessionRefreshTimeout = setTimeout(function () {
	        delete _this._sessionRefreshTimeout;
	        // refresh token by calling login() un-interactively
	        _this._login({
	          prompt: "none", // no user interaction
	          acr_values: "1" // non-anonymous user
	        }).catch(function (e) {
	          if (_this._sessionRefreshTimeout) return; // identity changed in-between (maybe due to login with directly provided access_token)
	          // refresh failed => perform logout few seconds before the token expires
	          var autoLogoutAfter = Math.max(0, expiresAt - new Date().getTime() - 30 * 1000);
	          // console.log("Token refresh failed - will perform auto-logout in", autoLogoutAfter, "ms.");
	          _this._sessionRefreshTimeout = setTimeout(function () {
	            delete _this._loginCtx;
	            _this._runListeners();
	          }, autoLogoutAfter);
	        });
	      }, delay);
	    });
	  }

	  /**
	   * Returns identity of currently logged in user or null if not logged in. The identity contains following fields:
	   * 
	   * * id
	   * * name
	   * * uuIdentity
	   * * email
	   * * levelOfAssurance
	   * * loginLevelOfAssurance
	   * 
	   * @return {Object} Identity of currently logged in user or null if not logged in.
	   * @method UuOidc.Session#getIdentity
	   */


	  _createClass(Session, [{
	    key: "getIdentity",
	    value: function getIdentity() {
	      return this._loginCtx ? this._loginCtx.getIdentity() : null;
	    }

	    /**
	     * Returns all claims present in the token (or null if not logged in).
	     * 
	     * @method UuOidc.Session#getClaims
	     */

	  }, {
	    key: "getClaims",
	    value: function getClaims() {
	      return this._loginCtx ? this._loginCtx.getClaims() : null;
	    }

	    /**
	     * Login against OpenID Connect server. If no or empty options are used, user will be required to
	     * log in as non-anonymous user (as if { acrValues: 1 } was used). If user is already logged in
	     * and options don't indicate that a re-login is necessary, then the method does nothing. Re-login can
	     * be forced by using option "prompt" set to "login".
	     * 
	     * @param options {Object} Options.
	     * @param options.prompt {string} (optional) One of "" (default), "none" (check login state without user interaction), "login" (re-request authentication).
	     * @param options.acrValues (optional) One of: 0 (allow log in as anonymous), 1 (require non-anonymous user).
	     * @param options.accessToken {string} (optional) Authentication token to use for login. Currently, only id_token (JWT) is supported.
	     * @param options.tokenTypeHint {string} (optional) Hint about the type of the authentication token (accessToken in options) if it
	     *   isn't standard id_token. Supported values depend on OpenID Connect server. uuOS9 server supports these values:
	     * 
	     * * "urn:ietf:params:oauth:token-type:jwt-uuos8" - indicates that the token being passed to the login was originally issued by uuOS8
	     * 
	     * @return Promise resolved after the login ends. The resolved value is this session instance, identity of logged in user can be obtained
	     *   via sessionInstance.{@link UuOidc.Session#getIdentity getIdentity()}. Rejection value is one of:
	     * 
	     *   * false - user refused to log in
	     *   * Error - any other error such as network problems, ...
	     * 
	     * @method UuOidc.Session#login
	     */

	  }, {
	    key: "login",
	    value: function login(options) {
	      // NOTE For backward compatibility within version 1.x.y, this method must accept also snake_cased options keys (access_token, ...).

	      // convert keys in options to snake_case (that's what is used in the code base of this library as OpenID & OAuth uses it too)
	      var opts;
	      if (options) opts = Object.keys(options).reduce(function (r, k) {
	        return r[_StringUtil2.default.toSnakeCase(k)] = options[k], r;
	      }, {});

	      return this._login(opts, true);
	    }

	    // NOTE Uses snake_case in options because that's how OpenID & OAuth is specified.

	  }, {
	    key: "_login",
	    value: function _login(options) {
	      var _this3 = this;

	      var updateSessionWithLoginResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	      var opts = Object.assign({}, options);

	      // there's a special case in which we support providing uuOS8 token
	      var os8Token;
	      if (opts.token_type_hint === "urn:ietf:params:oauth:token-type:jwt-uuos8") {
	        os8Token = opts.access_token;
	        delete opts.access_token;
	        delete opts.token_type_hint;
	      }

	      // use accessToken directly if it's provided
	      var accessToken = opts.access_token;
	      delete opts.access_token;

	      var doLogin = function doLogin() {
	        _this3._loginInProgress.push(1);

	        // if calling Session.login() with no parameters, log in as non-anonymous user
	        if (Object.keys(opts).length == 0) opts["acr_values"] = 1;

	        // if we have user then login only if options indicate that we have to
	        if (!accessToken && _this3._loginCtx) {
	          var useCurrent = true;
	          if (opts["prompt"] || opts["max_age"] || opts["access_token"]) useCurrent = false; // TODO Check max_age in more detail and use current if we're within the limit.

	          // check required login level of assurance
	          var acr_values = (opts["acr_values"] != null ? opts["acr_values"] + "" : "").split(/\s+/);
	          var identity = _this3.getIdentity();
	          if (acr_values.every(function (v) {
	            return Number(v) > identity.loginLevelOfAssurance;
	          })) useCurrent = false; // all acceptable login levels of assurance, that are requested, are greater than current one => do the login

	          // check current token expiration
	          if (_this3._authResponseExpired(_this3._loginCtx.authResponse)) useCurrent = false; // our token expired => do the login

	          // use current token if everything seems fine
	          if (useCurrent) {
	            _this3._loginInProgress.pop();
	            return Promise.resolve(_this3);
	          }
	        }

	        // login using implicit flow
	        var authResponse = accessToken ? { id_token: accessToken } : null;
	        var state;
	        var nonce = accessToken || "nonce" in opts ? opts["nonce"] : _this3.nonce;

	        // NOTE Clicking a button, which launches this login method, can result in
	        // at most 1 Promise resolution. If 2 or more Promises are chained, mobile
	        // devices such as iPhone 4 will block popup opening. That's why this._optionsMergedPromise
	        // is wrapped via PromiseUtil which then allows us here to call our "then" function immediately
	        // if the this._optionsMergedPromise has already been resolved.
	        // TODO Maybe reimplement by using some sort of ImmediatePromiseWrapper which in case of .then(fn)
	        // will invoke the fn immediately. Note that Promise chaining must be somehow resolved which is
	        // not trivial.
	        var authResponsePromise = Promise.resolve(authResponse || _PromiseUtil2.default.immediateThen(_this3._optionsMergedPromise, function () {
	          // handle uuOS8 token - we need to obtain standard OIDC id_token and start OIDC session (set session cookie) - we'll
	          // do this by exchanging tokens via non-standard endpoint for uuOS8
	          if (os8Token) {
	            nonce = null;
	            var os8Auth = new _Os8Auth2.default({
	              serverUri: _this3.serverUri,
	              clientId: _this3.clientId,
	              redirectUri: _this3.implicitFlowRedirectUri
	            });
	            return os8Auth.grantExchangeToken({
	              subject_token: os8Token
	            });
	          }

	          // authenticate using implicit flow
	          opts.nonce = nonce;
	          opts.state = state = Math.random().toString(32).substr(2);
	          return _ImplicitFlow2.default.login({
	            serverUri: _this3.serverUri,
	            clientId: _this3.clientId,
	            redirectUri: _this3.implicitFlowRedirectUri,
	            loginParams: opts
	          });
	        }, function (e) {
	          return Promise.reject(e);
	        }));
	        return authResponsePromise.then(function (authResponse) {
	          // ImplicitFlow response validation: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthResponseValidation
	          // 1. process only recognized fields in response (id_token, expires_in, ...)
	          // 2. validate implicit flow callback response ("state")
	          // 3. validate id_token with nonce => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
	          //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
	          //     ii. validate signature
	          //    iii. validate nonce
	          // 4. validate access_token

	          // 2.i. validate state
	          if (state && authResponse.state !== state) throw new Error("Invalid 'state' in received token. Expected " + state + " but got " + authResponse.state + ". Token: " + JSON.stringify(authResponse));

	          // 2.ii. validate expiration
	          if (_this3._authResponseExpired(authResponse)) throw new Error("Token expired " + JSON.stringify(authResponse));

	          // 3. validate id_token with nonce
	          return _this3._validateIdToken(authResponse.id_token, nonce).then(function (claims) {
	            if (updateSessionWithLoginResult !== false) {
	              _this3._loginCtx = new _SessionContext2.default(opts, authResponse, claims);
	              _this3._runListeners();
	            }
	            return _this3;
	          });
	        }).then(function (r) {
	          _this3._loginInProgress.pop();
	          return r;
	        }, function (e) {
	          _this3._loginInProgress.pop();
	          return Promise.reject(e);
	        });
	      };

	      // wait for session restoring in case that this instance of the session is the "main" session
	      return this === Session.currentSession && !accessToken && !os8Token && Object.keys(opts).length === 0 ? _PromiseUtil2.default.immediateThen(Session.initPromise, doLogin) : doLogin();
	    }

	    /**
	     * @return Promise resolved after the user gets logged out.
	     * @method UuOidc.Session#logout
	     */

	  }, {
	    key: "logout",
	    value: function logout() {
	      var _this4 = this;

	      if (!this._loginCtx) return Promise.resolve();

	      // TODO Logout using end_session_endpoint when it's implemented on server-side.
	      // logout using uuOidc-specific logout endpoint for now
	      return this._optionsMergedPromise.then(function () {
	        return new Promise(function (resolve, reject) {
	          var oidcServerUri = _this4.serverUri;
	          var logoutCallbackUri = _this4.implicitFlowRedirectUri;
	          var logoutUrl = oidcServerUri + "/logout?redirect_uri=" + encodeURIComponent(logoutCallbackUri);
	          new _IframeComponent2.default({
	            url: logoutUrl,
	            onResult: function onResult(result) {
	              // assume that the user is now logged out (regardless of result)
	              delete _this4._loginCtx;
	              _this4._runListeners();
	              resolve();
	            }
	          }).render();
	        });
	      });
	    }

	    /**
	     * Returns token and its type for calling commands. Returned object contains following fields:
	     * 
	     * * tokenType - the type of the token, such as "Bearer",
	     * * token - the token itself.
	     * 
	     * If the user is not logged in, null is returned.
	     * 
	     * @param {(string|UuApp.Uri.Uri)} callUri (optional) Command URI that is going to be called with the token.
	     * @return Object containing token and its type, or null if user is not logged in.
	     * @method UuOidc.Session#getCallToken
	     */

	  }, {
	    key: "getCallToken",
	    value: function getCallToken(callUri) {
	      var authResponse = (this._loginCtx || {}).authResponse;
	      if (!authResponse) return null;
	      var result = {
	        tokenType: authResponse.token_type || null,
	        token: authResponse.id_token || null
	      };
	      return result;
	    }
	  }, {
	    key: "_authResponseExpired",
	    value: function _authResponseExpired(authResponse) {
	      var now = new Date().getTime() / 1000;
	      var leeway = 60;
	      var expired = false;
	      if (!authResponse.issued_at) authResponse.issued_at = now;
	      if (authResponse.expires_at) expired = expired || authResponse.expires_at < now - leeway;
	      if (authResponse.expires_in && authResponse.issued_at) expired = expired || Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway;
	      return expired;
	    }

	    /**
	     * @return {Promise<Object>} Promise resolved to JWT claims or rejected with validation error.
	     */

	  }, {
	    key: "_validateIdToken",
	    value: function _validateIdToken(token, nonce) {
	      var _this5 = this;

	      // 3. validate id_token => http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation
	      //      i. validate as authorization code flow - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation
	      //         1. -Decrypt JWE - not supported.
	      //         2. +REQUIRED validate 'iss'
	      //         3. +REQUIRED validate 'aud'
	      //         4. -SHOULD validate multiple 'aud' vs. 'azp'
	      //         5. -SHOULD validate 'azp'
	      //         6. -REQUIRED <applicable only for token_endpoint, not for implicit flow>
	      //         7. -SHOULD validate 'alg' in header vs. 'alg' sent during client registration
	      //         8. -REQUIRED <for MAC-based algos> - not supported (we use RSA)
	      //         9. +REQUIRED current time < 'exp'
	      //        10. +CAN check 'iat'
	      //        11. +REQUIRED (for implicit flow) validate nonce
	      //        12. -SHOULD check if 'acr' is appropriate
	      //        13. -SHOULD check if 'auth_time' was requested.
	      //     ii. validate signature
	      //    iii. validate nonce

	      return this._optionsMergedPromise.then(function () {
	        return _Discovery2.default.getMetadata(_this5.serverUri).then(function (metadata) {
	          var verifyOptions = {
	            // NOTE IE11 doesn't have RS512 (but it has "RS256" and "RS384").
	            alg: ["RS256"], // 3.i.7. (we'll allow only RSA algorithms for signature verification)
	            iss: [metadata.issuer], // 3.i.2.
	            // aud: this.clientId, // 3.i.3. TODO We don't have the proper value.
	            // 3.i.9. - 'exp' is checked automatically if present in JWT claims (as well as 'iat', 'nbf') 
	            gracePeriod: 300
	          };
	          return _Jwt2.default.decode(token, verifyOptions, function (jwtHeader) {
	            // 3.ii.
	            if (!jwtHeader.alg || !jwtHeader.alg.match(/^RS\d+$/)) throw new Error("Invalid token. Only RSA signature is supported, but token uses algorithm '" + jwtHeader.alg + "'. Token: " + token);
	            var keyType = "RSA";

	            // check algorithm in token (whether it's really supported by the server)
	            var supportedAlgs = metadata.id_token_signing_alg_values_supported || [];
	            if (supportedAlgs.indexOf(jwtHeader.alg) == -1) throw new Error("Invalid token. Token was signed using algorithm '" + jwtHeader.alg + "' but the OIDC server '" + _this5.serverUri + "' supports only " + JSON.stringify(supportedAlgs) + ". Token: " + token);

	            // pick the key from JWK Set
	            var jwks = new _Jwks2.default({ serverUri: _this5.serverUri });
	            return jwks.getKey(jwtHeader.kid, keyType).catch(function (e) {
	              throw new Error("Invalid token. Unable to match key from JWT header to list of keys used by OpenID Connect server " + _this5.serverUri + ". Token: " + token, e);
	            });
	          }).then(function (claims) {
	            // 3.i.11., 3.iii. validate nonce
	            if (nonce && claims.nonce !== nonce) throw new _InvalidTokenError2.default("Invalid nonce in ID token claims. Expected " + nonce + " but got " + claims.nonce);
	            return claims;
	          });
	        });
	      });
	    }
	  }]);

	  return Session;
	}();

	exports.default = Session;


	function toFullUrl(path) {
	  var a = document.createElement("a");
	  a.href = path;
	  return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
	}

	/**
	 * Current session.
	 * 
	 * @name UuOidc.Session.currentSession
	 * @type UuOidc.Session
	 */
	var currentSession;
	var allowAutoInitSession = true;
	Object.defineProperty(Session, "currentSession", {
	  get: function get() {
	    if (allowAutoInitSession && !currentSession) {
	      currentSession = new Session(_uu_appg01_core.Util.Config); // TODO As it is now, accessing Session.currentSession prior to invoking Config.init will use defaults-only (for whole page duration).
	      currentSession.initComplete = false;
	      currentSession.initPromise = Session.initPromise;
	    }
	    return currentSession;
	  },
	  set: function set(value) {
	    allowAutoInitSession = false;
	    currentSession = value;
	  }
	});

	var finalizeInit;
	/**
	 * Promise resolved after session initialization (restoring state) finishes.
	 * 
	 * @type {Promise<UuOidc.Session>}
	 * @name UuOidc.Session.initPromise 
	 */
	/**
	 * Promise resolved after session initialization (restoring state) finishes.
	 * Note that this field is available only on a session instance that is
	 * created automatically during page load.
	 * 
	 * @type {Promise<UuOidc.Session>}
	 * @name UuOidc.Session#initPromise 
	 */
	Session.initPromise = _PromiseUtil2.default.wrapForImmediateThen(new Promise(function (resolve, reject) {
	  finalizeInit = function finalizeInit(isOk, result) {
	    Session.initComplete = true;
	    Session.currentSession.initComplete = true;
	    if (!isOk) console.log("Session initialization failed:", result);
	    resolve(Session.currentSession); // always resolve as success even if checking session state failed
	    return Session.initPromise;
	  };
	}));

	/**
	 * Whether the session initialization performed during page load has already completed.
	 * 
	 * @type {boolean}
	 * @name UuOidc.Session.initComplete
	 */
	/**
	 * Whether the session initialization performed during page load has already completed.
	 * Note that this field is available only on a session instance that is
	 * created automatically during page load.
	 * 
	 * @type {boolean}
	 * @name UuOidc.Session#initComplete
	 */
	Session.initComplete = false;

	function tryAutoLogin() {
	  if (Session.currentSession.isAuthenticated() || Session.currentSession._loginInProgress.length > 0) return;

	  // if there's access_token parameter in current URL, consider it as the id_token of the user
	  var id_token;
	  location.search.replace(/[?&]access_token=([^&#]*)/, function (m, g) {
	    id_token = decodeURIComponent(g.replace(/\+/g, " "));
	  });
	  if (id_token) {
	    return Session.currentSession._login({
	      access_token: id_token,
	      nonce: null
	    });
	  }

	  // TODO Maybe we should use localStorage/sessionStorage too so that navigating between pages won't unnecessarily trigger
	  // re-login every time.

	  // try to login with no user interaction
	  return Session.currentSession._login({
	    prompt: "none", // no user interaction
	    acr_values: "1" // non-anonymous user
	  }).catch(function (e) {
	    if (e && (typeof e === "undefined" ? "undefined" : _typeof(e)) == "object" && typeof e["error_description"] == "string" && e["error_description"].match(/interaction/i) && e["error_description"].match(/required/i)) return; // everything is fine, we just aren't logged in
	    throw e; // some other error happenned
	  });
	}

	// try to login without prompting user (only for browser environment)
	var isBrowser = new Function("try {return this===window;}catch(e){ return false;}")();
	if (isBrowser) {
	  // wait until DOM is ready because we need BODY element to be present due to how implicit flow works
	  _Dom2.default.domReady.then(function () {
	    return Promise.resolve(tryAutoLogin()); // ASAP login, possibly from URL parameter
	  }).then(finalizeInit.bind(null, true), finalizeInit.bind(null, false));
	} else {
	  finalizeInit(true);
	}

/***/ },
/* 4 */
/*!*****************************************************************************************************************!*\
  !*** external {"amd":"uu_appg01_core","commonjs":"uu_appg01_core","commonjs2":"uu_appg01_core","root":"UuApp"} ***!
  \*****************************************************************************************************************/
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ },
/* 5 */
/*!*********************!*\
  !*** ./Defaults.js ***!
  \*********************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	// NOTE If changed, update also JSDoc in Session.js.
	exports.default = {
	    serverUri: "https://oidc.plus4u.net/uu-oidcg01-main/0-0",
	    sessionCheckInterval: 60
	};

/***/ },
/* 6 */
/*!******************************!*\
  !*** ./flow/ImplicitFlow.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Discovery = __webpack_require__(/*! ../discovery/Discovery.js */ 7);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	var _PromiseUtil = __webpack_require__(/*! ../util/PromiseUtil.js */ 9);

	var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

	var _PopupComponent = __webpack_require__(/*! ../ui/PopupComponent.js */ 10);

	var _PopupComponent2 = _interopRequireDefault(_PopupComponent);

	var _IframeComponent = __webpack_require__(/*! ../ui/IframeComponent.js */ 12);

	var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ImplicitFlow = {
	  /**
	   * @param options.serverUri
	   * @param options.clientId
	   * @param options.redirectUri
	   * @param options.loginVisualComponent
	   * @param options.loginParams
	   */
	  login: function login(options) {
	    var opts = options || {};

	    // check that required data is available
	    var serverUri = opts.serverUri;
	    if (!serverUri) throw new Error("ImplicitFlow.login requires option 'serverUri'.");
	    var clientId = opts.clientId;
	    if (!clientId) throw new Error("ImplicitFlow.login requires option 'clientId'.");
	    var redirectUri = opts.redirectUri;
	    if (!redirectUri) throw new Error("ImplicitFlow.login requires option 'redirectUri'.");

	    // NOTE Using PromiseUtil.immediateThen which will run our "then" callback immediately if
	    // the Discovery.getMetadata is already resolved. The idea is that this login could have
	    // been triggered from "click" event and we need to open popup window within this event's
	    // lifetime or within single Promise (but not Promise chain because that doesn't work on
	    // iPhones).
	    return _PromiseUtil2.default.immediateThen(_Discovery2.default.getMetadata(serverUri), function (oidcMetadata) {
	      // prepare login URL
	      var loginParams = Object.assign({ scope: "openid" }, opts.loginParams, {
	        response_type: "id_token token",
	        client_id: clientId,
	        redirect_uri: redirectUri
	      });
	      var loginParamsParts = [];
	      for (var k in loginParams) {
	        var v = loginParams[k];
	        if (v == null) continue;
	        loginParamsParts.push(encodeURIComponent(k) + "=" + encodeURIComponent(v + ""));
	      }
	      var loginUrl = oidcMetadata.authorization_endpoint + "?" + loginParamsParts.join("&");

	      // display visual component for logging in (popup window)
	      var LoginVisualComponent = opts.loginVisualComponent || (loginParams.prompt != "none" ? _PopupComponent2.default : _IframeComponent2.default);
	      return new Promise(function (resolve, reject) {
	        new LoginVisualComponent({
	          url: loginUrl,
	          onResult: function onResult(aLoginResult) {
	            var authResponse = ImplicitFlow.getAuthResponseFromCallback(aLoginResult);
	            if (authResponse === false) return reject(new Error("User refused to sign in or the operation didn't complete successfully, e.g. due to popup blocking."));

	            // resolve the promise successfully with the token (iff there's no "error" field)
	            if (authResponse.error) reject(authResponse);else resolve(authResponse);
	          }
	        }).render();
	      });
	    }, function (e) {
	      return Promise.reject(e);
	    });
	  },

	  /**
	   * 
	   * @param {*} aLoginCallbackResult 
	   * @return One of: 
	   * * false - user refused to log in (or popups are blocked)
	   * * object with "error" field set - an error
	   * * object - the OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...
	   */
	  getAuthResponseFromCallback: function getAuthResponseFromCallback(aLoginCallbackResult) {
	    if (aLoginCallbackResult === false) return aLoginCallbackResult;

	    // extract login token
	    // example of successful aLoginCallbackResult: "...#access_token=UUOIDCAT-27a13a6e626a40c49e036cbab55f3e27&id_token=eyJ0eXAiOi...&token_type=Bearer&expires_in=7200&scope=openid" 
	    // example of error aLoginCallbackResult:      "...#error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR"
	    var authResponse = {};
	    aLoginCallbackResult.replace(/^[^#]*#?/, "").split(/&/).forEach(function (it) {
	      var eqlIdx = it.indexOf("=");
	      var key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\+/g, " "));
	      var value = decodeURIComponent((eqlIdx == -1 ? "" : it.substr(eqlIdx + 1)).replace(/\+/g, " "));
	      authResponse[key] = value;
	    });
	    return authResponse;
	  }
	};

	exports.default = ImplicitFlow;

/***/ },
/* 7 */
/*!********************************!*\
  !*** ./discovery/Discovery.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _HttpClient = __webpack_require__(/*! ../util/HttpClient.js */ 8);

	var _HttpClient2 = _interopRequireDefault(_HttpClient);

	var _PromiseUtil = __webpack_require__(/*! ../util/PromiseUtil.js */ 9);

	var _PromiseUtil2 = _interopRequireDefault(_PromiseUtil);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var oidcMetadataCache = {}; // stores Promises

	exports.default = {
	  /**
	   * @return Promise resolving to OIDC discovery metadata for given issuerUri.
	   */
	  getMetadata: function getMetadata(aIssuerUri) {
	    var issuerUri = aIssuerUri.replace(/\/+$/, ""); // strip trailing slash(es) (this also normalizes it as a key to cache)
	    var metadata = oidcMetadataCache[issuerUri];
	    if (metadata) return metadata;
	    var discoveryEndpoint = issuerUri + "/.well-known/openid-configuration";
	    return oidcMetadataCache[issuerUri] = _PromiseUtil2.default.wrapForImmediateThen(_HttpClient2.default.get(discoveryEndpoint).catch(function (e) {
	      delete oidcMetadataCache[issuerUri]; // don't cache errors so that e.g. clicking a button 2nd time (after network is up again) has chance to work
	      throw e;
	    }));
	  }
	};

/***/ },
/* 8 */
/*!****************************!*\
  !*** ./util/HttpClient.js ***!
  \****************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// helper for invoking Ajax requests and returning Promise
	function xhrJson(method, url, body, extraSettingFn) {
	  return new Promise(function (resolve, reject) {
	    var xhr = new XMLHttpRequest();
	    xhr.open(method, url, true);
	    xhr.withCredentials = true;
	    xhr.setRequestHeader("Accept", "application/json");
	    xhr.onreadystatechange = function (e) {
	      if (xhr.readyState == 4) {
	        if (xhr.status >= 200 && xhr.status < 300) {
	          try {
	            var json = JSON.parse(xhr.responseText);
	            resolve(json);
	          } catch (err) {
	            reject(err);
	          }
	        } else {
	          reject(new Error("Server responded with status " + xhr.status)); // TODO Better error.
	        }
	      }
	    };
	    xhr.withCredentials = true;
	    if (extraSettingFn) extraSettingFn(xhr);
	    xhr.send(body);
	  });
	}

	exports.default = {
	  get: function get() {
	    return xhrJson.bind(this, "GET").apply(this, Array.prototype.slice.call(arguments));
	  },
	  post: function post() {
	    return xhrJson.bind(this, "POST").apply(this, Array.prototype.slice.call(arguments));
	  }
	};

/***/ },
/* 9 */
/*!*****************************!*\
  !*** ./util/PromiseUtil.js ***!
  \*****************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  /**
	   * Wraps Promise so that it can then be used in immediateThen function.
	   */
	  wrapForImmediateThen: function wrapForImmediateThen(promise) {
	    promise.then(function (v) {
	      return promise._immediateValue = v;
	    }, function (e) {
	      return promise._immediateError = e;
	    });
	    return promise;
	  },

	  /**
	   * If promise has already been resolved, thenFn is called immediately (or catchFn in
	   * case that the promise has been rejected). Otherwise thenFn and catchFn callbacks
	   * are simply registered via promise.then(thenFn, catchFn).
	   * 
	   * Note that this works only on promises that were wrapped via #wrapForImmediateThen
	   * function.
	   * 
	   * @return Return value of thenFn/catchFn (if invoked immediately) or promise.then(thenFn, catchFn).
	   */
	  immediateThen: function immediateThen(promise, thenFn, catchFn) {
	    if ("_immediateValue" in promise) return typeof thenFn == "function" ? thenFn(promise._immediateValue) : promise._immediateValue;
	    if ("_immediateError" in promise) {
	      if (typeof catchFn == "function") return catchFn(promise._immediateError);
	      throw promise._immediateError;
	    }
	    return promise.then(thenFn, catchFn);
	  }
	};

/***/ },
/* 10 */
/*!******************************!*\
  !*** ./ui/PopupComponent.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _CallbackHandler = __webpack_require__(/*! ./CallbackHandler.js */ 11);

	var _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Default visual component for presenting login/logout prompt to the user. It displays the
	 * URL in a popup window and waits until the user logs in / closes the window. After that
	 * initAttrs.onResult(authResultUrl) is called as callback.
	 * 
	 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
	 * @param initAttrs.onResult The callback to call after login finishes. If the login finished
	 *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.
	 *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which
	 *   contains the authentication response in fragment). 
	 */
	var PopupComponent = function PopupComponent(initAttrs) {
	  var attrs = Object.assign({}, initAttrs);
	  var state = {
	    loginWindow: null,
	    closeCheckInterval: null
	  };

	  // add self to the list of opened loginWindows
	  _CallbackHandler2.default.registerForCallback(this, state);

	  this.finalize = function (result) {
	    // cleanup & do the callback
	    this.destroy();
	    if (attrs.onResult) attrs.onResult(result);
	  }.bind(this);

	  var closeCheck = function () {
	    if (!state.loginWindow || !state.loginWindow.closed) return;
	    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value "false"
	  }.bind(this);

	  this.render = function () {
	    var _this = this;

	    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)
	    if (!state.loginWindow) {
	      var rect = { width: 599, height: 600 };
	      rect.left = (screen.availWidth - rect.width) / 2 + screen.availLeft;
	      rect.top = (screen.availHeight - rect.height) / 2 + screen.availTop;
	      state.loginWindow = window.open(attrs.url, "_blank", "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=" + rect.width + ",height=" + rect.height + ",top=" + rect.top + ",left=" + rect.left);
	      if (!state.loginWindow) {
	        // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in
	        Promise.resolve().then(function () {
	          return _this.finalize(false);
	        }); // finalize in async way
	      } else {
	        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);
	      }
	    }
	  };

	  this.destroy = function () {
	    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();
	    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);
	    this.destroy = function () {};
	    _CallbackHandler2.default.unregisterForCallback(this);
	  };
	};

	exports.default = PopupComponent;

/***/ },
/* 11 */
/*!*******************************!*\
  !*** ./ui/CallbackHandler.js ***!
  \*******************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// login callback handling
	var VC_CALLBACK_FN_NAME = "uuOidcCallbackFn"; // !!! Must be in sync with the one in callbacks/oidc-callback.html.

	// make sure that callback works correctly even if multiple invocations using visual component below were
	// done (e.g. user clicked 2 different buttons for command invocations which each opened a login popup
	// and are now displayed both)
	if (typeof window != "undefined" && !window[VC_CALLBACK_FN_NAME]) {
	  window[VC_CALLBACK_FN_NAME] = function (aLoginResult, aSourceWindow) {
	    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;
	    // received callback from a popup => find out which component is using the source window and notify it
	    for (var i = 0; i < loginWindows.length; ++i) {
	      var p = loginWindows[i];
	      if (p.state.loginWindow == aSourceWindow) {
	        p.component.finalize(aLoginResult);
	        return;
	      }
	    }
	    console.warn("Received unexpected callback from window", aSourceWindow, "Passed result was:", aLoginResult, "Ignoring the callback.");
	  };
	  window[VC_CALLBACK_FN_NAME].loginWindows = [];
	}

	exports.default = {
	  registerForCallback: function registerForCallback(component, state) {
	    window[VC_CALLBACK_FN_NAME].loginWindows.push({ component: component, state: state });
	  },
	  unregisterForCallback: function unregisterForCallback(component) {
	    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;
	    for (var i = 0; i < loginWindows.length; ++i) {
	      // remove self from opened loginWindows
	      if (loginWindows[i].component === component) {
	        loginWindows.splice(i, 1);
	        break;
	      }
	    }
	  }
	};

/***/ },
/* 12 */
/*!*******************************!*\
  !*** ./ui/IframeComponent.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _CallbackHandler = __webpack_require__(/*! ./CallbackHandler.js */ 11);

	var _CallbackHandler2 = _interopRequireDefault(_CallbackHandler);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Visual component for attempting user login/logout on a background in an iframe. Usable only for prompt="none" cases.
	 * After login/logout initAttrs.onResult(authResultUrl) is called as callback.
	 * 
	 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
	 * @param initAttrs.onResult The callback to call after login/logout finishes.
	 */
	var IframeComponent = function IframeComponent(initAttrs) {
	  var attrs = Object.assign({}, initAttrs);
	  var state = {
	    iframe: null
	  };
	  Object.defineProperty(state, "loginWindow", {
	    get: function get() {
	      try {
	        // needs try-catch depending on which phase we're being asked (might be during redirect, ..., which can be cross-domain)
	        return state.iframe != null ? state.iframe.contentWindow : null;
	      } catch (e) {
	        // ignore
	      }
	      return null;
	    }
	  });

	  // add self to the list of openend loginWindows
	  _CallbackHandler2.default.registerForCallback(this, state);

	  // finalization callback (for this component instance) called after login from redirect_uri page
	  this.finalize = function (aLoginResult) {
	    // cleanup & do the callback
	    this.destroy();
	    if (attrs.onResult) attrs.onResult(aLoginResult);
	  }.bind(this);

	  // TODO Maybe use timeout ~30s and destroy in case that something is seriously wrong (network errors, ...).

	  this.render = function () {
	    if (!state.iframe) {
	      state.iframe = document.createElement("iframe");
	      state.iframe.style.cssText = "position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;";
	      state.iframe.src = attrs.url;
	      document.body.appendChild(state.iframe);
	    }
	  };

	  this.destroy = function () {
	    if (state.iframe && state.iframe.parentNode) state.iframe.parentNode.removeChild(state.iframe);
	    this.destroy = function () {};
	    _CallbackHandler2.default.unregisterForCallback(this);
	  };
	};

	exports.default = IframeComponent;

/***/ },
/* 13 */
/*!***************************!*\
  !*** ./SessionContext.js ***!
  \***************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SessionContext = function SessionContext(loginOptions, authResponse, claims) {
	  _classCallCheck(this, SessionContext);

	  this.loginOptions = loginOptions;
	  this.authResponse = authResponse;
	  this.claims = claims;

	  this.getClaims = function () {
	    return claims;
	  };

	  var identity;
	  this.getIdentity = function () {
	    if (identity) return identity;
	    return identity = {
	      id: claims["sub"],
	      name: claims["name"],
	      email: claims["email"],
	      uuIdentity: claims["uu_identity"],
	      levelOfAssurance: Number(claims["loa"]),
	      loginLevelOfAssurance: Number(claims["acr"])
	    };
	  };
	};

	exports.default = SessionContext;

/***/ },
/* 14 */
/*!**********************!*\
  !*** ./util/Uuid.js ***!
  \**********************/
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = generateUuid;
	function generateUuid() {
	  // generate UUID (RFC4122 version 4 compliant) for the event ID
	  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0,
	        v = c == 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });
	  return uuid;
	}

/***/ },
/* 15 */
/*!********************!*\
  !*** ./jwt/Jwt.js ***!
  \********************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Base64Url = __webpack_require__(/*! ../util/Base64Url.js */ 16);

	var _Base64Url2 = _interopRequireDefault(_Base64Url);

	var _InvalidTokenError = __webpack_require__(/*! ./InvalidTokenError.js */ 17);

	var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

	var _JwtVerifierWebCrypto = __webpack_require__(/*! ./JwtVerifierWebCrypto.js */ 18);

	var _JwtVerifierWebCrypto2 = _interopRequireDefault(_JwtVerifierWebCrypto);

	var _JwtVerifierJsrsasign = __webpack_require__(/*! ./JwtVerifierJsrsasign.js */ 19);

	var _JwtVerifierJsrsasign2 = _interopRequireDefault(_JwtVerifierJsrsasign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// JWT - JSON Web Token https://tools.ietf.org/html/rfc7519
	//     - JSON (containing claims) encoded in a JWS / JWE structure
	// JWS - JSON Web Signature https://tools.ietf.org/html/rfc7515
	// JWE - JSON Web Encryption https://tools.ietf.org/html/rfc7516

	// NOTE WebCrypto API works only via https://* or http://localhost (rare exception), but not on http://localhost.plus4u.net
	// so we're falling back to on-demand loaded jsrsasign library (which will be therefore used mostly during development,
	// but not on production; it's ~90kB of minified code).
	var hasWebCrypto = typeof crypto != "undefined" && crypto.subtle && crypto.subtle.importKey;
	var useWebCrypto = hasWebCrypto && (typeof location == "undefined" || location.protocol == "https:");
	var verifier = useWebCrypto ? _JwtVerifierWebCrypto2.default : _JwtVerifierJsrsasign2.default;

	var DEFAULT_ALG = "RS256";
	exports.default = {
	  /**
	   * 
	   */
	  decode: function decode(token, verifyOpts, getKeyFn) {
	    var tokenParts;
	    var header;
	    return Promise.resolve().then(function () {
	      if (typeof token != "string") throw new Error("Invalid JSON Web Token - it must be a string (result of JWS / JWE Compact Serialization as per RFC7515 / RFC7516).");
	      tokenParts = token.split(".");
	      if (tokenParts.length != 3) throw new Error("Unsupported JSON Web Token - the token doesn't consist of header+body+signature (only JWS Compact Serialization is supported - RFC7515, section-3). Token: " + token);

	      // parse header
	      var headerB64U = tokenParts[0];
	      var headerStr = _Base64Url2.default.decode(headerB64U);
	      header = JSON.parse(headerStr);
	      if (header.typ != "JWT") throw new Error("Invalid JSON Web Token - the header 'typ' field is not set to 'JWT'. Token: " + token);

	      // get key
	      return getKeyFn(header);
	    }).then(function (key) {
	      // NOTE Check the whole importKey call if adding support for other key types.
	      if (!key || key.kty != "RSA") throw new Error("Unsupported key type. Only RSA keys are supported for JSON Web Token signature verification. Key: " + JSON.stringify(key));
	      // always verify algorithm against the one is JOSE header
	      var alg = key.alg || DEFAULT_ALG;
	      if (alg !== header.alg) throw new _InvalidTokenError2.default("Invalid JSON Web Token or wrong verification key - algorithms don't match. Token uses '" + header.alg + "', verification key uses '" + key.alg + "' (with default of '" + DEFAULT_ALG + "'). Token: " + token + " Key: " + JSON.stringify(key));

	      return verifier.verify(key, alg, verifyOpts, header, tokenParts, token);
	    }).then(function (valid) {
	      if (!valid) throw new _InvalidTokenError2.default("Invalid JSON Web Token: " + token);
	      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);
	      var body = JSON.parse(bodyStr);
	      return body;
	    });
	  }
	};

/***/ },
/* 16 */
/*!***************************!*\
  !*** ./util/Base64Url.js ***!
  \***************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var Base64Url = {
	  /**
	   * @param txtAscii Ascii string to encode (each character is in range 0-255).
	   * @return {string} Provided string encoded to Base64Url encoding.
	   */
	  encodeAscii: function encodeAscii(txtAscii) {
	    if (!txtAscii) return txtAscii;
	    return btoa(txtAscii).replace(/\+/g, "-").replace(/\//g, "_");
	  },
	  /**
	   * @param txtUtf8 UTF-8 string to encode.
	   * @return {string} Provided string encoded to Base64Url encoding.
	   */
	  encode: function encode(txtUtf8) {
	    if (!txtUtf8) return txtUtf8;
	    return Base64Url.encodeAscii(unescape(encodeURIComponent(txtUtf8)));
	  },
	  /**
	   * @return {string} Base64Url decoded to an Ascii string (each character is in range 0-255).
	   */
	  decodeToAscii: function decodeToAscii(base64Url) {
	    if (!base64Url) return null;
	    var base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
	    return atob(base64);
	  },
	  /**
	   * @return {string} Base64Url decoded to a UTF-8 string.
	   */
	  decode: function decode(base64Url) {
	    var ascii = Base64Url.decodeToAscii(base64Url);
	    return ascii != null ? decodeURIComponent(escape(ascii)) : null;
	  }
	};
	exports.default = Base64Url;

/***/ },
/* 17 */
/*!**********************************!*\
  !*** ./jwt/InvalidTokenError.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var InvalidTokenError = function (_Errors$Error) {
	  _inherits(InvalidTokenError, _Errors$Error);

	  function InvalidTokenError() {
	    _classCallCheck(this, InvalidTokenError);

	    return _possibleConstructorReturn(this, (InvalidTokenError.__proto__ || Object.getPrototypeOf(InvalidTokenError)).apply(this, arguments));
	  }

	  return InvalidTokenError;
	}(_uu_appg01_core.Error.Error);

	exports.default = InvalidTokenError;

/***/ },
/* 18 */
/*!*************************************!*\
  !*** ./jwt/JwtVerifierWebCrypto.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _Base64Url = __webpack_require__(/*! ../util/Base64Url.js */ 16);

	var _Base64Url2 = _interopRequireDefault(_Base64Url);

	var _InvalidTokenError = __webpack_require__(/*! ./InvalidTokenError.js */ 17);

	var _InvalidTokenError2 = _interopRequireDefault(_InvalidTokenError);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	module.exports = {
	  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {
	    var webCryptoAlgorithm = {
	      name: "RSASSA-PKCS1-v1_5",
	      hash: { name: "SHA-" + alg.substr(2) }
	    };
	    // MS Edge throws error if the key contains field "use" => remove it
	    // https://connect.microsoft.com/IE/feedback/details/2242108/webcryptoapi-importing-jwk-with-use-field-fails
	    var usedKey = JSON.parse(JSON.stringify(key));
	    delete usedKey.use;

	    return crypto.subtle.importKey("jwk", usedKey, webCryptoAlgorithm, false, ["verify"]).then(function (webCryptoKey) {
	      // validate signature
	      var signatureB64U = tokenParts[2];
	      var data = tokenParts[0] + "." + tokenParts[1];
	      var signatureBytes = asciiToUint8Array(_Base64Url2.default.decodeToAscii(signatureB64U));
	      var dataBytes = asciiToUint8Array(data);
	      return crypto.subtle.verify(webCryptoKey.algorithm, webCryptoKey, signatureBytes, dataBytes);
	    }, function (importError) {
	      var e = new Error("Unable to verify JSON Web Token - importing key via WebCrypto API failed.\nKey: " + JSON.stringify(usedKey) + "\nToken: " + token + "\nError: " + importError);
	      e.cause = importError;
	      return Promise.reject(e);
	    }).then(function (signatureValid) {
	      if (!signatureValid) throw new _InvalidTokenError2.default("Invalid JSON Web Token - signature is not valid. Token: " + token);
	      var bodyStr = _Base64Url2.default.decode(tokenParts[1]);
	      var body = JSON.parse(bodyStr);
	      var throwError = function throwError(txt, failedClaim) {
	        throw new _InvalidTokenError2.default("Invalid token: " + txt + "\nFailed claim: " + JSON.stringify(failedClaim) + "\nIssued by: " + JSON.stringify(body.iss) + "\nVerification options: " + JSON.stringify(verifyOpts) + "\nToken: " + token);
	      };

	      // verify claims

	      // 'alg' is always checked
	      if (!verifyOpts.alg) throw new Error("Unable to verify JWT claim - 'alg' field must be always given for verification.");
	      if (verifyOpts.alg.indexOf(header.alg) == -1) throwError("Algorithm " + JSON.stringify(header.alg) + " used by token is not valid - expected one of " + JSON.stringify(verifyOpts.alg) + ".", "alg");

	      // 'iss'
	      var v;
	      v = asArray(verifyOpts.iss);
	      if (v && v.indexOf(body.iss) === -1) throwError("Issuer URI " + JSON.stringify(body.iss) + " in token is not valid - expected one of " + JSON.stringify(v) + ". Token was issued by different OpenID Connect server or it was forged.", "iss");

	      // 'sub'
	      v = asArray(verifyOpts.sub);
	      if (v && v.indexOf(body.sub) === -1) throwError("Subject " + JSON.stringify(body.sub) + " in token is not valid - expected one of " + JSON.stringify(v) + ".", "sub");

	      // 'aud' - all values from verifyOpts.aud must be present in body.aud 
	      v = asArray(verifyOpts.aud);
	      var bodyV = asArray(body.aud) || [];
	      if (v && bodyV.some(function (bv) {
	        return v.indexOf(bv) == -1;
	      })) throwError("Audience list " + JSON.stringify(bodyV) + " in token is not valid - some of following values are missing: " + JSON.stringify(v) + ".", "aud");

	      // time validity: (nbf - gracePeriod < now < exp + gracePeriod) && (iat - gracePeriod < now)
	      var now = Date.now() / 1000;
	      if (verifyOpts.verifyAt) now = verifyOpts.verifyAt;
	      var gracePeriod = verifyOpts.gracePeriod || 0;

	      // 'exp' - expires
	      if (typeof body.exp === "number" && body.exp + gracePeriod < now) throwError("Token already expired at " + toTimeString(body.exp) + ", current time is " + toTimeString(now) + ".", "exp");

	      // 'nbf' - not before
	      if (typeof body.nbf === "number" && now < body.nbf - gracePeriod) throwError("Token is not yet valid - it will become valid at " + toTimeString(body.nbf) + ", current time is " + toTimeString(now) + ". Check that your system time is correctly set.", "nbf");

	      // 'iat' - issued at time
	      if (typeof body.iat === "number" && now < body.iat - gracePeriod) throwError("Token seems to have been issued in the future - " + toTimeString(body.iat) + ", current time is " + toTimeString(now) + ". Check that your system time is correctly set.", "iat");

	      // 'jti' - JWT id
	      if (verifyOpts.jti && body.jti !== verifyOpts.jti) throwError("Token ID " + JSON.stringify(body.jti) + " not valid - expected " + JSON.stringify(verifyOpts.jti) + ".", "jti");

	      return true;
	    });
	  }
	};

	function asciiToUint8Array(ascii) {
	  return new Uint8Array(ascii.split("").map(function (c) {
	    return c.charCodeAt(0);
	  }));
	}
	function asArray(value) {
	  if (value == null) return null;
	  if (Array.isArray(value)) return value;
	  return [value];
	}
	function toTimeString(seconds) {
	  return new Date(seconds * 1000).toISOString().replace(/T/, " ");
	}

/***/ },
/* 19 */
/*!*************************************!*\
  !*** ./jwt/JwtVerifierJsrsasign.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _module = __webpack_require__(/*! module */ 1);

	var _module2 = _interopRequireDefault(_module);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var scriptUri = ((_module2.default ? _module2.default.uri : (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
	var jsrsasign = undefined;
	var Verifier = {
	  verify: function verify(key, alg, verifyOpts, header, tokenParts, token) {
	    var _this = this;

	    return Promise.resolve().then(function () {
	      // load jsrsasign library on 1st verification
	      if (jsrsasign === undefined) {
	        var continueFn = Verifier.verify.bind(_this, key, alg, verifyOpts, header, tokenParts, token);
	        var isMin = scriptUri.indexOf(".min.") != -1;
	        var baseUrl = scriptUri.replace(/^(.*\/).*/, "$1");
	        var url = baseUrl + "jsrsasign" + (isMin ? ".min" : "") + ".js";
	        var loadPromise;
	        if (typeof System != "undefined") loadPromise = System.import(url);else loadPromise = new Promise(function (resolve, reject) {
	          var script = document.createElement("script");
	          script.onload = function () {
	            resolve(window["Jsrsasign"]);
	          };
	          script.onerror = function (e) {
	            reject(e);
	          };
	          script.src = url;
	          document.head.appendChild(script);
	        });
	        return loadPromise.then(function (obj) {
	          jsrsasign = obj || null;
	          return continueFn();
	        }, function (e) {
	          console.error(e);
	          jsrsasign = null;
	          return continueFn();
	        });
	      }
	      if (!jsrsasign) throw new Error("Unable to verify token because jsrsasign library failed to load.");

	      // var exampleKey = {"kty":"RSA","e":"AQAB","n":"yXxJt2xevNsgGGGFfX5e22Jvy0_Eopgkumz7mJ7ScWlPfsMsAi8BZsF7nbDjA3T3v2vy2_-DaLDg-z-BjRwQIPL1LRzQGeDDSVmPcZtbexqkpjouxZ6-abpefSAFX5cA8NJ5h4JknFJWAsxxKEw4Ogy6XFd_BEaDmyXlLcV65Bs","alg":"RS256","kid":"rJZx5vzX1FOt_Nt8sB8jUA","use":"sig"};
	      // var pem = KEYUTIL.getPEM(jsrsasign.KEYUTIL.getKey(exampleKey));
	      //   =>
	      // -----BEGIN PUBLIC KEY-----
	      // MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDJfEm3bF682yAYYYV9fl7bYm/L
	      // T8SimCS6bPuYntJxaU9+wywCLwFmwXudsOMDdPe/a/Lb/4NosOD7P4GNHBAg8vUt
	      // HNAZ4MNJWY9xm1t7GqSmOi7Fnr5pul59IAVflwDw0nmHgmScUlYCzHEoTDg6DLpc
	      // V38ERoObJeUtxXrkGwIDAQAB
	      // -----END PUBLIC KEY-----

	      // do the verification
	      var keyInst = jsrsasign.KEYUTIL.getKey(key);
	      var result = jsrsasign.jws.JWS.verifyJWT(token, keyInst, verifyOpts); // see lib/jsrsasign-.../jws-3.3.js
	      return result || Promise.reject(new Error("Token is not valid. Token: " + token));
	    });
	  }
	};

	module.exports = Verifier;

/***/ },
/* 20 */
/*!**********************!*\
  !*** ./jwks/Jwks.js ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Discovery = __webpack_require__(/*! ../discovery/Discovery.js */ 7);

	var _Discovery2 = _interopRequireDefault(_Discovery);

	var _HttpClient = __webpack_require__(/*! ../util/HttpClient.js */ 8);

	var _HttpClient2 = _interopRequireDefault(_HttpClient);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var jwkSetCache = {};
	var cacheBustCounter = 0;

	// JWK - JSON Web Key https://tools.ietf.org/html/rfc7517

	var _class = function () {
	  function _class(options) {
	    _classCallCheck(this, _class);

	    if (!options || !options.serverUri) throw new Error("Jwks must be initialized with options containing serverUri.");
	    this.options = options;
	  }

	  _createClass(_class, [{
	    key: "getKey",
	    value: function getKey(keyId, keyType) {
	      return this._getKey(keyId, keyType, false);
	    }
	  }, {
	    key: "_getKey",
	    value: function _getKey(keyId, keyType, forceKeySetReload) {
	      var _this = this;

	      // load set of OIDC server JSON Web Key-s
	      return _Discovery2.default.getMetadata(this.options.serverUri).then(function (metadata) {
	        // TODO Use also localStorage cache as optimization.
	        var jwkSetMeta = jwkSetCache[metadata.jwks_uri];
	        if (!jwkSetMeta || forceKeySetReload) {
	          var url = metadata.jwks_uri;
	          if (forceKeySetReload) url = url.replace(/(\?.*)?$/, function (m) {
	            return "?cachebust=" + Date.now().toString(36) + "_" + (cacheBustCounter++).toString(36) + (m ? "&" + m.substr(1) : "");
	          });
	          jwkSetMeta = jwkSetCache[metadata.jwks_uri] = _HttpClient2.default.get(url).then(function (value) {
	            return { jwkSet: value, url: url };
	          });
	        }
	        return jwkSetMeta;
	      }).then(function (jwkSetMeta) {
	        var jwkSet = jwkSetMeta.jwkSet;
	        // choose key by id & type
	        var keys = jwkSet.keys;
	        if (keyId) keys = keys.filter(function (it) {
	          return it.kid === keyId;
	        }); // if specific key ID is used then use it (note that there might still be multiple of keys in the result)
	        if (keyType) keys = keys.filter(function (it) {
	          return it.kty === keyType;
	        });
	        // keys = keys.filter(it => it.use === "sig" || (it.key_ops||[]).indexOf("verify") !== -1 || (!it.key_ops && !it.use)); // consider only keys for verification / signing (or unspecified)
	        if (keys.length != 1) {
	          // try force-reloading of the JWK set because the URL from which we downloaded it might have been previously cached by browser
	          // and the server might have changed keys (e.g. due to restart or just because it changes them from time to time)
	          if (!forceKeySetReload) return _this._getKey(keyId, keyType, true);
	          throw new Error("There's " + keys.length + " JSON Web Key(s) in JWK Set with kid='" + keyId + "' kty='" + keyType + "'. There must be exactly 1. JWK Set has been downloaded from: " + jwkSetMeta.url);
	        }
	        return keys[0];
	      });
	    }
	  }]);

	  return _class;
	}();

	exports.default = _class;

/***/ },
/* 21 */
/*!**************************!*\
  !*** ./uuos8/Os8Auth.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _IframeComponent = __webpack_require__(/*! ../ui/IframeComponent.js */ 12);

	var _IframeComponent2 = _interopRequireDefault(_IframeComponent);

	var _ImplicitFlow = __webpack_require__(/*! ../flow/ImplicitFlow.js */ 6);

	var _ImplicitFlow2 = _interopRequireDefault(_ImplicitFlow);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Os8Auth = function () {

	  /**
	   * @param options.serverUri
	   * @param options.clientId
	   * @param options.redirectUri
	   */
	  function Os8Auth(options) {
	    _classCallCheck(this, Os8Auth);

	    if (!options || !options.serverUri || !options.clientId || !options.redirectUri) throw new Error("Os8Auth must be initialized with options containing serverUri, clientId and redirectUri.");
	    this.options = options;
	  }

	  /**
	   * @param parameters
	   * @param parameters.subject_token
	   */


	  _createClass(Os8Auth, [{
	    key: "grantExchangeToken",
	    value: function grantExchangeToken(parameters) {
	      var params = parameters || {};
	      if (!params.subject_token) throw new Error("Os8Auth.grantExchangeToken must be called with parameter subject_token.");
	      var urlParams = Object.assign({}, params, {
	        response_type: "id_token token",
	        client_id: this.options.clientId,
	        redirect_uri: this.options.redirectUri
	      });
	      var urlParamsParts = Object.keys(urlParams).filter(function (k) {
	        return urlParams[k] != null;
	      }).map(function (k) {
	        return encodeURIComponent(k) + "=" + encodeURIComponent(urlParams[k] + "");
	      });
	      var url = this.options.serverUri.replace(/\/*$/, "/") + "exchangeOs8Token" + "?" + urlParamsParts.join("&");

	      return new Promise(function (resolve, reject) {
	        new _IframeComponent2.default({
	          url: url,
	          onResult: function onResult(aLoginResult) {
	            var authResponse = _ImplicitFlow2.default.getAuthResponseFromCallback(aLoginResult);
	            if (!authResponse || authResponse.error) reject(authResponse);else resolve(authResponse);
	          }
	        }).render();
	      });
	    }
	  }]);

	  return Os8Auth;
	}();

	exports.default = Os8Auth;

/***/ },
/* 22 */
/*!*********************!*\
  !*** ./util/Dom.js ***!
  \*********************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var isBrowser = new Function("try {return this===window;}catch(e){ return false;}")();
	var domReadyPromise = isBrowser ? document.readyState === "interactive" || document.readyState === "complete" ? Promise.resolve() : new Promise(function (resolve) {
	  document.addEventListener("DOMContentLoaded", resolve, false);
	}) : Promise.resolve();

	exports.default = {
	  domReady: domReadyPromise
	};

/***/ },
/* 23 */
/*!****************************!*\
  !*** ./util/StringUtil.js ***!
  \****************************/
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  toSnakeCase: function toSnakeCase(aText) {
	    return (aText || "").replace(/[A-Z]/g, function (m) {
	      return "_" + m.toLowerCase();
	    });
	  }
	};

/***/ },
/* 24 */
/*!***************************!*\
  !*** ./SessionHandler.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = SessionHandler;

	var _uu_appg01_core = __webpack_require__(/*! uu_appg01_core */ 4);

	var UuApp = _interopRequireWildcard(_uu_appg01_core);

	var _Session = __webpack_require__(/*! ./Session.js */ 3);

	var _Session2 = _interopRequireDefault(_Session);

	var _StringUtil = __webpack_require__(/*! ./util/StringUtil.js */ 23);

	var _StringUtil2 = _interopRequireDefault(_StringUtil);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// NOTE Interceptor expects gateway present, i.e. it must be added after UriHandler.

	/**
	 * @class UuOidc.SessionHandler
	 * @classdesc
	 * Interceptor for Client which authenticates command calls by using user from
	 * current / specified session. Additionally, if server responds with authentication challenge
	 * (e.g. user needs to login with more secure realm or re-login due to inactivity), the interceptor
	 * performs session login and calls the command again.
	 * 
	 * Interceptor is skipped if there's request header "authorization" set for the command call, even
	 * if the header value is null.
	 * 
	 * **Configuration**
	 * 
	 * Interceptor recognizes following options for command call:
	 * 
	 * * uuoidc.loginParameters - object with extra parameters for login. See {@link UuOidc.Session#login} for supported values.
	 * * session - the session to use for authentication. By default {@link UuOidc.Session.currentSession Session.currentSession} is used.
	 * 
	 * **Error handling**
	 * 
	 * Interceptor might cause the command call to fail with these errors (in addition to standard Client ones):
	 * 
	 * * UuApp.Error.AbortError - in case that the command requires user to be logged in but the user refused to do so.
	 */
	function SessionHandler(request, options, nextInterceptorFn) {
	  var hasCustomAuthn = "authorization" in request.headers;
	  if (hasCustomAuthn) return nextInterceptorFn(request, options);

	  var session = options.session || _Session2.default.currentSession;
	  var loginParams = options["uuoidc.loginParameters"];
	  if (loginParams) loginParams = Object.keys(loginParams).reduce(function (r, k) {
	    return r[_StringUtil2.default.toSnakeCase(k)] = loginParams[k], r;
	  }, {});
	  var count = 0;

	  function runWith(extraLoginParams) {
	    if (++count > 5) throw new UuApp.Error.AbortError("Command invocation stopped because user was not able to fulfill login requirements for the command within " + count + " attempts.");

	    // depending on presence of login parameters, either perform the log-in or just use the current user (even if not logged in)
	    var usedLoginParams = Object.assign({}, loginParams, extraLoginParams);
	    return (Object.keys(usedLoginParams).length > 0 ? session._login(usedLoginParams, true) : Promise.resolve(session)).catch(function (e) {
	      // if user login failed then abort or throw
	      if (e === false) throw new UuApp.Error.AbortError("Command invocation stopped because user refused to log in.");
	      throw new UuApp.Error.Error("Command invocation stopped because of a login error.", e);
	    }).then(function (session) {
	      var isAuthenticated = session.isAuthenticated();
	      if (isAuthenticated) {
	        var baseUri = request.uri.baseUri;
	        return Promise.resolve(session.getCallToken(baseUri.toString())).then(function (callToken) {
	          return { isAuthenticated: isAuthenticated, callToken: callToken };
	        });
	      }
	      return { isAuthenticated: isAuthenticated, callToken: null };
	    }).then(function (data) {
	      var isAuthenticated = data.isAuthenticated;
	      var callToken = data.callToken;
	      var authToken = callToken ? callToken.token : null;
	      if (authToken) request.headers["authorization"] = [callToken.tokenType || "Bearer", authToken].join(" ");
	      return nextInterceptorFn(request, options).catch(function (response) {
	        // check for special response values in WWW-Authenticate response header which indicates
	        // that we shall run login procedure with additional parameters and then try again the same command
	        var wwwAuthenticate = response.headers("www-authenticate");
	        if (wwwAuthenticate) {
	          var valueMap = {};
	          wwwAuthenticate.replace(/^\S+\s+/, "").split(/,/).map(function (it) {
	            return it.trim();
	          }).forEach(function (it) {
	            // remove "Bearer "
	            var idx = it.indexOf("=");
	            var key = decodeUriWithPlus(idx == -1 ? it : it.substr(0, idx));
	            var value = decodeUriWithPlus(idx == -1 ? "" : it.substr(idx + 1));
	            valueMap[key] = decodeUriWithPlus(value);
	          });

	          var relevantValues = Object.keys(valueMap).filter(function (key) {
	            return key.match(/^(max_age|acr_values|prompt|scope)$/);
	          }).reduce(function (r, k) {
	            return r[k] = valueMap[k], r;
	          }, {});
	          // if there's any of relevant keys in the WWW-Authenticate response header then
	          // re-run the whole OIDC Handler with those values sent to login
	          if (Object.keys(relevantValues).length > 0) return runWith(relevantValues);

	          // OI if we weren't logged in at the time of invocation and there's wwwAuthenticate then re-run also
	          if (!isAuthenticated) return runWith({ acr_values: "1" }); // require non-anonymous
	        }
	        return Promise.reject(response);
	      });
	    });
	  }
	  return runWith(null);
	}

	function decodeUriWithPlus(txt) {
	  return decodeURIComponent(txt.replace(/\+/g, " "));
	}

/***/ }
/******/ ])
});
;