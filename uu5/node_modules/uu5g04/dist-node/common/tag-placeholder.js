import React from 'react';
import BaseMixin from './base-mixin.js';
import ElementaryMixin from './elementary-mixin.js';
import Tools from './tools.js';
import Environment from '../environment/environment.js'

//import './tag-placeholder.less';

export const TagPlaceholder = React.createClass({

  //@@viewOn:mixins
  mixins: [
    BaseMixin,
    ElementaryMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: 'UU5.Common.TagPlaceholder',
    classNames: {
      main: 'uu5-bricks-tag-placeholder'
    },
    errors: {
      serverError: 'Unexpected error: %s.'
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    tagName: React.PropTypes.string,
    props: React.PropTypes.object,
    content: React.PropTypes.object,
  },
  //@@viewOff:propTypes
  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      tagName: null,
      props: null,
      content: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState(){
    return {
      component: null
    }
  },

  componentDidMount(){
    this._findLib();
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _findLib(){
    let tagNameArr = this.props.tagName.split('.');
    let libraryName = tagNameArr[0] + '.' + tagNameArr[1];

    let library = Environment.getLibrary(libraryName);

    if (library && library.error) {
      this._setComponent(null, {tagName: this.props.tagName});
    } else {
      let dtoIn = {
        code: libraryName
      };
      library && library.version && (dtoIn.version = library.version);

      let url = Environment.COMPONENT_REGISTRY_URL;
      let query = Tools.encodeQuery(dtoIn);
      url += query;

      if (!Environment.tagCalls[query]) {
        Environment.tagCalls[query] = [this._setComponent.bind(this, this.props.tagName)];

        let request = new XMLHttpRequest();
        request.onreadystatechange = () => {
          if (request.readyState == XMLHttpRequest.DONE) {
            let tagCalls = Environment.tagCalls[query];
            delete Environment.tagCalls[query];

            if (request.status == 200) {
              let response = JSON.parse(request.response);
              this._importLibrary(response, response.dependencies, tagCalls);
            }
            else {
              this.showError('serverError', request.response, {
                  component: this.getTagName(),
                  searchedTag: this.props.tagName,
                  library: library || libraryName
                }
              );
              this._setLibError(libraryName);
              this._setNotFound(tagCalls);
            }
          }
        };
        request.open('GET', url, true);
        request.setRequestHeader("Content-Type", "application/json");
        request.send(JSON.stringify(dtoIn));

      } else {
        Environment.tagCalls[query].push(this._setComponent.bind(this, this.props.tagName));
      }
    }

    return this;
  },

  _getSourceUrl(library) {
    let result;
    if (library && library.name && library.version) {
      let baseName = library.name.replace('_basic', '').replace('_forms', '');
      let sourceName = library.name.replace('uu_', '');
      result = Environment.CDN_URL + '/' + baseName + '/' + library.version + '/' + sourceName + '.js';
    }
    return result;
  },

  _setComponent(tagName, props) {
    let component = (tagName && Tools.checkTag(tagName)) || Tools.checkTag('UU5.Bricks.NotFoundTag');
    component && this.setState({
      component: React.createElement(component, props || this.props.props, this.props.content)
    });
    return this;
  },

  _setNotFound(tagCalls) {
    // fce = this._setComponent (first param is bound in pushing into tagCalls)
    tagCalls.forEach(fce => fce({tagName: this.props.tagName}));
    return this;
  },

  _setLibError(libCode) {
    let libSettings = Environment.getLibrary(libCode);
    if (libSettings) {
      libSettings.error = true;
    } else {
      Environment.addLibrary(libCode, {error: true});
    }
    return this;
  },

  _getVersionFromUrl(url){
    let version;
    version = url.match(/\/\d*\.\d*\.\d*\//g);
    version[0] && (version = version[0].replace(/\//g, ''));
    return version;
  },

  _getVersionObject(version){
    let ver = version.split('.');
    return {
      major: parseInt(ver[0]),
      minor: parseInt(ver[1]),
      build: parseInt(ver[2])
    }
  },

  _compareDependencies(version, dependency){
    let result = true;
    let dependencyVersion;

    if(/^\d/g.test(dependency)) {
      dependencyVersion = dependency;
    } else {
      dependencyVersion = this._getVersionFromUrl(dependency);
    }

    if (dependencyVersion && version !== dependencyVersion) {

      let ver = this._getVersionObject(version);
      let verDep = this._getVersionObject(dependencyVersion);

      if (ver.major !== verDep.major) { // 1.0.0 x 2.0.0 || 1.0.0 x 0.1.1
        result = false;
      } else if (ver.minor < verDep.minor) { // 1.0.0 x 1.1.0
        result = false;
      } else if (ver.minor === verDep.minor && ver.build < verDep.build) { // 1.0.0 x 1.0.1
        result = false;
      }

      if (!result) {
        this._setDependencyError(version, dependencyVersion);
      }
    }

    return true;
  },

  _setDependencyError(version, dependencyVersion) {
    Tools.error('Wrong dependency.', {
      tag: this.props.tagName,
      ver: version,
      dependencyVersion: dependencyVersion
    });

    return this;
  },

  _updateDependencies(dependencies) {
    if (dependencies['uu5g04'] && this._compareDependencies(Environment.version, dependencies['uu5g04'])) {
      delete dependencies['uu5g04'];
    }
    if (window.Plus4U5 && dependencies['plus4u5g01'] && this._compareDependencies(window.Plus4U5.Environment.version, dependencies['plus4u5g01'])) {
      delete dependencies['plus4u5g01'];
    }

    Object.keys(dependencies).forEach((key) =>{
      if(/^\d/g.test(dependencies[key])) {
        let library = {
          name: key,
          version: dependencies[key]
        };
        let source = this._getSourceUrl(library);
        source && (dependencies[key] = source);
      }
    });

    return dependencies;
  },

  _importLibrary(library, dependencies, tagCalls) {
    let source = library.source;
    if (!source) {
      source = this._getSourceUrl(library);
    }

    if (window.System && window.System.import) {
      if (source) {
        System.config({map: this._updateDependencies(dependencies)});

        System.import(source).then(() => {
          tagCalls.forEach(fce => fce());
        });
      } else {
        Tools.error('System was not found and has not set any source to import.', {
          source: source,
          tagName: this.props.tagName
        });
        this._setLibError(library.code);
        this._setNotFound(tagCalls);
      }
    } else {
      Tools.error('System is not defined in window! Cannot import source:', {
        source: source,
        tagName: this.props.tagName
      });
      this._setLibError(library.code);
      this._setNotFound(tagCalls);
    }
    return this;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return this.state.component;
  }
  //@@viewOff:render
});

export default TagPlaceholder;
