import React from 'react';

import InputMixin from './input-mixin.js'

import Option from './../select-option.js';

export const TextInputMixin = {

  //@@viewOn:mixins
  mixins: [InputMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    UU5_Forms_TextInputMixin: {
      classNames: {
        main: 'uu5-forms-text-input',
        item: 'uu5-forms-auto-complete-item list-group-item',
      }
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    placeholder: React.PropTypes.oneOfType([
      React.PropTypes.object,
      React.PropTypes.string
    ]),
    required: React.PropTypes.bool,
    requiredMessage: React.PropTypes.any,
    focusMessage: React.PropTypes.any,
    autocompleteItems: React.PropTypes.arrayOf(
      React.PropTypes.shape({
        value: React.PropTypes.string,
        params: React.PropTypes.object,
        content: React.PropTypes.any
      })
    ),
    onFocus: React.PropTypes.func,
    onBlur: React.PropTypes.func,
    onEnter: React.PropTypes.func,
    validateOnChange: React.PropTypes.bool
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps: function () {
    return {
      placeholder: null,
      required: false,
      requiredMessage: 'This field is required.',
      focusMessage: null,
      autocompleteItems: null,
      onFocus: null,
      onBlur: null,
      onEnter: null,
      validateOnChange: false
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      autocompleteItems: this.props.autocompleteItems,
      foundAutocompleteItems: null,
      selectedIndex: null
    }
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      this.setState({autocompleteItems: nextProps.autocompleteItems});
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  isValid: function () {
    var feedback = this.getFeedback();
    var value = this.getValue();
    var result = true;

    if (this.props.required && (value === '' || value === null)) {
      this.setError(this.props.requiredMessage);
      result = false;
    } else if (feedback === 'error') {
      result = false;
    } else if (typeof this.isValid_ === 'function') {
      result = this.isValid_();
    }

    if (result && this.props.onValidate) {
      var validation = this.props.onValidate({value: value, component: this});
      if (validation && typeof validation === 'object') {
        if (validation.feedback === 'error') {
          result = false;
        }
      }
    }

    return result;
  },

  getFocusFeedback(){
    let value;
    if (this.isInitial() && this.props.focusMessage) {
      value = {
        message: this.props.focusMessage,
        value: this.state.value,
        feedback: 'initial'
      }
    }
    return value;
  },

  getBlurFeedback(opt){
    let result;
    if (typeof this.props.onValidate === 'function') {
      result = this.props.onValidate(opt);
    } else {
      result = {
        feedback: opt.required ? 'success' : this.state.feedback,
        message: this.state.feedback ? this.state.message : null,
        value: opt.value
      }
    }
    return result;
  },

  setAutoCompleteItems(items, opt, setStateCallback) {
    opt = opt || {};

    opt.autocompleteItems = items;
    opt.value = opt.value || this.state.value;
    let result = this.getChangeFeedback(opt);

    this.setState({
      autocompleteItems: items,
      feedback: result.feedback,
      message: result.message,
      value: result.value,
      foundAutocompleteItems: result.foundAutocompleteItems,
      selectedIndex: result.selectedIndex
    }, setStateCallback);

    return this;
  },

  onFocus(e){
    let opt = {value: e.target.value, event: e, component: this};
    if (typeof this.props.onFocus === 'function') {
      this.props.onFocus(opt);
    } else {
      let result = this.getFocusFeedback(opt);
      result && this.setFeedback(result.feedback, result.message, result.value)
    }

    return this;
  },

  onChange(e){
    let opt = {value: e.target.value, event: e, component: this};

    if (!this.isDisabled() && !this.isReadOnly()) {
      if (typeof this.props.onChange === 'function') {
        this.props.onChange(opt);
      } else if (this.props.validateOnChange) {
        this._validateOnChange(opt);
      } else {
        let result = this.getChangeFeedback(opt);
        this.setState({
          feedback: result.feedback,
          message: result.message,
          value: result.value,
          foundAutocompleteItems: result.foundAutocompleteItems,
          selectedIndex: result.selectedIndex
        });
      }
    }

    return this;
  },

  onBlur(e){
    let opt = {value: e.target.value, event: e, component: this};

    if (typeof this.props.onBlur === 'function') {
      this.props.onBlur(opt);
    } else {
      if (this._checkRequired({value: opt.value}) && !this.props.validateOnChange) {
        opt.required = this.props.required;
        let blurResult = this.getBlurFeedback(opt);
        this.setFeedback(blurResult.feedback, blurResult.message, blurResult.value);
      }
    }

    return this;
  },

  onKeyDown(e, param){
    let opt = {value: e.target.value, event: e, component: this};

    // param is user function passed to inputAttrs.onKeyDown
    if (typeof param === 'function') {
      param(e, opt);
    }

    if (typeof this.props.onEnter === 'function' && (e.keyCode || e.which) === 13 && !e.shiftKey && !e.ctrlKey) {
      this.props.onEnter(opt);
    }

    return this;
  },

  // find: function (foundValue, setStateCallback) {
  //   var values = {first: [], last: []};
  //   this.props.items.forEach(function (item) {
  //     if (foundValue !== '') {
  //       if (new RegExp('^' + foundValue, 'i').exec(item.value)) {
  //         values.first.push(item);
  //       } else if (new RegExp(foundValue, 'gi').exec(item.value)) {
  //         values.last.push(item);
  //       }
  //     }
  //   });
  //   var allValues = values.first.concat(values.last);
  //   this.setState({items: allValues.length ? allValues : null, selectedIndex: null}, setStateCallback);
  //   return this;
  // },

  isOpen () {
    let result = false;
    if (typeof this.isOpen_ === 'function') {
      result = this.isOpen_();
    } else {
      result = !!this.state.foundAutocompleteItems;
    }
    return result;
  },

  close: function (setStateCallback) {
    if (typeof this.close_ === 'function') {
      this.close_(setStateCallback);
    } else {
      this.setState({foundAutocompleteItems: null, selectedIndex: null, open: false}, setStateCallback);
    }
    return this;
  },

  //@@viewOff:interface

  //@@viewOn:overridingMethods
  getChangeFeedback_(opt) {
    let foundedItems = null;
    let selectedIndex = this.state.selectedIndex;

    if (opt.autocompleteItems || this.state.autocompleteItems) {
      foundedItems = this._find(opt.autocompleteItems || this.state.autocompleteItems, opt.value);
      selectedIndex = null;
    }

    return {
      feedback: opt.feedback || (opt.required ? InputMixin.SUCCESS_FEEDBACK : InputMixin.INITIAL_FEEDBACK),
      message: opt.message || null,
      value: opt.value === undefined ? this.state.value : opt.value,
      foundAutocompleteItems: foundedItems,
      selectedIndex: selectedIndex
    };
  },

  setChangeFeedback_(opt, setStateCallback) {
    let result = this.getChangeFeedback(opt);

    this.setState({
      feedback: result.feedback,
      message: result.message,
      value: result.value,
      foundAutocompleteItems: result.foundAutocompleteItems,
      selectedIndex: result.selectedIndex
    }, setStateCallback);

    return this;
  },
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _checkRequired(opt) {
    let result = true;
    if (this.props.required && !opt.value) {
      result = false;
      this.setError(this.props.requiredMessage, opt.value);
    }

    return result;
  },

  _find(items, foundValue) {
    let values = {first: [], last: []};
    items.forEach(function (item) {
      if (foundValue !== '') {
        if (new RegExp('^' + foundValue, 'i').exec(item.value)) {
          values.first.push(item);
        } else if (new RegExp(foundValue, 'gi').exec(item.value)) {
          values.last.push(item);
        }
      }
    });
    let allValues = values.first.concat(values.last);

    return allValues.length ? allValues : null;
  },

  _getBackdropProps () {
    var backdropId = this.getId() + "-backdrop";

    return {
      hidden: !this.isOpen(),
      id: backdropId,
      onClick: () => this.close()
    };
  },

  _getItemListProps(){
    let props = {};

    props.hidden = !this.isOpen();
    props.ref = (itemList) => this._itemList = itemList;
    props.onChange = (opt) => {
      let value = '';
      if (opt.value !== null) {
        value = this.state.foundAutocompleteItems[opt.value].value;
      }

      // TODO: how to do custom onChange, but items should be hidden because of this path is after choosing some item
      // if (typeof this.props.onChange === 'function') {
      //   opt.component = this;
      //   opt.value = value;
      //   this.setState({ foundAutocompleteItems: null, selectedIndex: null }, () => this.props.onChange(opt));
      // } else {
      this.setState({value: value, foundAutocompleteItems: null, selectedIndex: null}, ()=>{
        if(typeof this.props.onBlur === 'function'){
            this.props.onBlur({value: value, component: this})
        }
      });
      // this.close(() => this.setValue(result));
      // }
    };






    props.value = this.state.value;

    return props;
  },

  _getChildren () {
    return this.state.foundAutocompleteItems && this.state.foundAutocompleteItems.map((item, i) => {
        let className = this.getClassName().item;
        this.state.selectedIndex === i && (className += ' ' + this.getClassName().selected);
        return (
          <Option
            className={className}
            key={i}
            value={item.content || item.value}
            content={item.content || item.value}
            mainAttrs={{id: this.getId() + '-item-' + i}}
          />
        );
      });
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  //@@viewOff:render
};

export default TextInputMixin;
