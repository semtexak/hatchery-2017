import React from 'react';
import {BaseMixin, ElementaryMixin, Tools} from './../common/common.js';


import InputWrapper from './internal/input-wrapper.js';
import TextInput from './internal/text-input.js';

import TextInputMixin from './mixins/text-input-mixin.js'

import ItemList from './internal/item-list.js';
import Backdrop from './../bricks/backdrop.js';

import './text-button.less';

export const TextButton = React.createClass({

  //@@viewOn:mixins
  mixins: [
    BaseMixin,
    ElementaryMixin,
    TextInputMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: 'UU5.Forms.TextButton',
    classNames: {
      main: 'uu5-forms-text-button'
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    value: React.PropTypes.string,
    buttons: React.PropTypes.arrayOf(React.PropTypes.shape({
        glyphicon: React.PropTypes.string,
        onClick: React.PropTypes.func,
        colorSchema: React.PropTypes.string
      })
    )
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps () {
    return {
      value: '',
      buttons: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  componentWillMount(){
    if (this.props.onValidate && typeof this.props.onValidate === 'function') {
      this._validateOnChange({value: this.state.value, event: null, component: this})
    }

    return this;
  },

  componentWillReceiveProps(nextProps) {
    if (this.props.controlled) {
      if(nextProps.required && (nextProps.value === '' || nextProps.value === null)) {
        this.setError(nextProps.requiredMessage);
      } else {
        this.setFeedback(nextProps.feedback, nextProps.message, nextProps.value)
      }
    }
    return this;
  },

  shouldComponentUpdate(nextProps, nextState) {
    return this.shouldRender(nextProps, nextState);
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  // TODO: tohle je ještě otázka - je potřeba nastavit hodnotu z jiné komponenty (musí být validace) a z onChange (neměla by být validace)
  setValue_(value, setStateCallback){
    if (this._checkRequired({value: value})) {
      if (typeof this.props.onValidate === 'function') {
        this._validateOnChange({value: value, event: null, component: this})
      } else {
        this.props.required ? this.setSuccess(null, value, setStateCallback) : this.setInitial(null, value, setStateCallback);
      }
    }

    return this;
  },
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _onFocus(e){
    let opt = {value: e.target.value, event: e, component: this};

    this._onFocusButton(opt);

    return this;
  },

  _onFocusButton(opt){
    if (typeof this.props.onFocus === 'function') {
      this.props.onFocus(opt);
    } else {
      let result = this.getFocusFeedback(opt);
      result && this.setFeedback(result.feedback, result.message, result.value)
    }

    return this;
  },

  _validateOnChange(opt){
    let result = typeof this.props.onValidate === 'function' ? this.props.onValidate(opt) : null;
    if (result) {
      if (typeof result === 'object') {
        if (result.feedback) {
          this.setFeedback(result.feedback, result.message, result.value);
        } else {
          this.setState({value: opt.value});
        }
      } else {
        this.showError('validateError', null, {context: {event: e, func: this.props.onValidate, result: result}});
      }
    }
    return this;
  },

  _getFeedbackIcon(){
    let icon = this.props.required ? this.props.successGlyphicon : null;
    switch (this.getFeedback()) {
      case 'success':
        icon = this.props.successGlyphicon;
        break;
      case 'warning':
        icon = this.props.warningGlyphicon;
        break;
      case 'error':
        icon = this.props.errorGlyphicon;
        break;
    }
    return icon;
  },

  _getButtons(){
    let result = [];
    if (!this.isReadOnly()) {
      this.props.buttons && this.props.buttons.map((button, key)=> {
        let newButton = Tools.merge({}, button);
        if (typeof button.onClick === 'function') {
          newButton.onClick = ()=> {
            this._onFocusButton({value: this.state.value, component: this})
            button.onClick({value: this.state.value, component: this})
          };
        }
        if (this.isDisabled()) {
          newButton.disabled = true;
        }
        result.push(newButton);
      });
    }

    return result;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render () {
    let inputId = this.getId() + '-input';

    return (
      <div {...this._getInputAttrs()}>
        {this.getLabel(inputId)}
        {this.getInputWrapper([
            <TextInput
              id={inputId}
              name={this.props.name || inputId}
              value={this.state.value}
              placeholder={this.props.placeholder}
              type='text'
              onChange={this.onChange}
              onBlur={this.onBlur}
              onFocus={this._onFocus}
              onKeyDown={this.onKeyDown}
              mainAttrs={this.props.inputAttrs}
              disabled={this.isDisabled() || this.isLoading()}
              readonly={this.isReadOnly()}
              glyphicon={this._getFeedbackIcon()}
              loading={this.isLoading()}
            />,

          this.state.autocompleteItems && <ItemList {...this._getItemListProps()}>
            {this._getChildren()}
          </ItemList>,
          this.state.autocompleteItems && <Backdrop {...this._getBackdropProps()} />],
          this._getButtons())}
      </div>
    );
  }
  //@@viewOn:render
});

export default TextButton;
