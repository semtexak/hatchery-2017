import React from 'react';
import BaseMixin from './../common/base-mixin.js';
import ElementaryMixin from './../common/elementary-mixin.js';
import Tools from './../common/tools.js';
import Environment from './../environment/environment.js';

import Backdrop from './../bricks/backdrop.js';

import InputWrapper from './internal/input-wrapper.js';
import TextInput from './internal/text-input.js';
import Calendar from './calendar.js';
import Time from './time.js';

import TextInputMixin from './mixins/text-input-mixin.js'

import './datetimepicker.less';

const FORMAT_AM = 'AM';
const FORMAT_PM = 'PM';
const FORMAT_12 = '12';
const FORMAT_24 = '24';
export const Datetimepicker = React.createClass({

  //@@viewOn:mixins
  mixins: [
    BaseMixin,
    ElementaryMixin,
    TextInputMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: 'UU5.Forms.Datetimepicker',
    classNames: {
      main: 'uu5-forms-datetimepicker',
      datepickerOpen: 'uu5-forms-datepicker-open',
      timepickerOpen: 'uu5-forms-timepicker-open',
      menu: 'uu5-forms-input-menu'
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    value: React.PropTypes.oneOfType([
      React.PropTypes.instanceOf(Date),
      React.PropTypes.string
    ]),
    dateFrom: React.PropTypes.oneOfType([
      React.PropTypes.instanceOf(Date),
      React.PropTypes.string
    ]),
    dateTo: React.PropTypes.oneOfType([
      React.PropTypes.instanceOf(Date),
      React.PropTypes.string
    ]),
    buttonHidden: React.PropTypes.bool,
    calendarGlyphiconOpen: React.PropTypes.string,
    calendarGlyphiconClosed: React.PropTypes.string,
    timeGlyphiconOpen: React.PropTypes.string,
    timeGlyphiconClosed: React.PropTypes.string,
    format: React.PropTypes.string,
    country: React.PropTypes.string,
    timezone: React.PropTypes.string,
    nanMessage: React.PropTypes.any,
    beforeRangeMessage: React.PropTypes.any,
    afterRangeMessage: React.PropTypes.any,
    parseDate: React.PropTypes.func,
    placeholderTime: React.PropTypes.string
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps () {
    return {
      value: null,
      dateFrom: null,
      dateTo: null,
      isButtonHidden: false,
      calendarGlyphiconOpen: 'uu-glyphicon-calendar',
      calendarGlyphiconClosed: 'uu-glyphicon-calendar',
      timeGlyphiconOpen: 'uu-glyphicon-arrow-up',
      timeGlyphiconClosed: 'uu-glyphicon-arrow-down',
      format: null,
      country: null,
      nanMessage: 'Please insert a valid date.',
      beforeRangeMessage: 'Date is out of range.',
      afterRangeMessage: 'Date is out of range.',
      parseDate: null,
      placeholderTime: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState () {
    return {
      calendarOpen: false,
      timeOpen: false,
      format: this.props.format,
      country: this.props.country,
      timezone: this.props.timezone,
      dateString: this._getDateString() || null,
      timeString: this._getTimeString() || null
    };
  },

  componentWillMount(){
    if (this.props.onValidate && typeof this.props.onValidate === 'function') {
      let result = this._isValidDateResult({value: this.state.dateString});
      //let result = this._isValidTimeResult({value: this.state.timeString});
      //TODO: validovat datum i cas
      if (result) {
        if (typeof result === 'object') {
          if (result.feedback) {
            this.setFeedback(result.feedback, result.message, result.value);
          } else {
            this._validateOnChange({value: this.state.value, event: null, component: this})
          }
        }
      }
    } else {
      this.setInitial(null, this.state.value)
    }
    return this;
  },

  componentDidMount() {
    Environment.EventListener.registerDateTime(this.getId(), this._change);
  },

  componentWillReceiveProps(nextProps) {
    if (this.props.controlled) {
      let date = nextProps.value instanceof Date ? nextProps.value : new Date(nextProps.value);
      let result = this._isValidDateResult({value: date});
      if (result) {
        if (typeof result === 'object') {
          if (result.feedback) {
            this.setFeedback(result.feedback, result.message, result.value);
          } else {
            this.setFeedback(nextProps.feedback, nextProps.message, nextProps.value)
          }
        }
      }
    }
    return this;
  },

  componentWillUnmount() {
    Environment.EventListener.unregisterDateTime(this.getId(), this._change);
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  openCalendar (setStateCallback) {
    this.setState({calendarOpen: true}, setStateCallback);
    return this;
  },

  openTime (setStateCallback) {
    this.setState({timeOpen: true}, setStateCallback);
    return this;
  },

  toggleCalendar (setStateCallback) {
    this.setState((state) => ({calendarOpen: !state.calendarOpen}), setStateCallback);
    return this;
  },

  toggleTime (setStateCallback) {
    this.setState((state) => ({timeOpen: !state.timeOpen}), setStateCallback);
    return this;
  },

  // parseDate (stringDate) {
  //   var config = {
  //     "^(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})$": '$3-$2-$1',
  //     "^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$": '$3-$1-$2',
  //     "^(\\d{4})-(\\d{1,2})-(\\d{1,2})$": '$1-$2-$3'
  //   };
  //
  //   var date = null;
  //   if (stringDate) {
  //     stringDate = stringDate.replace(/ /g, '');
  //
  //     for (var pattern in config) {
  //       var regExp = new RegExp(pattern);
  //       if (regExp.test(stringDate)) {
  //         var replacedDate = stringDate.replace(regExp, config[pattern]);
  //         var splitter = replacedDate.split('-');
  //         //splitter[1] = Tools.rjust(splitter[1], 2, '0');
  //         //splitter[2] = Tools.rjust(splitter[2], 2, '0');
  //         //replacedDate = splitter.join('-');
  //         splitter[0] = Number(splitter[0]);
  //         splitter[1] = Number(splitter[1]) - 1;
  //         splitter[2] = Number(splitter[2]);
  //
  //         date = new Date(splitter[0], splitter[1], splitter[2]);
  //         break;
  //       }
  //     }
  //   }
  //   return date;
  // },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  getValue_(){
    return this._getValue();
  },

  setFeedback_(feedback, message, value, setStateCallback){
    let timeString = this._getTimeString(value);
    let dateString = this._getDateString(value);
    if (this.state.dateString !== dateString || this.state.timeString !== timeString) {
      this.setState({
        dateString: dateString,
        timeString: timeString,
        feedback: feedback,
        message: message
      }, () => setStateCallback);
    } else {
      this.setState({
        feedback: feedback,
        message: message
      }, () => setStateCallback);
    }
    return this;
  },

  _getValue(date, time){
    let value;
    date = date instanceof Date ? date : this._parseDate(date ? date : this.state.dateString);
    //time = typeof time === 'object' ? (time.hours + ':' + time.minutes) : this._parseTime(time ? time : this.state.timeString);
    time = typeof time === 'object' ? time : this._parseTime(time ? time : this.state.timeString);
    date && (value = new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.hours, time.minutes));
    return value;
  },

  setValue_(value, setStateCallback){
    // if (value instanceof Date) {
    //   value = this._formatDate(value);
    // }
    if (this._checkRequired({value: value})) {
      if (typeof this.props.onValidate === 'function') {
        this._validateOnChange({value: value, event: null, component: this});
      } else {
        this.props.required ? this.setSuccess(null, value, setStateCallback) : this.setInitial(null, value, setStateCallback);
      }
    }

    this.setState({
      value: value,
      dateString: this._getDateString(value),
      timeString: this._getTimeString(value)
    });

    return this;
  },

  close_(setStateCallback){
    if (this._isTimeOpen()) {
      this._onBlurTime(null, {value: this.state.timeString || '', component: this});
    }
    if (this._isCalendarOpen()) {
      this._onBlurCalendar(null, {value: this.state.dateString || '', component: this});
    }

    this.setState({calendarOpen: false, timeOpen: false}, setStateCallback);
    return this;
  },

  _isCalendarOpen(){
    return this.state.calendarOpen;
  },

  _isTimeOpen(){
    return this.state.timeOpen;
  },

  isOpen_(){
    return this._isCalendarOpen() || this._isTimeOpen();
  },
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getDateString(date){
    let dateString;
    date = date || this.props.value;
    if (typeof date === 'string') {
      date = new Date(date);
    }
    if (date) {
      if (date instanceof Date) {
        let newDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        dateString = this._formatDate(newDate)
      }
    }
    return dateString;
  },

  _getTimeString(date){
    let timeString;
    date = date || this.props.value;
    if (typeof date === 'string') {
      date = new Date(date);
    }
    if (date) {
      if (date instanceof Date) {
        timeString = this._formatTime({hours: date.getHours(), minutes: date.getMinutes()}, true);
      }
    }
    return timeString;
  },

  _change(opt) {
    if (typeof this.props.onChange === 'function') {
      this.props.onChange(opt);
    } else {
      this._setOptions(opt);
    }
    return this;
  },

  _setOptions(opt, setStateCallback) {
    this.setState({
      format: opt.format === undefined ? this.state.format : opt.format,
      country: opt.country === undefined ? this.state.country : (opt.country ? opt.country.toLowerCase() : opt.country),
    }, setStateCallback);
    return this;
  },

  _onChangeCalendar(e){
    let opt = {value: e.target.value, event: e, component: this};
    let date = this._parseDate(opt.value);
    let formatedDate = date ? this._formatDate(date) : null;
    if (formatedDate) {
      opt.value = formatedDate;
      if (!this.isDisabled() && !this.isReadOnly()) {
        if (typeof this.props.onChange === 'function') {
          this.props.onChange(opt);
        } else {
          if (this.props.validateOnChange) {
            this._validateOnChange(opt);
          } else {
            if (opt.value && this._checkRequired({value: opt.value})) {
              opt.required = this.props.required;
              let result = this.getChangeFeedback(opt);
              this.setState({
                feedback: result.feedback,
                message: result.message,
                dateString: result.value || ''
              });
            }
          }
        }
      }
    } else {
      this.setState({dateString: opt.value});
    }
    return this;
  },

  _onChangeTime(e){
    let opt = {value: e.target.value, event: e, component: this};

    if (opt.value === '' || this._parseTime(opt.value)) {
      if (!this.isDisabled() && !this.isReadOnly()) {
        if (typeof this.props.onChange === 'function') {
          this.props.onChange(opt);
        } else {
          if (this.props.validateOnChange) {
            this._validateOnChange(opt);
          } else {
            if (opt.value === '') {
              this.setState({timeString: opt.value});
            } else if (this._checkRequired({value: opt.value})) {
              opt.required = this.props.required;
              let result = this.getChangeFeedback(opt);

              if (!result.value ||
                (this.props.format === FORMAT_12 && result.value.match(/^\d{1,2}:?\d{0,2} ?[PpAa]?\.?[Mm]?\.?$/)) ||
                (this.props.format === FORMAT_24 && result.value.match(/^\d{1,2}:?\d{0,2}$/))) {
                this.setState({
                  feedback: result.feedback,
                  message: result.message,
                  timeString: result.value || ''
                });
              } else {
                this.setState({timeString: result.value});
              }
            }
          }
        }
      }
    }

    return this;
  },

  _onBlurCalendar(e, opt){
    opt = (opt && opt.value || !e) ? opt : {value: e.target.value, event: e, component: this};


    if (typeof this.props.onBlur === 'function') {
      this.props.onBlur(opt);
    } else {
      if (this._checkRequiredDatetime({value: opt.value || this.state.dateString}) && !this.props.validateOnChange) {
        opt.required = this.props.required;
        let blurResult = this.getBlurFeedback(opt);
        let result = this._isValidDateResult(blurResult);
        this.setState({
          feedback: result.feedback,
          message: result.message,
          dateString: result.value
        });
      }
    }

    return this;
  },

  _onBlurTime(e, opt){
    opt = (opt && opt.value || !e) ? opt : {value: e.target.value, event: e, component: this};


    if (typeof this.props.onBlur === 'function') {
      this.props.onBlur(opt);
    } else {
      if (this._checkRequiredDatetime({value: opt.value || this.state.timeString}) && !this.props.validateOnChange) {
        opt.required = this.props.required;
        let blurResult = this.getBlurFeedback(opt);
        let result = this._isValidTimeResult(blurResult);
        this.setState({
          feedback: result.feedback,
          message: result.message,
          timeString: opt.value ? this._formatTime(this._parseTime(blurResult.value), true) : ''
        });
      }
    }

    return this;
  },

  _checkRequiredDatetime(opt) {
    let result = true;
    if (this.props.required && !opt.value) {
      result = false;
      this.setState({
        feedback: 'error',
        mesage: this.props.requiredMessage
      });
    }

    return result;
  },

  _isValidDateResult(opt){
    return this._validateDateRangeResult(this._validateDateResult(opt));
  },

  _validateDateResult(opt){
    let result = opt;
    let date = opt.value instanceof Date ? opt.value : this._parseDate(opt.value);
    if (!this.state.timeString || !date && opt.value) {
      result.feedback = 'error';
      result.message = this.props.nanMessage;
    }
    return result;
  },

  _isValidTimeResult(opt){
    let result = opt;
    let time = this._parseTime(opt.value);
    if (!this.state.dateString || !time && opt.value) {
      result.feedback = 'error';
      result.message = this.props.nanMessage;
    }
    return result;
  },

  _validateDateRangeResult(opt){
    let result = opt;

    let date = opt.value instanceof Date ? this._getDateString(opt.vale) : this._parseDate(opt.value);
    if (date) {
      let dateFrom = this._parseDate(this.props.dateFrom);
      let dateTo = this._parseDate(this.props.dateTo);
      if (dateFrom && date < dateFrom) {
        result.feedback = 'error';
        result.message = this.props.beforeRangeMessage;
      } else if (dateTo && date > dateTo) {
        result.feedback = 'error';
        result.message = this.props.afterRangeMessage;
      }
    }

    return result;
  },

  _validateOnChange(opt){
    let result = typeof this.props.onValidate === 'function' ? this.props.onValidate(opt) : null;
    if (result) {
      if (typeof result === 'object') {
        if (result.feedback) {
          this.setFeedback(result.feedback, result.message, result.value);
        } else {
          this.setState({value: opt.value});
        }
      } else {
        this.showError('validateError', null, {context: {event: e, func: this.props.onValidate, result: result}});
      }
    } else if (this.props.required && this.state.value) {
      this.setSuccess(null, this.state.value)
    }
    return this;
  },

  _getFeedbackIcon(){
    let icon = this.props.required ? this.props.successGlyphicon : null;
    switch (this.getFeedback()) {
      case 'success':
        icon = this.props.successGlyphicon;
        break;
      case 'warning':
        icon = this.props.warningGlyphicon;
        break;
      case 'error':
        icon = this.props.errorGlyphicon;
        break;
    }
    return icon;
  },

  _onCalendarChange (opt) {
    if (typeof this.props.onChange === 'function') {
      opt.value = this._getValue(opt.value, this.state.timeString);
      opt.component = this;
      this.setState({calendarOpen: false}, this.props.onChange(opt));
    } else {
      //TODO: setValue_
      let value = this._formatDate(opt.value);
      this.setState({calendarOpen: false, dateString: value}, () => this._onBlurCalendar(null, {
        value: value,
        component: this
      }));
    }
    return this;
  },

  _getCalendarProps() {
    let date = typeof this.getValue() === 'string' ? this._parseDate(this.getValue()) : this.getValue();

    return {
      className: this.getClassName().menu,
      date: date,
      dateFrom: this.props.dateFrom ? this._parseDate(this.props.dateFrom) : null,
      dateTo: this.props.dateTo ? this._parseDate(this.props.dateTo) : null,
      ref_: this._refCalendar,
      hidden: !this._isCalendarOpen(),
      onChange: this._onCalendarChange
    };
  },

  _onTimeChange(opt) {
    if (typeof this.props.onChange === 'function') {
      opt.component = this;
      opt.value = this._getValue(this.state.dateString, opt.value);
      this.props.onChange(opt);
    } else {
      //TODO: setValue_
      let value = this._formatTime(opt.value, true);
      this.setState({timeString: value}, () => this._onBlurTime(null, {value: value, component: this}));
    }
    return this;
  },

  _getTimeProps(value) {
    return {
      className: this.getClassName().menu,
      value: value,
      ref_: this._refCalendar,
      hidden: !this._isTimeOpen(),
      onChange: this._onTimeChange,
      format: this.props.format,
      controlled: true
    };
  },

  _formatTime(value, fill0) {
    let time = '';
    if (value) {
      if (fill0) {
        time = Tools.rjust(value.hours, 2, '0') + ':' + Tools.rjust(value.minutes, 2, '0');
      } else {
        time = value.hours + ':' + value.minutes;
      }
      if (this.props.format === FORMAT_12) {
        time += ' ' + (value.dayPart || FORMAT_AM);
      }
    }
    return time;
  },


  _parseTime (stringTime) {
    stringTime = stringTime || '00:00';
    stringTime = stringTime.trim();
    let value = null;

    if (typeof stringTime === 'string' && stringTime !== '') {
      value = {
        hours: 0,
        minutes: 0
      };

      if (stringTime.indexOf(':') !== -1) {
        let dateArray = stringTime.split(':');
        value.hours = parseInt(dateArray[0].trim()) || 0;
        value.minutes = parseInt(dateArray[1].trim()) || 0;
      } else {
        value.hours = parseInt(stringTime) || 0;
      }

      if (value.hours < 0 || value.hours > 23 || value.minutes < 0 || value.minutes > 59) {
        value = null;
      } else if (this.props.format === FORMAT_12) {
        if (value.hours > 12) {
          value.hours -= 12;
        } else if (value.hours == 0) {
          value.hours = 12;
        }

        if (stringTime.match(/[Pp]\.?([Mm]\.?)?/)) {
          value.dayPart = FORMAT_PM;
        } else {
          value.dayPart = FORMAT_AM;
        }
      }
    }
    return value;
  },

  _formatDate(date) {

    let result = null;

    let format = (this.state && this.state.format) ? this.state.format : this.props.format;
    let country = (this.state && this.state.country) ? this.state.country : this.props.country;

    if (format) {
      result = Tools.formatDate(date, format);
    } else if (country) {
      result = this._formatDateByCountry(date, this.state.country);
    } else {
      result = date.toLocaleDateString();
    }
    return result;
  },

  _formatDateByCountry(date, country) {
    let result;
    if (Environment.dateTimeFormat[country]) {
      result = Tools.formatDate(date, Environment.dateTimeFormat[country]);
    } else {
      result = date.toLocaleDateString(country);
    }
    return result;
  },

  _parseDate (stringDate) {
    var date = null;
    if (this.props.parseDate && typeof this.props.parseDate === 'function') {
      date = this.props.parseDate(stringDate);
    } else {

      var config = {
        "^(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})$": '$3-$2-$1',
        "^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$": '$3-$1-$2',
        "^(\\d{4})-(\\d{1,2})-(\\d{1,2})$": '$1-$2-$3'
      };

      stringDate = stringDate && stringDate.replace(/ /g, '');

      for (var pattern in config) {
        var regExp = new RegExp(pattern);
        if (regExp.test(stringDate)) {
          var replacedDate = stringDate.replace(regExp, config[pattern]);

          // because of safari and IE must be date in format YYYY-MM-DD (not YYYY-M-D)
          let parser = replacedDate.split('-');
          replacedDate = [parser[0], Tools.rjust(parser[1], 2, '0'), Tools.rjust(parser[2], 2, '0')].join('-');

          date = Date.parse(replacedDate) ? new Date(replacedDate) : null;
          break;
        }
      }
    }
    return date;
  },

  _getCalendarInputAttrs () {
    var props = {};

    if (!this.isReadOnly() && !this.isDisabled()) {
      props.onClick = () => {
        this.openCalendar();
      };
    }

    return props;
  },

  _getTimeInputAttrs () {
    var props = {};

    if (!this.isReadOnly() && !this.isDisabled()) {
      props.onClick = () => {
        this.openTime();
      };
    }

    return props;
  },

  _getMainAttrs(){
    let attrs = this._getInputAttrs();

    if (this.isOpen()) {
      attrs.className += ' ' + this.getClassName().open;
    }

    return attrs;
  },

  _getPlacehoder(){
    let format = this.state.format || Environment.dateTimeFormat[this.state.country];
    let placeholder = format;
    if (this.props.placeholder && format) {
      placeholder = this.props.placeholder + ' - ' + format;
    } else if (this.props.placeholder) {
      placeholder = this.props.placeholder;
    }
    return placeholder;
  },

  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render () {
    let inputId = this.getId() + '-input';
    let buttons = !this.isReadOnly() && !this.props.buttonHidden ? [{
        glyphicon: this.isOpen() ? this.props.calendarGlyphiconOpen : this.props.calendarGlyphiconClosed,
        disabled: this.isDisabled(),
        onClick: () => this.toggleCalendar(),
        pressed: this._isCalendarOpen(),
        colorSchema: 'default'
      }, {
        glyphicon: this._isTimeOpen() ? this.props.timeGlyphiconOpen : this.props.timeGlyphiconClosed,
        disabled: this.isDisabled(),
        onClick: () => this.toggleTime(),
        pressed: this._isTimeOpen(),
        colorSchema: 'default'
      }] : null;

    let date = this.state.dateString;
    let time = this.state.timeString;

    return (
      <div {...this._getMainAttrs()}>
        {this.getLabel(inputId)}
        {this.getInputWrapper([
            <TextInput
              id={inputId}
              name={this.props.name || inputId}
              value={date || ''}
              placeholder={this._getPlacehoder()}
              type='text'
              onChange={this._onChangeCalendar}
              onBlur={this._onBlurCalendar}
              onFocus={this.onFocus}
              mainAttrs={this._getCalendarInputAttrs() || this.props.inputAttrs}
              disabled={this.isDisabled() || this.isLoading()}
              readonly={this.isReadOnly()}
              glyphicon={this._getFeedbackIcon()}
              loading={this.isLoading()}
              feedback={this.state.feedback}
              message={this.state.message}
            />,
            <TextInput
              id={inputId}
              name={this.props.name || inputId}
              value={time || ''}
              placeholder={this.props.placeholderTime}
              type='text'
              onChange={this._onChangeTime}
              onBlur={this._onBlurTime}
              onFocus={this.onFocus}
              mainAttrs={this._getTimeInputAttrs() || this.props.inputAttrs}
              disabled={this.isDisabled() || this.isLoading()}
              readonly={this.isReadOnly()}
              glyphicon={this._getFeedbackIcon()}
              loading={this.isLoading()}
              feedback={this.state.feedback}
              message={this.state.message}
            />,

            <Calendar {...this._getCalendarProps()} />,
            <Time {...this._getTimeProps(this._parseTime(time))} />,
            <Backdrop {...this._getBackdropProps()} />
          ],
          buttons)}

      </div>
    );
  }
  //@@viewOn:render
});

export default Datetimepicker;
