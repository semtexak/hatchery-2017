import React from 'react';
import {BaseMixin, ElementaryMixin, LsiMixin, Tools} from './../../common/common.js';

import Glyphicon from './../../bricks/glyphicon.js';
import Link from './../../bricks/link.js';

import './text-input.less';

const INPUT_TYPE_TEXT = 'text';
const INPUT_TYPE_PASSWORD = 'password';
const INPUT_TYPE_TEXTAREA = 'textarea';

export default React.createClass({

  //@@viewOn:mixins
  mixins: [
    BaseMixin,
    ElementaryMixin,
    LsiMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: "UU5.Forms.TextInput",
    classNames: {
      main: "uu5-forms-text-input",
      loading: 'uu5-forms-input-loading-icon',
      item: 'uu5-forms-input-form-item',
      text: 'uu5-forms-input-form-item-text',
      textarea: 'uu5-forms-input-form-item-textarea',
      hiddenDiv: 'uu5-forms-input-hidden-div',
      hiddenTextarea: 'uu5-forms-input-hidden-textarea',
      autoResizeTextarea: 'uu5-forms-input-auto-resize-textarea'
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    value: React.PropTypes.string,
    placeholder: React.PropTypes.oneOfType([
      React.PropTypes.object,
      React.PropTypes.string
    ]),
    type: React.PropTypes.oneOf([INPUT_TYPE_TEXT, INPUT_TYPE_PASSWORD, INPUT_TYPE_TEXTAREA]),
    onChange: React.PropTypes.func,
    onBlur: React.PropTypes.func,
    onFocus: React.PropTypes.func,
    onKeyDown: React.PropTypes.func,
    glyphicon: React.PropTypes.string,
    loading: React.PropTypes.bool,
    rows: React.PropTypes.number,
    glyphiconOnClick: React.PropTypes.func,
    textGlyphicon: React.PropTypes.bool,
    autoResize: React.PropTypes.bool,
    maxRows: React.PropTypes.number
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps: function () {
    return {
      value: '',
      placeholder: null,
      type: INPUT_TYPE_TEXT,
      onChange: null,
      onBlur: null,
      onFocus: null,
      onKeyDown: null,
      glyphicon: null,
      loading: false,
      rows: null,
      glyphiconOnClick: null,
      textGlyphicon: false,
      autoResize: false,
      maxRows: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  componentDidMount() {
    if (this.props.autoResize || this.props.maxRows) {
      this._setHeight()
    }
  },

  componentDidUpdate(prevProps, prevState) {
    if ((this.props.autoResize || this.props.maxRows) && prevProps.value !== this.props.value) {
      this._setHeight(() => {
        let textArea = document.getElementById(this.getId());
        textArea && (textArea.scrollTop = textArea.scrollHeight);
      })
    }
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getPlaceholder(){
    let placeholder;
    if (this.props.placeholder) {
      if (typeof this.props.placeholder === 'string') {
        placeholder = this.props.placeholder;
      } else if (typeof this.props.placeholder === 'object') {
        placeholder = this.getLSIItem(this.props.placeholder);
      }
    }

    return placeholder;
  },

  _getTextInput(){
    let input;
    let className = this.getClassName().item;
    if (this.props.type === INPUT_TYPE_TEXT || this.props.type === INPUT_TYPE_PASSWORD) {
      className += ' ' + this.getClassName().text;
    } else if (this.props.type === INPUT_TYPE_TEXTAREA) {
      className += ' ' + this.getClassName().textarea;
    }

    let mainAttrs = this.props.mainAttrs ? Tools.merge({}, this.props.mainAttrs) : null;
    let onKeyDown = this.props.onKeyDown;
    if (mainAttrs && typeof mainAttrs.onKeyDown === 'function') {
      let mainAttrsKeyDown = mainAttrs.onKeyDown;
      onKeyDown = (e) => {
        this.props.onKeyDown(e);
        mainAttrsKeyDown(e);
      };
      delete mainAttrs.onKeyDown;
    }

    let inputProps = {
      id: this.getId(),
      name: this.props.name,
      placeholder: this._getPlaceholder(),
      value: this.props.value,
      type: this.props.type,
      onChange: this.props.onChange,
      onBlur: this.props.readonly ? null : this.props.onBlur,
      onFocus: this.props.onFocus,
      readOnly: this.props.readonly,
      disabled: this.props.disabled,
      className: className,
      onKeyDown: onKeyDown
    };

    mainAttrs && (inputProps = Tools.merge(inputProps, mainAttrs));

    if (this.props.type === INPUT_TYPE_TEXT || this.props.type === INPUT_TYPE_PASSWORD) {
      input = <input {...inputProps} />;
    } else if (this.props.type === INPUT_TYPE_TEXTAREA) {
      if (this.props.autoResize || this.props.maxRows) {
        let style = {
          maxHeight: this._getMaxHeight(),
          height: this.state.height,
          overflow: this.state.autoResizeOverflow ? this.state.autoResizeOverflow : 'hidden'
        };

        input = [
          <textarea key="textarea" {...inputProps} rows={this.props.rows} ref={c => this._textarea = c} style={style}/>,
          this._createHiddenTextarea(inputProps.className, this.props.value)
        ]
      } else {
        input = <textarea {...inputProps} rows={this.props.rows}/>
      }
    }
    return input;
  },

  _getFeedbackIcon(){
    let result;
    if (this.props.loading) {
      result = <span className={this.getClassName().loading}/>;
    } else if (this.props.textGlyphicon && typeof this.props.glyphiconOnClick === 'function') {
      result = (<Link
        className='uu5-forms-text-glyphicon-link'
        onClick={(link, e) => {
          e.stopPropagation();
          this.props.glyphiconOnClick();
        }}
      >
        <Glyphicon glyphicon={this.props.glyphicon}/>
      </Link>);
    } else {
      result = <Glyphicon glyphicon={this.props.glyphicon}/>;
    }

    return result;
  },

  _createHiddenTextarea(style, value) {
    return (
      <div key="textarea-hidden" className={this.getClassName().hiddenDiv}>
        <textarea
          className={`${this.getClassName().hiddenTextarea} ${style}`}
          value={value}
          readOnly
          ref={(item) => this._hiddenTextarea = item}
        />
      </div>
    )
  },

  _getNewHeightOfTextarea() {
    let calculatedHeight = this._hiddenTextarea.scrollHeight;

    let textareaStyle = window.getComputedStyle(this._textarea);
    let minHeight = (parseFloat(textareaStyle.lineHeight) * this.props.rows) +
      parseFloat(textareaStyle.paddingTop) + parseFloat(textareaStyle.paddingBottom) +
      parseFloat(textareaStyle.borderTopWidth) + parseFloat(textareaStyle.borderBottomWidth);

    return Math.max(minHeight, calculatedHeight)
  },

  _getStyleOverflow(calculatedHeight) {
    let textareaStyle = window.getComputedStyle(this._textarea);
    let maxHeight = parseFloat(textareaStyle.maxHeight);
    isNaN(maxHeight) && (maxHeight = this._getMaxHeight());

    return (calculatedHeight > maxHeight) ? 'auto' : 'hidden'
  },

  _setHeight(setStateCallback) {
    let height = this._getNewHeightOfTextarea();
    if (height !== this.state.height) {
      this.setState({height, autoResizeOverflow: this._getStyleOverflow(height)}, setStateCallback)
    }
  },

  _getMaxHeight() {
    let maxHeight;
    if (this.props.maxRows && this._textarea) {
      let textareaStyle = window.getComputedStyle(this._textarea);
      maxHeight = (parseFloat(textareaStyle.lineHeight) * this.props.maxRows) +
        parseFloat(textareaStyle.paddingTop) + parseFloat(textareaStyle.paddingBottom) +
        parseFloat(textareaStyle.borderTopWidth) + parseFloat(textareaStyle.borderBottomWidth);
    }

    return maxHeight
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    return (
      <div className={this.getFullClassName()}>
        {this._getTextInput()}
        {this._getFeedbackIcon()}
      </div>
    );
  }
  //@@viewOn:render
});
