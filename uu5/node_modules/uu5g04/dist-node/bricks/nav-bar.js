import React from 'react';
import {
  BaseMixin,
  ElementaryMixin,
  ContentMixin,
  ColorSchemaMixin,
  Tools,
  NestingLevelMixin
} from '../common/common.js';
import Environment from '../environment/environment.js';
import Header from './nav-bar-header.js';
import Nav from './nav-bar-nav.js';
import NavBarNavItem from './nav-bar-nav-item.js';

import './nav-bar.less';

export const NavBar = React.createClass({

  //@@viewOn:mixins
  mixins: [
    BaseMixin,
    ElementaryMixin,
    ContentMixin,
    ColorSchemaMixin,
    NestingLevelMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: 'UU5.Bricks.NavBar',
    nestingLevelList: Environment.getNestingLevelList('bigBoxCollection', 'box'),
    classNames: {
      main: 'uu5-bricks-nav-bar navbar',
      body: 'uu5-bricks-nav-bar-body container-fluid',
      navCover: 'uu5-bricks-nav-bar-cover',
      navContainer: 'uu5-bricks-nav-bar-container',
      open: 'uu5-bricks-nav-bar-open'
    },
    defaults: {
      tagNames: {
        header: 'UU5.Bricks.NavBar.Header',
        nav: 'UU5.Bricks.NavBar.Nav'
      },
      duration: 250
    },
    warnings: {
      cannotOpenIfAlwaysOpen: 'Cannot open navBar if alwaysOpen is set to true.',
      cannotCloseIfAlwaysOpen: 'Cannot close navBar if alwaysOpen is set to true.',
      cannotToggleIfAlwaysOpen: 'Cannot toggle navBar if alwaysOpen is set to true.'
    },
    opt: {
      nestingLevelWrapper: true
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    fixed: React.PropTypes.oneOf(['top', 'bottom']),
    smoothScroll: React.PropTypes.number,
    offset: React.PropTypes.number,
    open: React.PropTypes.bool,
    alwaysOpen: React.PropTypes.bool,
    glyphiconOpen: React.PropTypes.string,
    glyphiconClosed: React.PropTypes.string,
    onOpen: React.PropTypes.func,
    onClose: React.PropTypes.func
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      fixed: null,
      smoothScroll: null,
      offset: null,
      open: false,
      alwaysOpen: false,
      glyphiconOpen: 'uu-glyphicon-menu',
      glyphiconClosed: 'uu-glyphicon-menu',
      onOpen: null,
      onClose: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      height: this._getHeight(this.props.open),
      offset: this.props.offset,
      expanded: this.props.open
    };
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      var newState = {};
      (nextProps.alwaysOpen || nextProps.open) && this.open();
      if (nextProps.offset !== undefined && nextProps.offset !== this.getOffset()) {
        newState.offset = nextProps.offset;
      }
      this.setState(newState);
    }
  },

  componentDidMount() {
    var newState = {};

    if (this.props.fixed === 'top' && !this.state.offset) {
      newState.offset = Tools.getOuterHeight(this);
    }

    if (this.props.alwaysOpen || this.props.open) {
      newState.height = null;
      newState.offset && (newState.offset += newState.height);
    }

    Object.keys(newState).length && this.setState(newState);
  },
  
  shouldComponentUpdate(nextProps, nextState) {
    return this.shouldRender(nextProps, nextState);
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  isNavBar() {
    return true;
  },

  isOpen() {
    return this.state.expanded;
  },

  open(setStateCallback) {
    if (!this.props.alwaysOpen) {
      if (!this.state.expanded) {
        var height = this._getHeight(true);
        this.setState({height: 0, expanded: true}, () => {
          this.setState({height: height}, () => {
            this._timer && clearTimeout(this._timer);
            this._timer = setTimeout(
              () => this.setAsyncState({height: null}, setStateCallback),
              this.getDefault().duration
            );
          });
        });
      }
    } else if (typeof setStateCallback === 'function') {
      this.showWarning('cannotOpenIfAlwaysOpen');
    }
    return this;
  },

  close(setStateCallback) {
    if (!this.props.alwaysOpen) {

      var height = this._getHeight(true);
      this.setState({height: height}, () => {
        // TODO: must to be timeout because of animation
        setTimeout(() => this.setAsyncState({height: 0, expanded: false}, setStateCallback), 0);
      });

    } else if (typeof setStateCallback === 'function') {
      this.showWarning('cannotCloseIfAlwaysOpen');
    }
    return this;
  },

  toggle(setStateCallback) {
    if (!this.props.alwaysOpen) {
      // TODO: to setState function
      this.state.expanded ? this.close(setStateCallback) : this.open(setStateCallback);
    } else if (typeof setStateCallback === 'function') {
      this.showWarning('cannotToggleIfAlwaysOpen', null);
    }
    return this;
  },

  getOffset() {
    return this.state.offset;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _getHeight(expanded) {
    return (expanded && this._container) ? Tools.getOuterHeight(this._container, true) : 0;
  },

  _getMainAttrs() {
    var mainAttrs = this.buildMainAttrs();
    mainAttrs.className += this.getColorSchema('darkgrey') ? ' navbar-inverse' : '';
    this.props.fixed && (mainAttrs.className += ' navbar-fixed-' + this.props.fixed);
    this.isOpen() && (mainAttrs.className += ' ' + this.getClassName().open);

    mainAttrs.style = mainAttrs.style || {};
    var time = this.getDefault().duration / 1000;
    ['WebkitTransitionDuration', 'MozTransitionDuration', 'MsTransitionDuration',
      'OTransitionDuration', 'transitionDuration'].forEach(function (style) {
      mainAttrs.style[style] = time + 's';
    });

    return mainAttrs;
  },

  _prepareHeader(headerProps) {
    var headerPropsToPass = {
      id: this.getId() + '-header',
      parent: this
    };

    var newHeaderProps = headerProps ? Tools.mergeDeep(headerPropsToPass, headerProps) : headerPropsToPass;
    newHeaderProps._glyphicon = this.isOpen() ? this.props.glyphiconOpen : this.props.glyphiconClosed;
    newHeaderProps._hamburger = !this.props.alwaysOpen;
    newHeaderProps._onOpen = typeof this.props.onOpen === 'function' ? this.props.onOpen : null;
    newHeaderProps._onClose = typeof this.props.onClose === 'function' ? this.props.onClose : null;

    return <Header {...newHeaderProps} />;
  },

  _prepareNavs(navsProps) {
    return navsProps.map(function (props, i) {
      props.key = props.key || 'nav-' + i;
      return <Nav {...props} />;
    });
  },

  _prepareChildren(children) {
    var navBar = this;
    var headerProps = null;

    var newNavProps = {smoothScroll: this.props.smoothScroll, offset: this.getOffset(), parent: this};
    var navsProps = [];

    children && children.map(function (child) {
      var childTagName = Tools.getChildTagName(child);

      switch (childTagName) {
        case navBar.getDefault().tagNames.header:
          headerProps = child.props;
          break;
        case navBar.getDefault().tagNames.nav:
          // TODO: max 3?
          var newProps = {};
          // default values is used if child is set as react element so null or undefined will not set!!!
          for (var key in child.props) {
            child.props[key] !== null && child.props[key] !== undefined && (newProps[key] = child.props[key]);
          }
          navsProps.push(Tools.merge({}, newNavProps, newProps));
          break;
      }
    });

    navsProps.length === 0 && navsProps.push(newNavProps);

    return {
      header: this._prepareHeader(headerProps),
      navs: this._prepareNavs(navsProps)
    };
  },

  _getNavContainerId() {
    return this.getId() + '-navContainer';
  },

  _getNavCoverId() {
    return this.getId() + '-navCover';
  },

  _getNavHeight() {
    return this.state.height;
  },

  _countNavHeight() {
    return Tools.getOuterHeight(this._container, true);
  },

  _getNavCoverProps() {
    return {
      className: this.getClassName().navCover,
      id: this._getNavCoverId(),
      style: {
        height: this._getNavHeight()
      }
    };
  },

  _getNavContainerProps() {
    return {
      id: this._getNavContainerId(),
      className: this.getClassName().navContainer
    };
  },

  _getNavBodyProps() {
    return {
      className: this.getClassName().body
    }
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    var childrenObject = this._prepareChildren(this.getChildren());
    var attrs = this._getMainAttrs();
    !this.getColorSchema() && (attrs.className += ' navbar-default');

    return (
      <nav {...attrs}>
        <div {...this._getNavBodyProps()}>
          {childrenObject.header}

          <div {...this._getNavCoverProps()}>
            <div {...this._getNavContainerProps()} ref={(navContainer) => this._container = navContainer}>
              {childrenObject.navs}
            </div>
          </div>
        </div>
        {this.getDisabledCover()}
      </nav>
    );
  }
  //@@viewOff:render
});

NavBar.Header = Header;
NavBar.Nav = Nav;
NavBar.Nav.Item = NavBarNavItem;

export default NavBar;
