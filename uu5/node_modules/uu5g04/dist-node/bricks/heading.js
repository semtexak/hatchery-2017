import React from 'react';
import {BaseMixin, ElementaryMixin, ContentMixin, NestingLevelMixin} from '../common/common.js';
import Environment from '../environment/environment.js';

import './heading.less';

export const Heading = React.createClass({

  //@@viewOn:mixins
  mixins: [
    BaseMixin,
    ElementaryMixin,
    ContentMixin,
    NestingLevelMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: "UU5.Bricks.Heading",
    nestingLevelList: Environment.getNestingLevelList('bigBoxCollection', 'box'),
    classNames: {
      main: "uu5-bricks-heading",
      fixed: "uu5-bricks-heading-fixed"
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    fixed: React.PropTypes.bool,
    fixedOnScroll: React.PropTypes.bool,
    onScrollToFixed: React.PropTypes.func, // not called in interface, just on scroll
    onScrollToBlocked: React.PropTypes.func // not called in interface, just on scroll
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps: function () {
    return {
      fixed: false,
      fixedOnScroll: false,
      onScrollToFixed: null,
      onScrollToBlocked: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState: function () {
    return {
      fixed: this.props.fixed
    };
  },

  componentWillMount: function () {
    this.scrollPosition = 0;
    this.scrollStart = 0;
    return this;
  },

  componentDidMount: function () {
    if (this.props.fixedOnScroll || this.props.onScrollToFixed || this.props.onScrollToBlocked) {
      Environment.EventListener.addWindowEvent('scroll', this.getId(), this._scroll);
      Environment.EventListener.addWindowEvent('wheel', this.getId(), this._scroll);
      Environment.EventListener.addWindowEvent('DOMMouseScroll', this.getId(), this._scroll);
      Environment.EventListener.addWindowEvent('mousewheel', this.getId(), this._scroll);
    }
    return this;
  },

  componentWillReceiveProps: function (nextProps) {
    this.scrollPosition = 0;
    if (nextProps.controlled){
      this.setState({fixed: nextProps.fixed});
      this._scroll(nextProps);
    }
    return this;
  },

  componentWillUnmount: function () {
    if (this.props.fixedOnScroll || this.props.onScrollToFixed || this.props.onScrollToBlocked) {
      Environment.EventListener.removeWindowEvent('scroll', this.getId());
      Environment.EventListener.removeWindowEvent('wheel', this.getId());
      Environment.EventListener.removeWindowEvent('DOMMouseScroll', this.getId());
      Environment.EventListener.removeWindowEvent('mousewheel', this.getId());
    }
  },
  
  shouldComponentUpdate(nextProps, nextState) {
    return this.shouldRender(nextProps, nextState);
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  getOffsetTop: function () {
    let component = document.getElementById(this.getId());
    return component ? component.offsetTop : null;

    // var componentJQuery = $("#" + this.getId());
    // return componentJQuery ? componentJQuery.offset().top : null;
  },

  setFixedValue: function (fixed, setStateCallback) {
    this.setState({fixed: fixed}, setStateCallback);
    return this;
  },

  isFixed: function () {
    return this.state.fixed;
  },

  setFixed: function (setStateCallback) {
    this.setFixedValue(true, setStateCallback);
    return this;
  },

  setBlocked: function (setStateCallback) {
    this.setFixedValue(false, setStateCallback);
    return this;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _scroll: function (props) {
    props = props || this.props;

    var scrollPosition = window.scrollY;
    var scrollStart = this.getOffsetTop();

    if (scrollPosition > scrollStart && this.scrollPosition <= scrollStart) {
      //console.log(true, {oldScrollPosition: this.scrollPosition, newScrollPosition: scrollPosition, oldScrollStart: this.scrollOffsetStart, newScrollStart: scrollOffsetStart});
      this.scrollPosition = scrollPosition;
      this.scrollStart = scrollStart;

      if (typeof props.onScrollToFixed === 'function') {
        props.onScrollToFixed(this, scrollPosition, scrollStart);
      } else if (props.fixedOnScroll) {
        this.setFixed();
      }
    } else if (scrollPosition <= this.scrollStart && this.scrollPosition > scrollStart) {
      //console.log(false, {oldScrollPosition: this.scrollPosition, newScrollPosition: 0, oldScrollStart: this.scrollOffsetStart, newScrollStart: 0});

      this.scrollPosition = 0;
      this.scrollStart = 0;

      if (typeof props.onScrollToBlocked === 'function') {
        props.onScrollToBlocked(this, scrollPosition, scrollStart);
      } else if (props.fixedOnScroll) {
        this.setBlocked();
      }
    }
    return this;
  },

  _getMainAttrs: function () {
    var mainAttrs = this.buildMainAttrs();

    mainAttrs.id = this.getId();
    this.state.fixed && (mainAttrs.className += " " + this.getClassName().fixed);

    return mainAttrs;
  },
  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render: function () {
    return (
      this.getNestingLevel()
        ? (
          <div {...this._getMainAttrs()}>
            {this.getChildren()}
            {this.getDisabledCover()}
          </div>
        ) : null
    );
  }
  //@@viewOff:render
});

export default Heading;
