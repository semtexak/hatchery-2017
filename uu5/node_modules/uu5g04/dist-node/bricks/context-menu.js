import React from 'react';
import ReactDOM from 'react-dom';
import {BaseMixin, ElementaryMixin, SectionMixin, CcrWriterMixin, Tools, NestingLevelMixin} from '../common/common.js';
import Environment from '../environment/environment.js';
//import {FloatMixin} from '../layout/layout.js';
import {Div} from './bricks.js';
import ContextMenuItem from './context-menu-item.js';

import './context-menu.less';

export const ContextMenu = React.createClass({

  //@@viewOn:mixins
  mixins: [
    BaseMixin,
    ElementaryMixin,
    SectionMixin,
    CcrWriterMixin,
    //FloatMixin,
    NestingLevelMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: 'UU5.Bricks.ContextMenu',
    nestingLevelList: Environment.getNestingLevelList('bigBoxCollection', 'box'),
    classNames: {
      main: 'uu5-bricks-context-menu',
      open: 'uu5-bricks-context-menu-shown',
      content: 'uu5-bricks-context-menu-content',
      header: 'uu5-bricks-context-menu-header',
      footer: 'uu5-bricks-context-menu-footer',
      top: 'uu5-bricks-context-menu-top',
      bottom: 'uu5-bricks-context-menu-bottom',
      left: 'uu5-bricks-context-menu-left',
      right: 'uu5-bricks-context-menu-right'
    },
    defaults: {
      transitionDuration: 100,
      childTagName: 'UU5.Bricks.ContextMenu.Item'
    },
    opt: {
      nestingLevelRoot: true
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    shown: React.PropTypes.bool,
    parentElement: React.PropTypes.object,
    allowTags: React.PropTypes.arrayOf(
      React.PropTypes.string
    )
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      shown: false,
      parentElement: null,
      allowTags: []
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      header: null,
      content: null,
      footer: null,
      pageX: null,
      pageY: null,
      position: {
        top: false,
        left: false
      }
    };
  },

  componentWillMount() {
    this.setState({ hidden: !this.props.shown });
  },

  componentWillReceiveProps(nextProps){
    if (nextProps.controlled) {
      this.setState({ hidden: !nextProps.shown });
    }
  },

  componentWillUnmount: function () {
    Environment.EventListener.removeWindowEvent('click', this.getId());
  },

  shouldComponentUpdate(nextProps, nextState) {
    return this.shouldRender(nextProps, nextState);
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  open(opt, setStateCallback) {
    this._addEvent();

    let pageX = opt.pageX;
    let pageY = opt.pageY;
    let position = Tools.mergeDeep({},this.state.position);

    if (opt.event) {
      opt.event.preventDefault();
      opt.event.stopPropagation();
      pageX = pageX || opt.event.pageX;
      pageY = pageY || opt.event.pageY;
    }

    let parent;
    if (this.props.parentElement) {
      parent = ReactDOM.findDOMNode(this.props.parentElement);
    } else {
      parent = Tools.getElementByComputedStyle(document.getElementById(this.getId()), 'position', 'relative');
    }
    if (parent) {
      let parentX = Tools.getOffsetLeft(parent);
      let parentY = Tools.getOffsetTop(parent);
      pageX = pageX - parentX;
      pageY = pageY - parentY;
    }

    this.setState({
      position: position,
      header: opt.header || this.getHeader(),
      content: opt.content || this.getChildren(),
      footer: opt.footer || this.getFooter(),
      hidden: true,
      pageX: 0,
      pageY: 0
    }, () => {
      let parentHeight = parent ? Tools.getInnerHeight(parent) : window.innerHeight;
      let parentWidth = parent ? Tools.getInnerWidth(parent) : window.innerWidth;
      if (parentHeight < (pageY + Tools.getOuterHeight(this, true))) {
        pageY = pageY - Tools.getOuterHeight(this, true);
        position.top = true;
      } else {
        position.top = false;
      }

      if (parentWidth < (pageX + Tools.getOuterWidth(this, true))) {
        pageX = pageX - Tools.getOuterWidth(this, true);
        position.left = true;
      } else {
        position.left = false;
      }
      this.setState({
        hidden: false,
        pageX: pageX,
        pageY: pageY
      }, () => {
        typeof setStateCallback === 'function' && setStateCallback();
      });
    });
    return this;
  },

  close(setStateCallback) {
    this._removeEvent();

    this.setState({
      // header: null,
      // content: null,
      // footer: null,
      hidden: true
    }, setStateCallback);

    return this;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  shouldChildRender_(child) {
    let childTagName = Tools.getChildTagName(child);
    let childTagNames = this.props.allowTags.concat(this.getDefault().childTagName);
    return childTagNames.indexOf(childTagName) > -1;
  },
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _findTarget(item) {
    let result = false;
    let id = this.getId();

    if (item.id === id) {
      result = true;
    } else if (item.parentElement) {
      result = this._findTarget(item.parentElement);
    }

    return result;
  },

  _addEvent(){
    Environment.EventListener.addWindowEvent('click', this.getId(), (e) => {
      let isMenu = this._findTarget(e.target);

      if (!this._stopPropagation && !isMenu && !this.isHidden()) {
        this.close();
      } else {
        this._stopPropagation = false;
      }
    });
    return this;
  },

  _removeEvent(){
    Environment.EventListener.removeWindowEvent('click', this.getId());
    return this;
  },

  _getMainAttrs() {
    let props = this.getMainAttrs();

    props.id = this.getId();

    !this.isHidden() && (props.className += ' ' + this.getClassName().open);
    props.className += this.state.position.top ? ' ' + this.getClassName('top') : ' ' + this.getClassName('bottom');
    props.className += this.state.position.left ? ' ' + this.getClassName('left') : ' ' + this.getClassName('right');

    props.style = {};
    if (this.state.pageX !== null) {
      props.style = {
        left: this.state.pageX,
        top: this.state.pageY
      };
    }

    //opera mini dont know how to use transitions :(
    if (navigator.userAgent.indexOf('Opera Mini') == -1) {
      let time = this.getDefault().transitionDuration / 1000;
      ['WebkitTransitionDuration', 'MozTransitionDuration', 'MsTransitionDuration',
        'OTransitionDuration', 'transitionDuration'].forEach((style) => {
        // props.style[style] = time + 's';
      });
    }
    props.nestingLevel = this.getNestingLevel();

    return props;
  },

  _getHeader(){
    let header = this.state.header || this.getHeader();
    if (header) {
      header = <div className={this.getClassName().header}>{header}</div>;
    }
    return header;
  },

  _getFooter(){
    let footer = this.state.footer || this.getFooter();
    if (footer) {
      footer = <div className={this.getClassName().footer}>{footer}</div>;
    }
    return footer;
  },

  //@@viewOff:componentSpecificHelpers

  //@@viewOn:render
  render() {
    let children = this.buildChildren({ content: this.state.content, children: this.props.children });

    return (
      <Div {...this._getMainAttrs()}>
        <div className={this.getClassName().content}>
          {this._getHeader()}
          {children}
          {this._getFooter()}
        </div>
        {this.getDisabledCover()}
      </Div>
    );
  }
  //@@viewOff:render
});

ContextMenu.Item = ContextMenuItem;
export default ContextMenu;
