import React from 'react';
import {BaseMixin, ElementaryMixin, ContentMixin, NestingLevelMixin} from '../common/common.js';
import Environment from '../environment/environment.js';
//import {FloatMixin} from '../layout/layout.js';
import DraggableMixin from './draggable-mixin.js';
import {Div} from './bricks.js';
import './draggable-item.less'

export const DraggableItem = React.createClass({

  //@@viewOn:mixins
  mixins: [
    BaseMixin,
    ElementaryMixin,
    ContentMixin,
    DraggableMixin,
    //FloatMixin,
    NestingLevelMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: 'UU5.Bricks.DraggableItem',
    nestingLevelList: Environment.getNestingLevelList('bigBoxCollection', 'box'),
    classNames: {
      main: 'uu5-bricks-draggable-item'
    },
    errors: {
      invalidParentType: "Parrent of the component does not have DraggableMixin."
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    x: React.PropTypes.number,
    y: React.PropTypes.number,
    onMoveStart: React.PropTypes.func,
    onMove: React.PropTypes.func,
    onMoveEnd: React.PropTypes.func
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      x: 0,
      y: 0,
      onMoveStart: null,
      onMove: null,
      onMoveEnd: null
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  getInitialState() {
    return {
      x: this.props.x,
      y: this.props.y
    };
  },

  componentWillMount() {
    this.draggableParent = this.getParentByType('hasUU5_Bricks_DraggableMixin');
    return this;
  },

  componentDidMount() {
    if (this.draggableParent) {
      this.setState((state) => {
        return {
          x: state.x + this.draggableParent.getXOffset() + this.draggableParent.getClientLeft() + this.draggableParent.getPaddingLeft(),
          y: state.y + this.draggableParent.getYOffset() + this.draggableParent.getClientTop() + this.draggableParent.getPaddingTop()
        }
      });
    } else {
      this.showError('invalidParentType')
    }
    return this;
  },

  shouldComponentUpdate(nextProps, nextState) {
    return this.shouldRender(nextProps, nextState);
  },

  componentWillReceiveProps(nextProps){
    if (nextProps.controlled) {
      this.setState({
        x: nextProps.x,
        y: nextProps.y
      });
    }
    return this;
  },

  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  moveToPosition(x, y) {
    if (x || y) {
      if (typeof this.props.onMove === 'function') {
        this.props.onMove({component: this, x: x, y: y})
      } else {
        this.setPosition(x, y)
      }
    }
    return this;
  },

  setPosition(x, y, setStateCallback) {
    x = isNaN(x) ? 0 : x;
    y = isNaN(y) ? 0 : y;
    this.setState((state) => {
      return {
        x: x + state.x,
        y: y + state.y
      }
    }, setStateCallback);
    return this;
  },

  moveEnd() {

    typeof this.props.onMoveEnd === 'function' && this.props.onMoveEnd();
    return this;
  },

  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _onMouseDown(e) {
    var onStart;
    if (typeof this.props.onMoveStart === 'function') {
      onStart = this.props.onMoveStart();
    }
    if (onStart !== false) {
      var x = e.pageX || e.touches[0].pageX;
      var y = e.pageY || e.touches[0].pageY;

      this.draggableParent.dragStart(this, x, y);
    }

    return this;
  },
  //@@viewOff:componentSpecificHelpers

  // Render

  //@@viewOn:render
  render() {

    return (
      this.getNestingLevel()
        ? (
          <div {...this.buildMainAttrs()}
               onMouseDown={this._onMouseDown}
               onTouchStart={this._onMouseDown}
               style={{
                 left: this.state.x,
                 top: this.state.y
               }}>
            {this.getChildren()}
            {this.getDisabledCover()}
          </div>
        ) : null
    );
  }
  //@@viewOff:render
});

export default DraggableItem;
