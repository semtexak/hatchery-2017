import React from 'react';
import {BaseMixin, ElementaryMixin, SectionMixin, Tools, NestingLevelMixin, CcrReaderMixin} from '../common/common.js';
import Environment from '../environment/environment.js';
import Header from './modal-header.js';
import Body from './modal-body.js';
import Footer from './modal-footer.js';

import './modal.less';

export const Modal = React.createClass({

  //@@viewOn:mixins
  mixins: [
    BaseMixin,
    ElementaryMixin,
    SectionMixin,
    //FloatMixin,
    NestingLevelMixin,
    CcrReaderMixin
  ],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: 'UU5.Bricks.Modal',
    nestingLevelList: Environment.getNestingLevelList('bigBoxCollection', 'box'),
    classNames: {
      main: 'uu5-bricks-modal modal',
      dialog: 'uu5-bricks-modal-dialog modal-dialog modal-',
      content: 'uu5-bricks-modal-dialog modal-content'
    },
    defaults: {
      header: 'noHeader',
      body: 'noBody',
      animationDuration: 150, // ms
      closeTypes: {
        closedButton: 'closedButton',
        blur: 'blur',
        ifc: 'interface'
      }
    },
    opt: {
      nestingLevelRoot: true
    }
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    size: React.PropTypes.oneOf(['sm', 'md', 'lg']),
    shown: React.PropTypes.bool,
    sticky: React.PropTypes.bool,
    stickyBackground: React.PropTypes.bool,
    scrollableBackground: React.PropTypes.bool,
    onClose: React.PropTypes.func
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      size: 'md',
      shown: false,
      sticky: false,
      stickyBackground: false,
      scrollableBackground: false,
      onClose: null
    };
  },

  getInitialState() {
    return {
      header: this.getHeader(),
      content: this.getContent() || this.props.children,
      footer: this.getFooter(),
      className: null,
      size: this.props.size,
      sticky: this.props.sticky,
      stickyBackground: this.props.stickyBackground,
      scrollableBackground: this.props.scrollableBackground,
      onClose: this.props.onClose
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:standardComponentLifeCycle
  componentWillMount() {
    this.props.shown ? this.open() : this.hide();
  },

  componentDidMount() {
    if (!this.isSticky()) {
      Environment.EventListener.addWindowEvent('keyup', this.getId(), this._onCloseESC);
    }
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled) {
      this.setState(function (state) {
        let newState = {};

        if (nextProps.shown && state.hidden) {
          newState.hidden = false;
        } else if (!nextProps.shown && !state.hidden) {
          newState.hidden = true;
        }

        newState.header = nextProps.header;
        newState.footer = nextProps.footer;
        newState.content = nextProps.content || nextProps.children || this.state.content;
        newState.size = nextProps.size;
        newState.sticky = nextProps.sticky;
        newState.stickyBackground = nextProps.stickyBackground;
        newState.scrollableBackground = nextProps.scrollableBackground;
        newState.onClose = nextProps.onClose;

        return newState;
      });
    }
  },

  shouldComponentUpdate(nextProps, nextState) {
    return this.shouldRender(nextProps, nextState);
  },

  componentWillUnmount() {
    Environment.EventListener.removeWindowEvent('keyup', this.getId(), this._onCloseESC);
  },
  //@@viewOff:standardComponentLifeCycle

  //@@viewOn:interface
  open: function (openProps, setStateCallback) {
    let page = this.getCcrComponentByKey(Environment.CCRKEY_PAGE);
    if (page && page.getModal() && page.getModal().props.ccrKey !== this.props.ccrKey) {
      let centralModal = page.getModal();
      let newProps = Tools.merge(this.props, openProps);
      centralModal.open(newProps, setStateCallback);
    } else {
      this._stopScroll();
      let newState = {
        hidden: false
      };

      openProps = openProps || {};
      newState.header = openProps.header === undefined ? this.props.header : openProps.header;
      newState.footer = openProps.footer === undefined ? this.props.footer : openProps.footer;
      newState.content = openProps.content === undefined ? this.props.content : openProps.content;
      newState.className = openProps.className === undefined ? this.props.className : openProps.className;
      newState.size = openProps.size === undefined ? this.props.size : openProps.size;
      newState.sticky = openProps.sticky === undefined ? this.props.sticky : openProps.sticky;
      newState.stickyBackground = openProps.stickyBackground === undefined ? this.props.stickyBackground : openProps.stickyBackground;
      newState.scrollableBackground = openProps.scrollableBackground === undefined ? this.props.scrollableBackground : openProps.scrollableBackground;
      newState.onClose = openProps.onClose === undefined ? this.props.onClose : openProps.onClose;

      this.setState(newState, setStateCallback);
    }
    return this;
  },

  close: function (shouldOnClose, setStateCallback) {
    let page = this.getCcrComponentByKey(Environment.CCRKEY_PAGE);

    if (page && page.getModal() && page.getModal().props.ccrKey !== this.props.ccrKey) {
      let centralModal = page.getModal();
      centralModal.close(shouldOnClose, setStateCallback);
    } else if (typeof this.state.onClose === 'function' && shouldOnClose !== false) {
      this.state.onClose({ component: this, closeType: this.getDefault().closeTypes.ifc, callback: setStateCallback });
    } else {
      this._close(setStateCallback);
    }
    return this;
  },

  toggle(setStateCallback) {
    let modal = this;
    this.setState((state) => {
      state.hidden ? modal._stopScroll() : modal._startScroll();
      return { hidden: !state.hidden };
    }, setStateCallback);
    return this;
  },

  isSticky() {
    return this.state.sticky;
  },
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  buildHeaderChild_(headerTypes) {
    let headerType = this.getHeaderType(headerTypes);

    let headerChild;
    if (headerType === 'contentOfStandardHeader') {
      headerChild = <Header content={headerTypes.header} />;
      headerChild = this.cloneChild(headerChild, this.expandHeaderProps(headerChild));
    }

    return headerChild;
  },

  expandHeaderProps_(headerChild) {
    let extendedHeaderProps = this._extendPartProps(headerChild.props, 'header');
    if (extendedHeaderProps) {
      extendedHeaderProps._sticky = this.state.sticky;
      extendedHeaderProps._onClose = this._onCloseHandler;
    }
    return extendedHeaderProps;
  },

  buildFooterChild_(footerTypes) {
    let footerType = this.getFooterType(footerTypes);

    let footerChild;
    if (footerType === 'contentOfStandardFooter') {
      footerChild = <Footer content={footerTypes.footer} />;
      footerChild = this.cloneChild(footerChild, this.expandFooterProps(footerChild));
    }

    return footerChild;
  },

  expandFooterProps_(footerChild) {
    return this._extendPartProps(footerChild.props, 'footer');
  },
  //@@viewOff:overridingMethods

  //@@viewOn:componentSpecificHelpers
  _onCloseESC(e) {
    e.which === 27 && !this.isHidden() && this._blur(e);
    return this;
  },

  _onBlurHandler(event) {
    event.target.id === this.getId() && this._blur(event);
    return this;
  },

  _onCloseHandler(e) {
    if (typeof this.state.onClose === 'function') {
      this.state.onClose({ component: this, event: e, closeType: this.getDefault().closeTypes.closedButton });
    } else {
      this._close();
    }
    return this;
  },

  _blur(e) {
    if (typeof this.state.onClose === 'function') {
      this.state.onClose({ component: this, event: e, closeType: this.getDefault().closeTypes.blur });
    } else {
      this._close();
    }
    return this;
  },

  _close(callback) {
    this._startScroll();
    this.hide(callback);
    return this;
  },

  _getScrollbarWidth() {
    let width = 0;

    // if scroll bar is visible
    if (Tools.getDocumentHeight() > window.innerHeight) {
      let div = document.createElement("div");
      div.style.overflow = "scroll";
      div.style.visibility = "hidden";
      div.style.position = 'absolute';
      div.style.width = '100px';
      div.style.height = '100px';

      // temporarily creates a div into DOM
      document.body.appendChild(div);
      try {
        width = div.offsetWidth - div.clientWidth;
      } finally {
        document.body.removeChild(div);
      }
    }

    return width;
  },

  _startScroll() {
    let modal = this;
    // TODO: wrong, but not found better solution
    setTimeout(function () {
      !modal.props.scrollableBackground && (document.body.className = document.body.className.replace('modal-open', ''));
      document.body.style.paddingRight = '';
    }, this.getDefault().animationDuration);
  },

  _stopScroll() {
    // TODO: wrong, but not found better solution
    !this.state.scrollableBackground && (document.body.className = document.body.className ? document.body.className + ' modal-open' : 'modal-open');
    let paddingRight = this._getScrollbarWidth();
    paddingRight && (document.body.style.paddingRight = paddingRight + 'px');
  },

  _getMainAttrs() {
    let mainAttrs = this.buildMainAttrs();

    // id because of checking backdrop on click in _onBlurHandler function
    mainAttrs.id = this.getId();
    this.state.className && (mainAttrs.className += ' ' + this.state.className);
    !this.state.sticky && !this.state.stickyBackground && (mainAttrs.onClick = this._onBlurHandler);

    let sec = (this.getDefault().animationDuration / 1000) + 's';
    mainAttrs.style = mainAttrs.style || {};
    mainAttrs.style.WebkitTransitionDuration = sec;
    mainAttrs.style.MozTransitionDuration = sec;
    mainAttrs.style.OTransitionDuration = sec;
    mainAttrs.style.transitionDuration = sec;

    return mainAttrs;
  },

  _extendPartProps(partProps, part) {
    let newProps = {};

    // default values is used if child is set as react element so null or undefined will not set!!!
    for (let key in partProps) {
      partProps[key] !== null && partProps[key] !== undefined && (newProps[key] = partProps[key]);
    }

    newProps.key = newProps.id;

    return newProps;
  },

  _extendBodyProps(bodyProps) {
    let id = this.getId() + '-body';

    let newProps = {
      id: id
    };

    // default values is used if child is set as react element so null or undefined will not set!!!
    for (let key in bodyProps) {
      bodyProps[key] !== null && bodyProps[key] !== undefined && (newProps[key] = bodyProps[key]);
    }

    return Tools.merge(newProps, { key: newProps.id });
  },
  //@@viewOff:componentSpecificHelpers

  // Render
  _buildChildren() {
    let header = this.state.header;
    let footer = this.state.footer;
    let bodyContent = this.state.content;

    let headerChild;
    let footerChild;

    if (!bodyContent && ((!header && !footer) || header || footer)) {
      header = header || this.getDefault().header;
      bodyContent = bodyContent || this.getDefault().body;
    }

    header && (headerChild = this.buildHeaderChild({ header: header }));
    footer && (footerChild = this.buildFooterChild({ footer: footer }));

    let bodyProps = this._extendBodyProps({ content: bodyContent });

    let bodyChild = this.buildChildren({
      children: React.createElement(Body, bodyProps)
    });

    return [headerChild, bodyChild, footerChild];
  },

  //@@viewOn:render
  render() {
    return (
      this.getNestingLevel() ?
        (
          <div {...this._getMainAttrs()}>
            <div className={this.getClassName().dialog + this.state.size}>
              <div className={this.getClassName().content}>
                {this._buildChildren()}
              </div>
            </div>
            {this.getDisabledCover()}
          </div>
        ) : null
    );
  }
  //@@viewOff:render
});

export default Modal;
